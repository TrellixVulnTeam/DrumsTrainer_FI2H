{"ast":null,"code":"var getNote = require('./load-note');\n\nvar soundsCache = require('./sounds-cache');\n\nvar createNoteMap = require('./create-note-map');\n\nvar registerAudioContext = require('./register-audio-context');\n\nvar activeAudioContext = require('./active-audio-context');\n\nvar supportsAudio = require('./supports-audio');\n\nvar pitchToNoteName = require('./pitch-to-note-name');\n\nvar instrumentIndexToName = require('./instrument-index-to-name');\n\nvar downloadBuffer = require('./download-buffer');\n\nvar sequence = require('../midi/abc_midi_sequencer');\n\nvar flatten = require('../midi/abc_midi_flattener'); // TODO-PER: remove the midi tests from here: I don't think the object can be constructed unless it passes.\n\n\nvar notSupportedMessage = \"MIDI is not supported in this browser.\";\nvar defaultSoundFontUrl = \"https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/\";\n\nfunction CreateSynth() {\n  var self = this;\n  self.audioBufferPossible = undefined;\n  self.directSource = []; // type: AudioBufferSourceNode\n\n  self.startTimeSec = undefined; // the time that the midi started: used for pause/resume.\n\n  self.pausedTimeSec = undefined; // the time that the midi was paused: used for resume.\n\n  self.audioBuffers = []; // cache of the buffers so starting play can be fast.\n\n  self.duration = undefined; // the duration of the tune in seconds.\n\n  self.isRunning = false; // whether there is currently a sound buffer running.\n  // Load and cache all needed sounds\n\n  self.init = function (options) {\n    if (!options) options = {};\n    registerAudioContext(options.audioContext); // This works no matter what - if there is already an ac it is a nop; if the context is not passed in, then it creates one.\n\n    var startTime = activeAudioContext().currentTime;\n    self.debugCallback = options.debugCallback;\n    if (self.debugCallback) self.debugCallback(\"init called\");\n    self.audioBufferPossible = self._deviceCapable();\n    if (!self.audioBufferPossible) return Promise.reject({\n      status: \"NotSupported\",\n      message: notSupportedMessage\n    });\n    self.soundFontUrl = options.soundFontUrl ? options.soundFontUrl : defaultSoundFontUrl;\n    self.millisecondsPerMeasure = options.millisecondsPerMeasure ? options.millisecondsPerMeasure : options.visualObj ? options.visualObj.millisecondsPerMeasure() : 1000;\n    var params = options.options ? options.options : {};\n    self.meterSize = 1;\n\n    if (options.visualObj) {\n      var seq = sequence(options.visualObj, params);\n      self.flattened = flatten(seq, params);\n      self.meterSize = options.visualObj.getMeterFraction().num / options.visualObj.getMeterFraction().den;\n    } else if (options.sequence) self.flattened = options.sequence;else return Promise.reject(new Error(\"Must pass in either a visualObj or a sequence\"));\n\n    self.sequenceCallback = params.sequenceCallback;\n    self.callbackContext = params.callbackContext;\n    self.onEnded = options.onEnded;\n    var allNotes = {};\n    var currentInstrument = instrumentIndexToName[0];\n    self.flattened.tracks.forEach(function (track) {\n      track.forEach(function (event) {\n        if (event.cmd === \"program\" && instrumentIndexToName[event.instrument]) currentInstrument = instrumentIndexToName[event.instrument];\n\n        if (event.pitch !== undefined) {\n          var pitchNumber = event.pitch + 60;\n          var noteName = pitchToNoteName[pitchNumber];\n\n          if (noteName) {\n            if (!allNotes[currentInstrument]) allNotes[currentInstrument] = {};\n            allNotes[currentInstrument][pitchToNoteName[pitchNumber]] = true;\n          } else console.log(\"Can't find note: \", pitchNumber);\n        }\n      });\n    });\n    if (self.debugCallback) self.debugCallback(\"note gathering time = \" + Math.floor((activeAudioContext().currentTime - startTime) * 1000) + \"ms\");\n    startTime = activeAudioContext().currentTime;\n    var notes = [];\n    Object.keys(allNotes).forEach(function (instrument) {\n      Object.keys(allNotes[instrument]).forEach(function (note) {\n        notes.push({\n          instrument: instrument,\n          note: note\n        });\n      });\n    }); // If there are lots of notes, load them in batches\n\n    var batches = [];\n    var CHUNK = 256;\n\n    for (var i = 0; i < notes.length; i += CHUNK) {\n      batches.push(notes.slice(i, i + CHUNK));\n    }\n\n    return new Promise(function (resolve, reject) {\n      var results = [];\n      var index = 0;\n\n      var next = function () {\n        if (index < batches.length) {\n          self._loadBatch(batches[index], self.soundFontUrl, startTime).then(function (data) {\n            startTime = activeAudioContext().currentTime;\n            results.push(data);\n            index++;\n            next();\n          }, reject);\n        } else {\n          resolve(results);\n        }\n      };\n\n      next();\n    });\n  };\n\n  self._loadBatch = function (batch, soundFontUrl, startTime) {\n    var promises = [];\n    batch.forEach(function (item) {\n      promises.push(getNote(soundFontUrl, item.instrument, item.note, activeAudioContext()));\n    });\n    return Promise.all(promises).then(function (response) {\n      if (self.debugCallback) self.debugCallback(\"mp3 load time = \" + Math.floor((activeAudioContext().currentTime - startTime) * 1000) + \"ms\");\n      return Promise.resolve(response);\n    });\n  };\n\n  self.prime = function () {\n    self.isRunning = false;\n    if (!self.audioBufferPossible) return Promise.reject(new Error(notSupportedMessage));\n    if (self.debugCallback) self.debugCallback(\"prime called\");\n    return new Promise(function (resolve) {\n      var startTime = activeAudioContext().currentTime;\n      var tempoMultiplier = self.millisecondsPerMeasure / 1000 / self.meterSize;\n      self.duration = self.flattened.totalDuration * tempoMultiplier;\n      var totalSamples = Math.floor(activeAudioContext().sampleRate * self.duration); // There might be a previous run that needs to be turned off.\n\n      self.stop();\n      var noteMapTracks = createNoteMap(self.flattened);\n      if (self.sequenceCallback) self.sequenceCallback(noteMapTracks, self.callbackContext); //console.log(noteMapTracks);\n\n      self.audioBuffers = [];\n      noteMapTracks.forEach(function (noteMap) {\n        var audioBuffer = activeAudioContext().createBuffer(1, totalSamples, activeAudioContext().sampleRate);\n        var chanData = audioBuffer.getChannelData(0);\n        noteMap.forEach(function (note) {\n          self._placeNote(chanData, note, tempoMultiplier, soundsCache);\n        });\n        self.audioBuffers.push(audioBuffer);\n      });\n\n      if (self.debugCallback) {\n        self.debugCallback(\"sampleRate = \" + activeAudioContext().sampleRate);\n        self.debugCallback(\"totalSamples = \" + totalSamples);\n        self.debugCallback(\"creationTime = \" + Math.floor((activeAudioContext().currentTime - startTime) * 1000) + \"ms\");\n      }\n\n      resolve({\n        status: \"ok\",\n        seconds: 0\n      });\n    });\n  }; // This is called after everything is set up, so it can quickly make sound\n\n\n  self.start = function () {\n    if (self.pausedTimeSec) {\n      self.resume();\n      return;\n    }\n\n    if (!self.audioBufferPossible) throw new Error(notSupportedMessage);\n    if (self.debugCallback) self.debugCallback(\"start called\");\n\n    self._kickOffSound(0);\n\n    self.startTimeSec = activeAudioContext().currentTime;\n    self.pausedTimeSec = undefined;\n    if (self.debugCallback) self.debugCallback(\"MIDI STARTED\", self.startTimeSec);\n  };\n\n  self.pause = function () {\n    if (!self.audioBufferPossible) throw new Error(notSupportedMessage);\n    if (self.debugCallback) self.debugCallback(\"pause called\");\n\n    if (!self.pausedTimeSec) {\n      // ignore if self is already paused.\n      self.stop();\n      self.pausedTimeSec = activeAudioContext().currentTime;\n    }\n  };\n\n  self.resume = function () {\n    if (!self.audioBufferPossible) throw new Error(notSupportedMessage);\n    if (self.debugCallback) self.debugCallback(\"resume called\");\n    var offset = self.pausedTimeSec - self.startTimeSec;\n    self.startTimeSec = activeAudioContext().currentTime - offset; // We move the start time in case there is another pause/resume.\n\n    self.pausedTimeSec = undefined;\n\n    self._kickOffSound(offset);\n  };\n\n  self.seek = function (percent) {\n    var offset = self.duration * percent; // TODO-PER: can seek when paused or when playing\n\n    if (!self.audioBufferPossible) throw new Error(notSupportedMessage);\n    if (self.debugCallback) self.debugCallback(\"seek called sec=\" + offset);\n\n    if (self.isRunning) {\n      self.stop();\n\n      self._kickOffSound(offset);\n    }\n\n    var pauseDistance = self.pausedTimeSec ? self.pausedTimeSec - self.startTimeSec : undefined;\n    self.startTimeSec = activeAudioContext().currentTime - offset;\n    if (self.pausedTimeSec) self.pausedTimeSec = self.startTimeSec + pauseDistance;\n  };\n\n  self.stop = function () {\n    self.isRunning = false;\n    self.pausedTimeSec = undefined;\n    self.directSource.forEach(function (source) {\n      try {\n        source.stop();\n      } catch (error) {\n        // We don't care if self succeeds: it might fail if something else turned off the sound or it ended for some reason.\n        console.log(\"direct source didn't stop:\", error);\n      }\n    });\n    self.directSource = [];\n  };\n\n  self.download = function () {\n    return downloadBuffer(self);\n  }; /////////////// Private functions //////////////\n\n\n  self._deviceCapable = function () {\n    if (!supportsAudio()) {\n      console.warn(notSupportedMessage);\n      if (self.debugCallback) self.debugCallback(notSupportedMessage);\n      return false;\n    }\n\n    return true;\n  };\n\n  self._kickOffSound = function (seconds) {\n    self.isRunning = true;\n    self.directSource = [];\n    self.audioBuffers.forEach(function (audioBuffer, trackNum) {\n      self.directSource[trackNum] = activeAudioContext().createBufferSource(); // creates a sound source\n\n      self.directSource[trackNum].buffer = audioBuffer; // tell the source which sound to play\n\n      self.directSource[trackNum].connect(activeAudioContext().destination); // connect the source to the context's destination (the speakers)\n    });\n    self.directSource.forEach(function (source) {\n      source.start(0, seconds);\n    });\n\n    if (self.onEnded) {\n      self.directSource[0].onended = function () {\n        self.onEnded(self.callbackContext);\n      };\n    }\n  };\n\n  self._placeNote = function (chanData, note, tempoMultiplier, soundsCache) {\n    var start = Math.floor(note.start * activeAudioContext().sampleRate * tempoMultiplier);\n    var numBeats = note.end - note.start;\n    var noteTimeSec = numBeats * tempoMultiplier;\n    var noteName = pitchToNoteName[note.pitch + 60];\n\n    if (noteName) {\n      // Just ignore pitches that don't exist.\n      var pitch = soundsCache[note.instrument][noteName].getChannelData(0);\n      var duration = Math.min(pitch.length, Math.floor(noteTimeSec * activeAudioContext().sampleRate)); //console.log(pitchToNote[note.pitch+''], start, numBeats, noteTimeSec, duration);\n\n      for (var i = 0; i < duration; i++) {\n        var thisSample = pitch[i] * note.volume / 128;\n        if (chanData[start + i]) chanData[start + i] = (chanData[start + i] + thisSample) * 0.75;else chanData[start + i] = thisSample;\n      }\n    }\n  };\n}\n\nmodule.exports = CreateSynth;","map":{"version":3,"sources":["/home/elad/Desktop/Repos/drums-trainer/frontend/node_modules/react-sheet-music/node_modules/abcjs/src/synth/create-synth.js"],"names":["getNote","require","soundsCache","createNoteMap","registerAudioContext","activeAudioContext","supportsAudio","pitchToNoteName","instrumentIndexToName","downloadBuffer","sequence","flatten","notSupportedMessage","defaultSoundFontUrl","CreateSynth","self","audioBufferPossible","undefined","directSource","startTimeSec","pausedTimeSec","audioBuffers","duration","isRunning","init","options","audioContext","startTime","currentTime","debugCallback","_deviceCapable","Promise","reject","status","message","soundFontUrl","millisecondsPerMeasure","visualObj","params","meterSize","seq","flattened","getMeterFraction","num","den","Error","sequenceCallback","callbackContext","onEnded","allNotes","currentInstrument","tracks","forEach","track","event","cmd","instrument","pitch","pitchNumber","noteName","console","log","Math","floor","notes","Object","keys","note","push","batches","CHUNK","i","length","slice","resolve","results","index","next","_loadBatch","then","data","batch","promises","item","all","response","prime","tempoMultiplier","totalDuration","totalSamples","sampleRate","stop","noteMapTracks","noteMap","audioBuffer","createBuffer","chanData","getChannelData","_placeNote","seconds","start","resume","_kickOffSound","pause","offset","seek","percent","pauseDistance","source","error","download","warn","trackNum","createBufferSource","buffer","connect","destination","onended","numBeats","end","noteTimeSec","min","thisSample","volume","module","exports"],"mappings":"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","sourcesContent":["var getNote = require('./load-note');\nvar soundsCache = require('./sounds-cache');\nvar createNoteMap = require('./create-note-map');\nvar registerAudioContext = require('./register-audio-context');\nvar activeAudioContext = require('./active-audio-context');\nvar supportsAudio = require('./supports-audio');\nvar pitchToNoteName = require('./pitch-to-note-name');\nvar instrumentIndexToName = require('./instrument-index-to-name');\nvar downloadBuffer = require('./download-buffer');\nvar sequence = require('../midi/abc_midi_sequencer');\nvar flatten = require('../midi/abc_midi_flattener');\n\n// TODO-PER: remove the midi tests from here: I don't think the object can be constructed unless it passes.\nvar notSupportedMessage = \"MIDI is not supported in this browser.\";\n\nvar defaultSoundFontUrl = \"https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/\";\n\n\nfunction CreateSynth() {\n\tvar self = this;\n\tself.audioBufferPossible = undefined;\n\tself.directSource = []; // type: AudioBufferSourceNode\n\tself.startTimeSec = undefined; // the time that the midi started: used for pause/resume.\n\tself.pausedTimeSec = undefined; // the time that the midi was paused: used for resume.\n\tself.audioBuffers = []; // cache of the buffers so starting play can be fast.\n\tself.duration = undefined; // the duration of the tune in seconds.\n\tself.isRunning = false; // whether there is currently a sound buffer running.\n\n\t// Load and cache all needed sounds\n\tself.init = function(options) {\n\t\tif (!options)\n\t\t\toptions = {};\n\t\tregisterAudioContext(options.audioContext); // This works no matter what - if there is already an ac it is a nop; if the context is not passed in, then it creates one.\n\t\tvar startTime = activeAudioContext().currentTime;\n\t\tself.debugCallback = options.debugCallback;\n\t\tif (self.debugCallback)\n\t\t\tself.debugCallback(\"init called\");\n\t\tself.audioBufferPossible = self._deviceCapable();\n\t\tif (!self.audioBufferPossible)\n\t\t\treturn Promise.reject({ status: \"NotSupported\", message: notSupportedMessage});\n\t\tself.soundFontUrl = options.soundFontUrl ? options.soundFontUrl : defaultSoundFontUrl;\n\t\tself.millisecondsPerMeasure = options.millisecondsPerMeasure ? options.millisecondsPerMeasure : (options.visualObj ? options.visualObj.millisecondsPerMeasure() : 1000);\n\t\tvar params = options.options ? options.options : {};\n\t\tself.meterSize = 1;\n\t\tif (options.visualObj) {\n\t\t\tvar seq = sequence(options.visualObj, params);\n\t\t\tself.flattened = flatten(seq, params);\n\t\t\tself.meterSize = options.visualObj.getMeterFraction().num / options.visualObj.getMeterFraction().den;\n\t\t} else if (options.sequence)\n\t\t\tself.flattened = options.sequence;\n\t\telse\n\t\t\treturn Promise.reject(new Error(\"Must pass in either a visualObj or a sequence\"));\n\t\tself.sequenceCallback = params.sequenceCallback;\n\t\tself.callbackContext = params.callbackContext;\n\t\tself.onEnded = options.onEnded;\n\n\t\tvar allNotes = {};\n\t\tvar currentInstrument = instrumentIndexToName[0];\n\t\tself.flattened.tracks.forEach(function(track) {\n\t\t\ttrack.forEach(function(event) {\n\t\t\t\tif (event.cmd === \"program\" && instrumentIndexToName[event.instrument])\n\t\t\t\t\tcurrentInstrument = instrumentIndexToName[event.instrument];\n\t\t\t\tif (event.pitch !== undefined) {\n\t\t\t\t\tvar pitchNumber = event.pitch + 60;\n\t\t\t\t\tvar noteName = pitchToNoteName[pitchNumber];\n\t\t\t\t\tif (noteName) {\n\t\t\t\t\t\tif (!allNotes[currentInstrument])\n\t\t\t\t\t\t\tallNotes[currentInstrument] = {};\n\t\t\t\t\t\tallNotes[currentInstrument][pitchToNoteName[pitchNumber]] = true;\n\t\t\t\t\t} else\n\t\t\t\t\t\tconsole.log(\"Can't find note: \", pitchNumber);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tif (self.debugCallback)\n\t\t\tself.debugCallback(\"note gathering time = \" + Math.floor((activeAudioContext().currentTime - startTime)*1000)+\"ms\");\n\t\tstartTime = activeAudioContext().currentTime;\n\n\t\tvar notes = [];\n\t\tObject.keys(allNotes).forEach(function(instrument) {\n\t\t\tObject.keys(allNotes[instrument]).forEach(function(note) {\n\t\t\t\tnotes.push({ instrument: instrument, note: note });\n\t\t\t});\n\t\t});\n\t\t// If there are lots of notes, load them in batches\n\t\tvar batches = [];\n\t\tvar CHUNK = 256;\n\t\tfor (var i=0; i < notes.length; i += CHUNK) {\n\t\t\tbatches.push(notes.slice(i, i + CHUNK));\n\t\t}\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tvar results = [];\n\n\t\t\tvar index = 0;\n\t\t\tvar next = function() {\n\t\t\t\tif (index < batches.length) {\n\t\t\t\t\tself._loadBatch(batches[index], self.soundFontUrl, startTime).then(function(data) {\n\t\t\t\t\t\tstartTime = activeAudioContext().currentTime;\n\t\t\t\t\t\tresults.push(data);\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}, reject);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(results);\n\t\t\t\t}\n\t\t\t};\n\t\t\tnext();\n\t\t});\n\t};\n\n\tself._loadBatch = (function(batch, soundFontUrl, startTime) {\n\t\tvar promises = [];\n\t\tbatch.forEach(function(item) {\n\t\t\tpromises.push(getNote(soundFontUrl, item.instrument, item.note, activeAudioContext()));\n\t\t});\n\t\treturn Promise.all(promises).then(function(response) {\n\t\t\tif (self.debugCallback)\n\t\t\t\tself.debugCallback(\"mp3 load time = \" + Math.floor((activeAudioContext().currentTime - startTime)*1000)+\"ms\");\n\t\t\treturn Promise.resolve(response);\n\t\t});\n\t});\n\n\tself.prime = function() {\n\t\tself.isRunning = false;\n\t\tif (!self.audioBufferPossible)\n\t\t\treturn Promise.reject(new Error(notSupportedMessage));\n\t\tif (self.debugCallback)\n\t\t\tself.debugCallback(\"prime called\");\n\t\treturn new Promise(function(resolve) {\n\t\t\tvar startTime = activeAudioContext().currentTime;\n\t\t\tvar tempoMultiplier = self.millisecondsPerMeasure / 1000 / self.meterSize;\n\t\t\tself.duration = self.flattened.totalDuration * tempoMultiplier;\n\t\t\tvar totalSamples = Math.floor(activeAudioContext().sampleRate * self.duration);\n\n\t\t\t// There might be a previous run that needs to be turned off.\n\t\t\tself.stop();\n\n\t\t\tvar noteMapTracks = createNoteMap(self.flattened);\n\t\t\tif (self.sequenceCallback)\n\t\t\t\tself.sequenceCallback(noteMapTracks, self.callbackContext);\n\t\t\t//console.log(noteMapTracks);\n\n\t\t\tself.audioBuffers = [];\n\t\t\tnoteMapTracks.forEach(function(noteMap) {\n\t\t\t\tvar audioBuffer = activeAudioContext().createBuffer(1, totalSamples, activeAudioContext().sampleRate);\n\t\t\t\tvar chanData = audioBuffer.getChannelData(0);\n\n\t\t\t\tnoteMap.forEach(function(note) {\n\t\t\t\t\tself._placeNote(chanData, note, tempoMultiplier, soundsCache);\n\t\t\t\t});\n\n\t\t\t\tself.audioBuffers.push(audioBuffer);\n\t\t\t});\n\n\t\t\tif (self.debugCallback) {\n\t\t\t\tself.debugCallback(\"sampleRate = \" + activeAudioContext().sampleRate);\n\t\t\t\tself.debugCallback(\"totalSamples = \" + totalSamples);\n\t\t\t\tself.debugCallback(\"creationTime = \" + Math.floor((activeAudioContext().currentTime - startTime)*1000) + \"ms\");\n\t\t\t}\n\t\t\tresolve({\n\t\t\t\tstatus: \"ok\",\n\t\t\t\tseconds: 0\n\t\t\t});\n\t\t});\n\t};\n\n\t// This is called after everything is set up, so it can quickly make sound\n\tself.start = function() {\n\t\tif (self.pausedTimeSec) {\n\t\t\tself.resume();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!self.audioBufferPossible)\n\t\t\tthrow new Error(notSupportedMessage);\n\t\tif (self.debugCallback)\n\t\t\tself.debugCallback(\"start called\");\n\n\t\tself._kickOffSound(0);\n\t\tself.startTimeSec = activeAudioContext().currentTime;\n\t\tself.pausedTimeSec = undefined;\n\n\t\tif (self.debugCallback)\n\t\t\tself.debugCallback(\"MIDI STARTED\", self.startTimeSec);\n\t};\n\n\tself.pause = function() {\n\t\tif (!self.audioBufferPossible)\n\t\t\tthrow new Error(notSupportedMessage);\n\t\tif (self.debugCallback)\n\t\t\tself.debugCallback(\"pause called\");\n\n\t\tif (!self.pausedTimeSec) { // ignore if self is already paused.\n\t\t\tself.stop();\n\t\t\tself.pausedTimeSec = activeAudioContext().currentTime;\n\t\t}\n\t};\n\n\tself.resume = function() {\n\t\tif (!self.audioBufferPossible)\n\t\t\tthrow new Error(notSupportedMessage);\n\t\tif (self.debugCallback)\n\t\t\tself.debugCallback(\"resume called\");\n\n\t\tvar offset = self.pausedTimeSec - self.startTimeSec;\n\t\tself.startTimeSec = activeAudioContext().currentTime - offset; // We move the start time in case there is another pause/resume.\n\t\tself.pausedTimeSec = undefined;\n\t\tself._kickOffSound(offset);\n\t};\n\n\tself.seek = function(percent) {\n\t\tvar offset = self.duration * percent;\n\n\t\t// TODO-PER: can seek when paused or when playing\n\t\tif (!self.audioBufferPossible)\n\t\t\tthrow new Error(notSupportedMessage);\n\t\tif (self.debugCallback)\n\t\t\tself.debugCallback(\"seek called sec=\" + offset);\n\n\t\tif (self.isRunning) {\n\t\t\tself.stop();\n\t\t\tself._kickOffSound(offset);\n\t\t}\n\t\tvar pauseDistance = self.pausedTimeSec ? self.pausedTimeSec - self.startTimeSec : undefined;\n\t\tself.startTimeSec = activeAudioContext().currentTime - offset;\n\t\tif (self.pausedTimeSec)\n\t\t\tself.pausedTimeSec = self.startTimeSec + pauseDistance;\n\t};\n\n\tself.stop = function() {\n\t\tself.isRunning = false;\n\t\tself.pausedTimeSec = undefined;\n\t\tself.directSource.forEach(function(source) {\n\t\t\ttry {\n\t\t\t\tsource.stop();\n\t\t\t} catch (error) {\n\t\t\t\t// We don't care if self succeeds: it might fail if something else turned off the sound or it ended for some reason.\n\t\t\t\tconsole.log(\"direct source didn't stop:\", error)\n\t\t\t}\n\t\t});\n\t\tself.directSource = [];\n\t};\n\n\tself.download = function() {\n\t\treturn downloadBuffer(self);\n\t};\n\n\t/////////////// Private functions //////////////\n\n\tself._deviceCapable = function() {\n\t\tif (!supportsAudio()) {\n\t\t\tconsole.warn(notSupportedMessage);\n\t\t\tif (self.debugCallback)\n\t\t\t\tself.debugCallback(notSupportedMessage);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tself._kickOffSound = function(seconds) {\n\t\tself.isRunning = true;\n\t\tself.directSource = [];\n\t\tself.audioBuffers.forEach(function(audioBuffer, trackNum) {\n\t\t\tself.directSource[trackNum] = activeAudioContext().createBufferSource(); // creates a sound source\n\t\t\tself.directSource[trackNum].buffer = audioBuffer; // tell the source which sound to play\n\t\t\tself.directSource[trackNum].connect(activeAudioContext().destination); // connect the source to the context's destination (the speakers)\n\t\t});\n\t\tself.directSource.forEach(function(source) {\n\t\t\tsource.start(0, seconds);\n\t\t});\n\t\tif (self.onEnded) {\n\t\t\tself.directSource[0].onended = function () {\n\t\t\t\tself.onEnded(self.callbackContext);\n\t\t\t};\n\t\t}\n\t};\n\n\tself._placeNote = function(chanData, note, tempoMultiplier, soundsCache) {\n\t\tvar start = Math.floor(note.start*activeAudioContext().sampleRate * tempoMultiplier);\n\t\tvar numBeats = note.end - note.start;\n\t\tvar noteTimeSec = numBeats * tempoMultiplier;\n\t\tvar noteName = pitchToNoteName[note.pitch+60];\n\t\tif (noteName) { // Just ignore pitches that don't exist.\n\t\t\tvar pitch = soundsCache[note.instrument][noteName].getChannelData(0);\n\t\t\tvar duration = Math.min(pitch.length, Math.floor(noteTimeSec * activeAudioContext().sampleRate));\n\t\t\t//console.log(pitchToNote[note.pitch+''], start, numBeats, noteTimeSec, duration);\n\t\t\tfor (var i = 0; i < duration; i++) {\n\t\t\t\tvar thisSample = pitch[i] * note.volume / 128;\n\t\t\t\tif (chanData[start + i])\n\t\t\t\t\tchanData[start + i] = (chanData[start + i] + thisSample) *0.75;\n\t\t\t\telse\n\t\t\t\t\tchanData[start + i] = thisSample;\n\t\t\t}\n\t\t}\n\t};\n}\n\nmodule.exports = CreateSynth;\n"]},"metadata":{},"sourceType":"script"}