{"ast":null,"code":"//    abc_midi_sequencer.js: Turn parsed abc into a linear series of events.\n//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar sequence;\n\n(function () {\n  \"use strict\";\n\n  var measureLength; // The abc is provided to us line by line. It might have repeats in it. We want to re arrange the elements to\n  // be an array of voices with all the repeats embedded, and no lines. Then it is trivial to go through the events\n  // one at a time and turn it into midi.\n\n  var PERCUSSION_PROGRAM = 128;\n\n  sequence = function (abctune, options) {\n    // Global options\n    options = options || {};\n    var qpm = undefined;\n    var program = options.program || 0; // The program if there isn't a program specified.\n\n    var transpose = options.midiTranspose || 0;\n    var channel = options.channel || 0;\n    var drumPattern = options.drum || \"\";\n    var drumBars = options.drumBars || 1;\n    var drumIntro = options.drumIntro || 0;\n    var drumOn = drumPattern !== \"\"; // All of the above overrides need to be integers\n\n    program = parseInt(program, 10);\n    transpose = parseInt(transpose, 10);\n    channel = parseInt(channel, 10);\n    if (channel === 10) program = PERCUSSION_PROGRAM;\n    drumPattern = drumPattern.split(\" \");\n    drumBars = parseInt(drumBars, 10);\n    drumIntro = parseInt(drumIntro, 10);\n    var bagpipes = abctune.formatting.bagpipes; // If it is bagpipes, then the gracenotes are played on top of the main note.\n\n    if (bagpipes) program = 71; // %%MIDI fermatafixed\n    // %%MIDI fermataproportional\n    // %%MIDI deltaloudness n\n    // %%MIDI gracedivider b\n    // %%MIDI ratio n m\n    // %%MIDI beat a b c n\n    // %%MIDI grace a/b\n    // %%MIDI trim x/y\n    // %MIDI gchordon\n    // %MIDI gchordoff\n    // %%MIDI bassprog 45\n    // %%MIDI chordprog 24\n    // %%MIDI chordname name n1 n2 n3 n4 n5 n6\n    //%%MIDI beat ⟨int1⟩ ⟨int2⟩ ⟨int3⟩ ⟨int4⟩: controls the volumes of the notes in a measure. The first note in a bar has volume ⟨int1⟩; other ‘strong’ notes have volume ⟨int2⟩ and all the rest have volume ⟨int3⟩. These values must be in the range 0–127. The parameter ⟨int4⟩ determines which notes are ‘strong’. If the time signature is x/y, then each note is given a position number k = 0, 1, 2. . . x-1 within each bar. If k is a multiple of ⟨int4⟩, then the note is ‘strong’.\n\n    var startingMidi = [];\n\n    if (abctune.formatting.midi) {\n      //console.log(\"MIDI Formatting:\", abctune.formatting.midi);\n      var globals = abctune.formatting.midi;\n\n      if (globals.program && globals.program.length > 0) {\n        program = globals.program[0];\n\n        if (globals.program.length > 1) {\n          program = globals.program[1];\n          channel = globals.program[0];\n        }\n      }\n\n      if (globals.transpose) transpose = globals.transpose[0];\n      if (globals.channel) channel = globals.channel[0];\n      if (globals.drum) drumPattern = globals.drum;\n      if (globals.drumbars) drumBars = globals.drumbars[0];\n      if (globals.drumon) drumOn = true;\n      if (channel === 10) program = PERCUSSION_PROGRAM;\n      if (globals.beat) startingMidi.push({\n        el_type: 'beat',\n        beats: globals.beat\n      });\n      if (globals.nobeataccents) startingMidi.push({\n        el_type: 'beataccents',\n        value: false\n      });\n    } // Specified options in abc string.\n    // If the tempo was passed in, use that.\n    // If the tempo is specified, use that.\n    // If there is a default, use that.\n    // Otherwise, use the default.\n\n\n    if (options.qpm) qpm = parseInt(options.qpm, 10);else if (abctune.metaText.tempo) qpm = interpretTempo(abctune.metaText.tempo);else if (options.defaultQpm) qpm = options.defaultQpm;else qpm = 180; // The tempo if there isn't a tempo specified.\n\n    var startVoice = [];\n    if (bagpipes) startVoice.push({\n      el_type: 'bagpipes'\n    });\n    startVoice.push({\n      el_type: 'instrument',\n      program: program\n    });\n    if (channel) startVoice.push({\n      el_type: 'channel',\n      channel: channel\n    });\n    if (transpose) startVoice.push({\n      el_type: 'transpose',\n      transpose: transpose\n    });\n    startVoice.push({\n      el_type: 'tempo',\n      qpm: qpm\n    });\n\n    for (var ss = 0; ss < startingMidi.length; ss++) startVoice.push(startingMidi[ss]); // the relevant part of the input structure is:\n    // abctune\n    //\t\tarray lines\n    //\t\t\tarray staff\n    //\t\t\t\tobject key\n    //\t\t\t\tobject meter\n    //\t\t\t\tarray voices\n    //\t\t\t\t\tarray abcelem\n    // visit each voice completely in turn\n\n\n    var voices = [];\n    var startRepeatPlaceholder = []; // There is a place holder for each voice.\n\n    var skipEndingPlaceholder = []; // This is the place where the first ending starts.\n\n    var startingDrumSet = false;\n\n    for (var i = 0; i < abctune.lines.length; i++) {\n      // For each group of staff lines in the tune.\n      var line = abctune.lines[i];\n\n      if (line.staff) {\n        var staves = line.staff;\n        var voiceNumber = 0;\n\n        for (var j = 0; j < staves.length; j++) {\n          var staff = staves[j]; // For each staff line\n\n          for (var k = 0; k < staff.voices.length; k++) {\n            // For each voice in a staff line\n            var voice = staff.voices[k];\n\n            if (!voices[voiceNumber]) {\n              voices[voiceNumber] = [].concat(JSON.parse(JSON.stringify(startVoice)));\n            }\n\n            if (staff.clef && staff.clef.type === 'perc') {\n              for (var cl = 0; cl < voices[voiceNumber].length; cl++) {\n                if (voices[voiceNumber][cl].el_type === 'instrument') voices[voiceNumber][cl].program = PERCUSSION_PROGRAM;\n              }\n            } else if (staff.key) {\n              if (staff.key.root === 'HP') voices[voiceNumber].push({\n                el_type: 'key',\n                accidentals: [{\n                  acc: 'natural',\n                  note: 'g'\n                }, {\n                  acc: 'sharp',\n                  note: 'f'\n                }, {\n                  acc: 'sharp',\n                  note: 'c'\n                }]\n              });else voices[voiceNumber].push({\n                el_type: 'key',\n                accidentals: staff.key.accidentals\n              });\n            }\n\n            if (staff.meter) {\n              voices[voiceNumber].push(interpretMeter(staff.meter));\n            }\n\n            if (!startingDrumSet && drumOn) {\n              // drum information is only needed once, so use the first line and track 0.\n              voices[voiceNumber].push({\n                el_type: 'drum',\n                params: {\n                  pattern: drumPattern,\n                  bars: drumBars,\n                  on: drumOn,\n                  intro: drumIntro\n                }\n              });\n              startingDrumSet = true;\n            }\n\n            if (staff.clef && staff.clef.transpose) {\n              staff.clef.el_type = 'clef';\n              voices[voiceNumber].push({\n                el_type: 'transpose',\n                transpose: staff.clef.transpose\n              });\n            }\n\n            if (abctune.formatting.midi && abctune.formatting.midi.drumoff) {\n              // If there is a drum off command right at the beginning it is put in the metaText instead of the stream,\n              // so we will just insert it here.\n              voices[voiceNumber].push({\n                el_type: 'bar'\n              });\n              voices[voiceNumber].push({\n                el_type: 'drum',\n                params: {\n                  pattern: \"\",\n                  on: false\n                }\n              });\n            }\n\n            var noteEventsInBar = 0;\n\n            for (var v = 0; v < voice.length; v++) {\n              // For each element in a voice\n              var elem = voice[v];\n\n              switch (elem.el_type) {\n                case \"note\":\n                  // regular items are just pushed.\n                  if (!elem.rest || elem.rest.type !== 'spacer') {\n                    if (elem.decoration) {\n                      if (elem.decoration.indexOf('ppp') >= 0) voices[voiceNumber].push({\n                        el_type: 'beat',\n                        beats: [30, 20, 10, 1]\n                      });else if (elem.decoration.indexOf('pp') >= 0) voices[voiceNumber].push({\n                        el_type: 'beat',\n                        beats: [45, 35, 20, 1]\n                      });else if (elem.decoration.indexOf('p') >= 0) voices[voiceNumber].push({\n                        el_type: 'beat',\n                        beats: [60, 50, 35, 1]\n                      });else if (elem.decoration.indexOf('mp') >= 0) voices[voiceNumber].push({\n                        el_type: 'beat',\n                        beats: [75, 65, 50, 1]\n                      });else if (elem.decoration.indexOf('mf') >= 0) voices[voiceNumber].push({\n                        el_type: 'beat',\n                        beats: [90, 80, 65, 1]\n                      });else if (elem.decoration.indexOf('f') >= 0) voices[voiceNumber].push({\n                        el_type: 'beat',\n                        beats: [105, 95, 80, 1]\n                      });else if (elem.decoration.indexOf('ff') >= 0) voices[voiceNumber].push({\n                        el_type: 'beat',\n                        beats: [120, 110, 95, 1]\n                      });else if (elem.decoration.indexOf('fff') >= 0) voices[voiceNumber].push({\n                        el_type: 'beat',\n                        beats: [127, 125, 110, 1]\n                      });\n                    }\n\n                    voices[voiceNumber].push(elem);\n                    noteEventsInBar++;\n                  }\n\n                  break;\n\n                case \"key\":\n                  if (elem.root === 'HP') voices[voiceNumber].push({\n                    el_type: 'key',\n                    accidentals: [{\n                      acc: 'natural',\n                      note: 'g'\n                    }, {\n                      acc: 'sharp',\n                      note: 'f'\n                    }, {\n                      acc: 'sharp',\n                      note: 'c'\n                    }]\n                  });else voices[voiceNumber].push({\n                    el_type: 'key',\n                    accidentals: elem.accidentals\n                  });\n                  break;\n\n                case \"meter\":\n                  voices[voiceNumber].push(interpretMeter(elem));\n                  break;\n\n                case \"clef\":\n                  // need to keep this to catch the \"transpose\" element.\n                  if (elem.transpose) voices[voiceNumber].push({\n                    el_type: 'transpose',\n                    transpose: elem.transpose\n                  });\n                  break;\n\n                case \"tempo\":\n                  qpm = interpretTempo(elem);\n                  voices[voiceNumber].push({\n                    el_type: 'tempo',\n                    qpm: qpm\n                  });\n                  break;\n\n                case \"bar\":\n                  if (noteEventsInBar > 0) // don't add two bars in a row.\n                    voices[voiceNumber].push({\n                      el_type: 'bar'\n                    }); // We need the bar marking to reset the accidentals.\n\n                  noteEventsInBar = 0; // figure out repeats and endings --\n                  // The important part is where there is a start repeat, and end repeat, or a first ending.\n\n                  var endRepeat = elem.type === \"bar_right_repeat\" || elem.type === \"bar_dbl_repeat\";\n                  var startEnding = elem.startEnding === '1';\n                  var startRepeat = elem.type === \"bar_left_repeat\" || elem.type === \"bar_dbl_repeat\" || elem.type === \"bar_right_repeat\";\n\n                  if (endRepeat) {\n                    var s = startRepeatPlaceholder[voiceNumber];\n                    if (!s) s = 0; // If there wasn't a left repeat, then we repeat from the beginning.\n\n                    var e = skipEndingPlaceholder[voiceNumber];\n                    if (!e) e = voices[voiceNumber].length; // If there wasn't a first ending marker, then we copy everything.\n\n                    voices[voiceNumber] = voices[voiceNumber].concat(voices[voiceNumber].slice(s, e)); // reset these in case there is a second repeat later on.\n\n                    skipEndingPlaceholder[voiceNumber] = undefined;\n                    startRepeatPlaceholder[voiceNumber] = undefined;\n                  }\n\n                  if (startEnding) skipEndingPlaceholder[voiceNumber] = voices[voiceNumber].length;\n                  if (startRepeat) startRepeatPlaceholder[voiceNumber] = voices[voiceNumber].length;\n                  break;\n\n                case 'style':\n                  // TODO-PER: If this is set to rhythm heads, then it should use the percussion channel.\n                  break;\n\n                case 'part':\n                  // TODO-PER: If there is a part section in the header, then this should probably affect the repeats.\n                  break;\n\n                case 'stem':\n                case 'scale':\n                  // These elements don't affect sound\n                  break;\n\n                case 'midi':\n                  //console.log(\"MIDI inline\", elem); // TODO-PER: for debugging. Remove this.\n                  var drumChange = false;\n\n                  switch (elem.cmd) {\n                    case \"drumon\":\n                      drumOn = true;\n                      drumChange = true;\n                      break;\n\n                    case \"drumoff\":\n                      drumOn = false;\n                      drumChange = true;\n                      break;\n\n                    case \"drum\":\n                      drumPattern = elem.params;\n                      drumChange = true;\n                      break;\n\n                    case \"drumbars\":\n                      drumBars = elem.params[0];\n                      drumChange = true;\n                      break;\n\n                    case \"drummap\":\n                      // This is handled before getting here so it can be ignored.\n                      break;\n\n                    case \"program\":\n                      voices[voiceNumber].push({\n                        el_type: 'instrument',\n                        program: elem.params[0]\n                      });\n                      break;\n\n                    case \"transpose\":\n                      voices[voiceNumber].push({\n                        el_type: 'transpose',\n                        transpose: elem.params[0]\n                      });\n                      break;\n\n                    case \"gchordoff\":\n                      voices[voiceNumber].push({\n                        el_type: 'gchord',\n                        tacet: true\n                      });\n                      break;\n\n                    case \"gchordon\":\n                      voices[voiceNumber].push({\n                        el_type: 'gchord',\n                        tacet: false\n                      });\n                      break;\n\n                    case \"beat\":\n                      voices[voiceNumber].push({\n                        el_type: 'beat',\n                        beats: elem.params\n                      });\n                      break;\n\n                    case \"nobeataccents\":\n                      voices[voiceNumber].push({\n                        el_type: 'beataccents',\n                        value: false\n                      });\n                      break;\n\n                    case \"beataccents\":\n                      voices[voiceNumber].push({\n                        el_type: 'beataccents',\n                        value: true\n                      });\n                      break;\n\n                    case \"vol\":\n                      voices[voiceNumber].push({\n                        el_type: 'vol',\n                        volume: elem.params[0]\n                      });\n                      break;\n\n                    case \"volinc\":\n                      voices[voiceNumber].push({\n                        el_type: 'volinc',\n                        volume: elem.params[0]\n                      });\n                      break;\n\n                    default:\n                      console.log(\"MIDI seq: midi cmd not handled: \", elem.cmd, elem);\n                  }\n\n                  if (drumChange) {\n                    voices[0].push({\n                      el_type: 'drum',\n                      params: {\n                        pattern: drumPattern,\n                        bars: drumBars,\n                        intro: drumIntro,\n                        on: drumOn\n                      }\n                    });\n                    startingDrumSet = true;\n                  }\n\n                  break;\n\n                default:\n                  console.log(\"MIDI: element type \" + elem.el_type + \" not handled.\");\n              }\n            }\n\n            voiceNumber++;\n          }\n        }\n      }\n    }\n\n    if (drumIntro) {\n      var pickups = abctune.getPickupLength(); // add some measures of rests to the start of each track.\n\n      for (var vv = 0; vv < voices.length; vv++) {\n        var insertPoint = 0;\n\n        while (voices[vv][insertPoint].el_type !== \"note\" && voices[vv].length > insertPoint) insertPoint++;\n\n        if (voices[vv].length > insertPoint) {\n          for (var w = 0; w < drumIntro; w++) {\n            // If it is the last measure of intro, subtract the pickups.\n            if (pickups === 0 || w < drumIntro - 1) voices[vv].splice(insertPoint, 0, {\n              el_type: \"note\",\n              rest: {\n                type: \"rest\"\n              },\n              duration: measureLength\n            }, {\n              el_type: \"bar\"\n            });else {\n              voices[vv].splice(insertPoint, 0, {\n                el_type: \"note\",\n                rest: {\n                  type: \"rest\"\n                },\n                duration: measureLength - pickups\n              });\n            }\n          }\n        }\n      }\n    }\n\n    return voices;\n  };\n\n  function interpretTempo(element) {\n    var duration = 1 / 4;\n\n    if (element.duration) {\n      duration = element.duration[0];\n    }\n\n    var bpm = 60;\n\n    if (element.bpm) {\n      bpm = element.bpm;\n    } // The tempo is defined with a beat of a 1/4 note, so we need to adjust it if the tempo is expressed with other than a quarter note.\n    // expressedDuration * expressedBeatsPerMinute / lengthOfQuarterNote = quarterNotesPerMinute\n\n\n    return duration * bpm / 0.25;\n  }\n\n  function interpretMeter(element) {\n    var meter;\n\n    switch (element.type) {\n      case \"common_time\":\n        meter = {\n          el_type: 'meter',\n          num: 4,\n          den: 4\n        };\n        break;\n\n      case \"cut_time\":\n        meter = {\n          el_type: 'meter',\n          num: 2,\n          den: 2\n        };\n        break;\n\n      case \"specified\":\n        // TODO-PER: only taking the first meter, so the complex meters are not handled.\n        meter = {\n          el_type: 'meter',\n          num: element.value[0].num,\n          den: element.value[0].den\n        };\n        break;\n\n      default:\n        // This should never happen.\n        meter = {\n          el_type: 'meter'\n        };\n    }\n\n    measureLength = meter.num / meter.den;\n    return meter;\n  }\n})();\n\nmodule.exports = sequence;","map":{"version":3,"sources":["/home/elad/Desktop/Repos/drums-trainer/frontend/node_modules/react-sheet-music/node_modules/abcjs/src/midi/abc_midi_sequencer.js"],"names":["sequence","measureLength","PERCUSSION_PROGRAM","abctune","options","qpm","undefined","program","transpose","midiTranspose","channel","drumPattern","drum","drumBars","drumIntro","drumOn","parseInt","split","bagpipes","formatting","startingMidi","midi","globals","length","drumbars","drumon","beat","push","el_type","beats","nobeataccents","value","metaText","tempo","interpretTempo","defaultQpm","startVoice","ss","voices","startRepeatPlaceholder","skipEndingPlaceholder","startingDrumSet","i","lines","line","staff","staves","voiceNumber","j","k","voice","concat","JSON","parse","stringify","clef","type","cl","key","root","accidentals","acc","note","meter","interpretMeter","params","pattern","bars","on","intro","drumoff","noteEventsInBar","v","elem","rest","decoration","indexOf","endRepeat","startEnding","startRepeat","s","e","slice","drumChange","cmd","tacet","volume","console","log","pickups","getPickupLength","vv","insertPoint","w","splice","duration","element","bpm","num","den","module","exports"],"mappings":"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","sourcesContent":["//    abc_midi_sequencer.js: Turn parsed abc into a linear series of events.\n//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar sequence;\n\n(function() {\n\t\"use strict\";\n\n\tvar measureLength;\n\t// The abc is provided to us line by line. It might have repeats in it. We want to re arrange the elements to\n\t// be an array of voices with all the repeats embedded, and no lines. Then it is trivial to go through the events\n\t// one at a time and turn it into midi.\n\n\tvar PERCUSSION_PROGRAM = 128;\n\n\tsequence = function(abctune, options) {\n\t\t// Global options\n\t\toptions = options || {};\n\t\tvar qpm = undefined;\n\t\tvar program = options.program || 0;\t// The program if there isn't a program specified.\n\t\tvar transpose = options.midiTranspose || 0;\n\t\tvar channel = options.channel || 0;\n\t\tvar drumPattern = options.drum || \"\";\n\t\tvar drumBars = options.drumBars || 1;\n\t\tvar drumIntro = options.drumIntro || 0;\n\t\tvar drumOn = drumPattern !== \"\";\n\n\t\t// All of the above overrides need to be integers\n\t\tprogram = parseInt(program, 10);\n\t\ttranspose = parseInt(transpose, 10);\n\t\tchannel = parseInt(channel, 10);\n\t\tif (channel === 10)\n\t\t\tprogram = PERCUSSION_PROGRAM;\n\t\tdrumPattern = drumPattern.split(\" \");\n\t\tdrumBars = parseInt(drumBars, 10);\n\t\tdrumIntro = parseInt(drumIntro, 10);\n\n\t\tvar bagpipes = abctune.formatting.bagpipes; // If it is bagpipes, then the gracenotes are played on top of the main note.\n\t\tif (bagpipes)\n\t\t\tprogram = 71;\n\n\t\t// %%MIDI fermatafixed\n\t\t// %%MIDI fermataproportional\n\t\t// %%MIDI deltaloudness n\n\t\t// %%MIDI gracedivider b\n\t\t// %%MIDI ratio n m\n\t\t// %%MIDI beat a b c n\n\t\t// %%MIDI grace a/b\n\t\t// %%MIDI trim x/y\n\n\t\t// %MIDI gchordon\n\t\t// %MIDI gchordoff\n\t\t// %%MIDI bassprog 45\n\t\t// %%MIDI chordprog 24\n\t\t// %%MIDI chordname name n1 n2 n3 n4 n5 n6\n\n\t\t//%%MIDI beat ⟨int1⟩ ⟨int2⟩ ⟨int3⟩ ⟨int4⟩: controls the volumes of the notes in a measure. The first note in a bar has volume ⟨int1⟩; other ‘strong’ notes have volume ⟨int2⟩ and all the rest have volume ⟨int3⟩. These values must be in the range 0–127. The parameter ⟨int4⟩ determines which notes are ‘strong’. If the time signature is x/y, then each note is given a position number k = 0, 1, 2. . . x-1 within each bar. If k is a multiple of ⟨int4⟩, then the note is ‘strong’.\n\n\t\tvar startingMidi = [];\n\t\tif (abctune.formatting.midi) {\n\t\t\t//console.log(\"MIDI Formatting:\", abctune.formatting.midi);\n\t\t\tvar globals = abctune.formatting.midi;\n\t\t\tif (globals.program && globals.program.length > 0) {\n\t\t\t\tprogram = globals.program[0];\n\t\t\t\tif (globals.program.length > 1) {\n\t\t\t\t\tprogram = globals.program[1];\n\t\t\t\t\tchannel = globals.program[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (globals.transpose)\n\t\t\t\ttranspose = globals.transpose[0];\n\t\t\tif (globals.channel)\n\t\t\t\tchannel = globals.channel[0];\n\t\t\tif (globals.drum)\n\t\t\t\tdrumPattern = globals.drum;\n\t\t\tif (globals.drumbars)\n\t\t\t\tdrumBars = globals.drumbars[0];\n\t\t\tif (globals.drumon)\n\t\t\t\tdrumOn = true;\n\t\t\tif (channel === 10)\n\t\t\t\tprogram = PERCUSSION_PROGRAM;\n\t\t\tif (globals.beat)\n\t\t\t\tstartingMidi.push({ el_type: 'beat', beats: globals.beat })\n\t\t\tif (globals.nobeataccents)\n\t\t\t\tstartingMidi.push({ el_type: 'beataccents', value: false });\n\n\t\t}\n\n\t\t// Specified options in abc string.\n\n\t\t// If the tempo was passed in, use that.\n\t\t// If the tempo is specified, use that.\n\t\t// If there is a default, use that.\n\t\t// Otherwise, use the default.\n\t\tif (options.qpm)\n\t\t\tqpm = parseInt(options.qpm, 10);\n\t\telse if (abctune.metaText.tempo)\n\t\t\tqpm = interpretTempo(abctune.metaText.tempo);\n\t\telse if (options.defaultQpm)\n\t\t\tqpm = options.defaultQpm;\n\t\telse\n\t\t\tqpm = 180; \t// The tempo if there isn't a tempo specified.\n\n\t\tvar startVoice = [];\n\t\tif (bagpipes)\n\t\t\tstartVoice.push({ el_type: 'bagpipes' });\n\t\tstartVoice.push({ el_type: 'instrument', program: program });\n\t\tif (channel)\n\t\t\tstartVoice.push({ el_type: 'channel', channel: channel });\n\t\tif (transpose)\n\t\t\tstartVoice.push({ el_type: 'transpose', transpose: transpose });\n\t\tstartVoice.push({ el_type: 'tempo', qpm: qpm });\n\t\tfor (var ss = 0; ss < startingMidi.length;ss++)\n\t\t\tstartVoice.push(startingMidi[ss]);\n\n\t\t// the relevant part of the input structure is:\n\t\t// abctune\n\t\t//\t\tarray lines\n\t\t//\t\t\tarray staff\n\t\t//\t\t\t\tobject key\n\t\t//\t\t\t\tobject meter\n\t\t//\t\t\t\tarray voices\n\t\t//\t\t\t\t\tarray abcelem\n\n\t\t// visit each voice completely in turn\n\t\tvar voices = [];\n\t\tvar startRepeatPlaceholder = []; // There is a place holder for each voice.\n\t\tvar skipEndingPlaceholder = []; // This is the place where the first ending starts.\n\t\tvar startingDrumSet = false;\n\t\tfor (var i = 0; i < abctune.lines.length; i++) {\n\t\t\t// For each group of staff lines in the tune.\n\t\t\tvar line = abctune.lines[i];\n\t\t\tif (line.staff) {\n\t\t\t\tvar staves = line.staff;\n\t\t\t\tvar voiceNumber = 0;\n\t\t\t\tfor (var j = 0; j < staves.length; j++) {\n\t\t\t\t\tvar staff = staves[j];\n\t\t\t\t\t// For each staff line\n\t\t\t\t\tfor (var k = 0; k < staff.voices.length; k++) {\n\t\t\t\t\t\t// For each voice in a staff line\n\t\t\t\t\t\tvar voice = staff.voices[k];\n\t\t\t\t\t\tif (!voices[voiceNumber]) {\n\t\t\t\t\t\t\tvoices[voiceNumber] = [].concat(JSON.parse(JSON.stringify(startVoice)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (staff.clef && staff.clef.type === 'perc') {\n\t\t\t\t\t\t\tfor (var cl = 0; cl < voices[voiceNumber].length; cl++) {\n\t\t\t\t\t\t\t\tif (voices[voiceNumber][cl].el_type === 'instrument')\n\t\t\t\t\t\t\t\t\tvoices[voiceNumber][cl].program = PERCUSSION_PROGRAM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (staff.key) {\n\t\t\t\t\t\t\tif (staff.key.root === 'HP')\n\t\t\t\t\t\t\t\tvoices[voiceNumber].push({el_type: 'key', accidentals: [{acc: 'natural', note: 'g'}, {acc: 'sharp', note: 'f'}, {acc: 'sharp', note: 'c'}]});\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tvoices[voiceNumber].push({el_type: 'key', accidentals: staff.key.accidentals });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (staff.meter) {\n\t\t\t\t\t\t\tvoices[voiceNumber].push(interpretMeter(staff.meter));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!startingDrumSet && drumOn) { // drum information is only needed once, so use the first line and track 0.\n\t\t\t\t\t\t\tvoices[voiceNumber].push({el_type: 'drum', params: {pattern: drumPattern, bars: drumBars, on: drumOn, intro: drumIntro}});\n\t\t\t\t\t\t\tstartingDrumSet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (staff.clef && staff.clef.transpose) {\n\t\t\t\t\t\t\tstaff.clef.el_type = 'clef';\n\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'transpose', transpose: staff.clef.transpose });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (abctune.formatting.midi && abctune.formatting.midi.drumoff) {\n\t\t\t\t\t\t\t// If there is a drum off command right at the beginning it is put in the metaText instead of the stream,\n\t\t\t\t\t\t\t// so we will just insert it here.\n\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'bar' });\n\t\t\t\t\t\t\tvoices[voiceNumber].push({el_type: 'drum', params: {pattern: \"\", on: false }});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar noteEventsInBar = 0;\n\t\t\t\t\t\tfor (var v = 0; v < voice.length; v++) {\n\t\t\t\t\t\t\t// For each element in a voice\n\t\t\t\t\t\t\tvar elem = voice[v];\n\t\t\t\t\t\t\tswitch (elem.el_type) {\n\t\t\t\t\t\t\t\tcase \"note\":\n\t\t\t\t\t\t\t\t\t// regular items are just pushed.\n\t\t\t\t\t\t\t\t\tif (!elem.rest || elem.rest.type !== 'spacer') {\n\t\t\t\t\t\t\t\t\t\tif (elem.decoration) {\n\t\t\t\t\t\t\t\t\t\t\tif (elem.decoration.indexOf('ppp') >= 0)\n\t\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'beat', beats: [30, 20, 10, 1] });\n\t\t\t\t\t\t\t\t\t\t\telse if (elem.decoration.indexOf('pp') >= 0)\n\t\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'beat', beats: [45, 35, 20, 1] });\n\t\t\t\t\t\t\t\t\t\t\telse if (elem.decoration.indexOf('p') >= 0)\n\t\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'beat', beats: [60, 50, 35, 1] });\n\t\t\t\t\t\t\t\t\t\t\telse if (elem.decoration.indexOf('mp') >= 0)\n\t\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'beat', beats: [75, 65, 50, 1] });\n\t\t\t\t\t\t\t\t\t\t\telse if (elem.decoration.indexOf('mf') >= 0)\n\t\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'beat', beats: [90, 80, 65, 1] });\n\t\t\t\t\t\t\t\t\t\t\telse if (elem.decoration.indexOf('f') >= 0)\n\t\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'beat', beats: [105, 95, 80, 1] });\n\t\t\t\t\t\t\t\t\t\t\telse if (elem.decoration.indexOf('ff') >= 0)\n\t\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'beat', beats: [120, 110, 95, 1] });\n\t\t\t\t\t\t\t\t\t\t\telse if (elem.decoration.indexOf('fff') >= 0)\n\t\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'beat', beats: [127, 125, 110, 1] });\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push(elem);\n\t\t\t\t\t\t\t\t\t\tnoteEventsInBar++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"key\":\n\t\t\t\t\t\t\t\t\tif (elem.root === 'HP')\n\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({el_type: 'key', accidentals: [{acc: 'natural', note: 'g'}, {acc: 'sharp', note: 'f'}, {acc: 'sharp', note: 'c'}]});\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({el_type: 'key', accidentals: elem.accidentals });\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"meter\":\n\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push(interpretMeter(elem));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"clef\": // need to keep this to catch the \"transpose\" element.\n\t\t\t\t\t\t\t\t\tif (elem.transpose)\n\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'transpose', transpose: elem.transpose });\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"tempo\":\n\t\t\t\t\t\t\t\t\tqpm = interpretTempo(elem);\n\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'tempo', qpm: qpm });\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"bar\":\n\t\t\t\t\t\t\t\t\tif (noteEventsInBar > 0) // don't add two bars in a row.\n\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'bar' }); // We need the bar marking to reset the accidentals.\n\t\t\t\t\t\t\t\t\tnoteEventsInBar = 0;\n\t\t\t\t\t\t\t\t\t// figure out repeats and endings --\n\t\t\t\t\t\t\t\t\t// The important part is where there is a start repeat, and end repeat, or a first ending.\n\t\t\t\t\t\t\t\t\tvar endRepeat = (elem.type === \"bar_right_repeat\" || elem.type === \"bar_dbl_repeat\");\n\t\t\t\t\t\t\t\t\tvar startEnding = (elem.startEnding === '1');\n\t\t\t\t\t\t\t\t\tvar startRepeat = (elem.type === \"bar_left_repeat\" || elem.type === \"bar_dbl_repeat\" || elem.type === \"bar_right_repeat\");\n\t\t\t\t\t\t\t\t\tif (endRepeat) {\n\t\t\t\t\t\t\t\t\t\tvar s = startRepeatPlaceholder[voiceNumber];\n\t\t\t\t\t\t\t\t\t\tif (!s) s = 0; // If there wasn't a left repeat, then we repeat from the beginning.\n\t\t\t\t\t\t\t\t\t\tvar e = skipEndingPlaceholder[voiceNumber];\n\t\t\t\t\t\t\t\t\t\tif (!e) e = voices[voiceNumber].length; // If there wasn't a first ending marker, then we copy everything.\n\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber] = voices[voiceNumber].concat(voices[voiceNumber].slice(s, e));\n\t\t\t\t\t\t\t\t\t\t// reset these in case there is a second repeat later on.\n\t\t\t\t\t\t\t\t\t\tskipEndingPlaceholder[voiceNumber] = undefined;\n\t\t\t\t\t\t\t\t\t\tstartRepeatPlaceholder[voiceNumber] = undefined;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (startEnding)\n\t\t\t\t\t\t\t\t\t\tskipEndingPlaceholder[voiceNumber] = voices[voiceNumber].length;\n\t\t\t\t\t\t\t\t\tif (startRepeat)\n\t\t\t\t\t\t\t\t\t\tstartRepeatPlaceholder[voiceNumber] = voices[voiceNumber].length;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'style':\n\t\t\t\t\t\t\t\t\t// TODO-PER: If this is set to rhythm heads, then it should use the percussion channel.\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'part':\n\t\t\t\t\t\t\t\t\t// TODO-PER: If there is a part section in the header, then this should probably affect the repeats.\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'stem':\n\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t// These elements don't affect sound\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'midi':\n\t\t\t\t\t\t\t\t\t//console.log(\"MIDI inline\", elem); // TODO-PER: for debugging. Remove this.\n\t\t\t\t\t\t\t\t\tvar drumChange = false;\n\t\t\t\t\t\t\t\t\tswitch (elem.cmd) {\n\t\t\t\t\t\t\t\t\t\tcase \"drumon\": drumOn = true; drumChange = true; break;\n\t\t\t\t\t\t\t\t\t\tcase \"drumoff\": drumOn = false; drumChange = true; break;\n\t\t\t\t\t\t\t\t\t\tcase \"drum\": drumPattern = elem.params; drumChange = true; break;\n\t\t\t\t\t\t\t\t\t\tcase \"drumbars\": drumBars = elem.params[0]; drumChange = true; break;\n\t\t\t\t\t\t\t\t\t\tcase \"drummap\":\n\t\t\t\t\t\t\t\t\t\t\t// This is handled before getting here so it can be ignored.\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"program\":\n\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'instrument', program: elem.params[0] });\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"transpose\":\n\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'transpose', transpose: elem.params[0] });\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"gchordoff\":\n\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'gchord', tacet: true });\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"gchordon\":\n\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'gchord', tacet: false });\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"beat\":\n\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'beat', beats: elem.params });\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"nobeataccents\":\n\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'beataccents', value: false });\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"beataccents\":\n\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'beataccents', value: true });\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"vol\":\n\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'vol', volume: elem.params[0] });\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase \"volinc\":\n\t\t\t\t\t\t\t\t\t\t\tvoices[voiceNumber].push({ el_type: 'volinc', volume: elem.params[0] });\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.log(\"MIDI seq: midi cmd not handled: \", elem.cmd, elem);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (drumChange) {\n\t\t\t\t\t\t\t\t\t\tvoices[0].push({el_type: 'drum', params: { pattern: drumPattern, bars: drumBars, intro: drumIntro, on: drumOn}});\n\t\t\t\t\t\t\t\t\t\tstartingDrumSet = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tconsole.log(\"MIDI: element type \" + elem.el_type + \" not handled.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvoiceNumber++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (drumIntro) {\n\t\t\tvar pickups = abctune.getPickupLength();\n\t\t\t// add some measures of rests to the start of each track.\n\t\t\tfor (var vv = 0; vv < voices.length; vv++) {\n\t\t\t\tvar insertPoint = 0;\n\t\t\t\twhile (voices[vv][insertPoint].el_type !== \"note\" && voices[vv].length > insertPoint)\n\t\t\t\t\tinsertPoint++;\n\t\t\t\tif (voices[vv].length > insertPoint) {\n\t\t\t\t\tfor (var w = 0; w < drumIntro; w++) {\n\t\t\t\t\t\t// If it is the last measure of intro, subtract the pickups.\n\t\t\t\t\t\tif (pickups === 0 || w < drumIntro-1)\n\t\t\t\t\t\t\tvoices[vv].splice(insertPoint, 0, {el_type: \"note\", rest: {type: \"rest\"}, duration: measureLength},\n\t\t\t\t\t\t\t\t{ el_type: \"bar\" });\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvoices[vv].splice(insertPoint, 0, {el_type: \"note\", rest: {type: \"rest\"}, duration: measureLength-pickups});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn voices;\n\t};\n\n\tfunction interpretTempo(element) {\n\t\tvar duration = 1/4;\n\t\tif (element.duration) {\n\t\t\tduration = element.duration[0];\n\t\t}\n\t\tvar bpm = 60;\n\t\tif (element.bpm) {\n\t\t\tbpm = element.bpm;\n\t\t}\n\t\t// The tempo is defined with a beat of a 1/4 note, so we need to adjust it if the tempo is expressed with other than a quarter note.\n\t\t// expressedDuration * expressedBeatsPerMinute / lengthOfQuarterNote = quarterNotesPerMinute\n\t\treturn duration * bpm / 0.25;\n\t}\n\n\tfunction interpretMeter(element) {\n\t\tvar meter;\n\t\tswitch (element.type) {\n\t\t\tcase \"common_time\":\n\t\t\t\tmeter = { el_type: 'meter', num: 4, den: 4 };\n\t\t\t\tbreak;\n\t\t\tcase \"cut_time\":\n\t\t\t\tmeter = { el_type: 'meter', num: 2, den: 2 };\n\t\t\t\tbreak;\n\t\t\tcase \"specified\":\n\t\t\t\t// TODO-PER: only taking the first meter, so the complex meters are not handled.\n\t\t\t\tmeter = { el_type: 'meter', num: element.value[0].num, den: element.value[0].den };\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// This should never happen.\n\t\t\t\tmeter = { el_type: 'meter' };\n\t\t}\n\t\tmeasureLength = meter.num/meter.den;\n\t\treturn meter;\n\t}\n})();\n\nmodule.exports = sequence;\n"]},"metadata":{},"sourceType":"script"}