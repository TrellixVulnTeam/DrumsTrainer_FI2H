{"ast":null,"code":"//    abc_parse.js: parses a string representing ABC Music Notation into a usable internal structure.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*global window */\nvar parseCommon = require('./abc_common');\n\nvar parseDirective = require('./abc_parse_directive');\n\nvar ParseHeader = require('./abc_parse_header');\n\nvar parseKeyVoice = require('./abc_parse_key_voice');\n\nvar Tokenizer = require('./abc_tokenizer');\n\nvar transpose = require('./abc_transpose');\n\nvar wrap = require('./wrap_lines');\n\nvar Tune = require('../data/abc_tune');\n\nvar Parse = function () {\n  \"use strict\";\n\n  var tune = new Tune();\n  var tokenizer = new Tokenizer();\n\n  this.getTune = function () {\n    return {\n      formatting: tune.formatting,\n      lines: tune.lines,\n      media: tune.media,\n      metaText: tune.metaText,\n      version: tune.version,\n      addElementToEvents: tune.addElementToEvents,\n      addUsefulCallbackInfo: tune.addUsefulCallbackInfo,\n      getBarLength: tune.getBarLength,\n      getBeatLength: tune.getBeatLength,\n      getBeatsPerMeasure: tune.getBeatsPerMeasure,\n      getBpm: tune.getBpm,\n      getMeter: tune.getMeter,\n      getMeterFraction: tune.getMeterFraction,\n      getPickupLength: tune.getPickupLength,\n      getKeySignature: tune.getKeySignature,\n      makeVoicesArray: tune.makeVoicesArray,\n      millisecondsPerMeasure: tune.millisecondsPerMeasure,\n      setupEvents: tune.setupEvents,\n      setTiming: tune.setTiming\n    };\n  };\n\n  function addPositioning(el, type, value) {\n    if (!el.positioning) el.positioning = {};\n    el.positioning[type] = value;\n  }\n\n  function addFont(el, type, value) {\n    if (!el.fonts) el.fonts = {};\n    el.fonts[type] = value;\n  }\n\n  var multilineVars = {\n    reset: function () {\n      for (var property in this) {\n        if (this.hasOwnProperty(property) && typeof this[property] !== \"function\") {\n          delete this[property];\n        }\n      }\n\n      this.iChar = 0;\n      this.key = {\n        accidentals: [],\n        root: 'none',\n        acc: '',\n        mode: ''\n      };\n      this.meter = null; // if no meter is specified, free meter is assumed\n\n      this.origMeter = null; // this is for new voices that are created after we set the meter.\n\n      this.hasMainTitle = false;\n      this.default_length = 0.125;\n      this.clef = {\n        type: 'treble',\n        verticalPos: 0\n      };\n      this.next_note_duration = 0;\n      this.start_new_line = true;\n      this.is_in_header = true;\n      this.is_in_history = false;\n      this.partForNextLine = {};\n      this.havent_set_length = true;\n      this.voices = {};\n      this.staves = [];\n      this.macros = {};\n      this.currBarNumber = 1;\n      this.barCounter = {};\n      this.inTextBlock = false;\n      this.inPsBlock = false;\n      this.ignoredDecorations = [];\n      this.textBlock = \"\";\n      this.score_is_present = false; // Can't have original V: lines when there is the score directive\n\n      this.inEnding = false;\n      this.inTie = [];\n      this.inTieChord = {};\n      this.vocalPosition = \"auto\";\n      this.dynamicPosition = \"auto\";\n      this.chordPosition = \"auto\";\n      this.ornamentPosition = \"auto\";\n      this.volumePosition = \"auto\";\n      this.openSlurs = [];\n      this.freegchord = false;\n    },\n    differentFont: function (type, defaultFonts) {\n      if (this[type].decoration !== defaultFonts[type].decoration) return true;\n      if (this[type].face !== defaultFonts[type].face) return true;\n      if (this[type].size !== defaultFonts[type].size) return true;\n      if (this[type].style !== defaultFonts[type].style) return true;\n      if (this[type].weight !== defaultFonts[type].weight) return true;\n      return false;\n    },\n    addFormattingOptions: function (el, defaultFonts, elType) {\n      if (elType === 'note') {\n        if (this.vocalPosition !== 'auto') addPositioning(el, 'vocalPosition', this.vocalPosition);\n        if (this.dynamicPosition !== 'auto') addPositioning(el, 'dynamicPosition', this.dynamicPosition);\n        if (this.chordPosition !== 'auto') addPositioning(el, 'chordPosition', this.chordPosition);\n        if (this.ornamentPosition !== 'auto') addPositioning(el, 'ornamentPosition', this.ornamentPosition);\n        if (this.volumePosition !== 'auto') addPositioning(el, 'volumePosition', this.volumePosition);\n        if (this.differentFont(\"annotationfont\", defaultFonts)) addFont(el, 'annotationfont', this.annotationfont);\n        if (this.differentFont(\"gchordfont\", defaultFonts)) addFont(el, 'gchordfont', this.gchordfont);\n        if (this.differentFont(\"vocalfont\", defaultFonts)) addFont(el, 'vocalfont', this.vocalfont);\n        if (this.differentFont(\"tripletfont\", defaultFonts)) addFont(el, 'tripletfont', this.tripletfont);\n      } else if (elType === 'bar') {\n        if (this.dynamicPosition !== 'auto') addPositioning(el, 'dynamicPosition', this.dynamicPosition);\n        if (this.chordPosition !== 'auto') addPositioning(el, 'chordPosition', this.chordPosition);\n        if (this.ornamentPosition !== 'auto') addPositioning(el, 'ornamentPosition', this.ornamentPosition);\n        if (this.volumePosition !== 'auto') addPositioning(el, 'volumePosition', this.volumePosition);\n        if (this.differentFont(\"measurefont\", defaultFonts)) addFont(el, 'measurefont', this.measurefont);\n        if (this.differentFont(\"repeatfont\", defaultFonts)) addFont(el, 'repeatfont', this.repeatfont);\n      }\n    }\n  };\n\n  var addWarning = function (str) {\n    if (!multilineVars.warnings) multilineVars.warnings = [];\n    multilineVars.warnings.push(str);\n  };\n\n  var addWarningObject = function (warningObject) {\n    if (!multilineVars.warningObjects) multilineVars.warningObjects = [];\n    multilineVars.warningObjects.push(warningObject);\n  };\n\n  var encode = function (str) {\n    var ret = parseCommon.gsub(str, '\\x12', ' ');\n    ret = parseCommon.gsub(ret, '&', '&amp;');\n    ret = parseCommon.gsub(ret, '<', '&lt;');\n    return parseCommon.gsub(ret, '>', '&gt;');\n  };\n\n  var warn = function (str, line, col_num) {\n    if (!line) line = \" \";\n    var bad_char = line.charAt(col_num);\n    if (bad_char === ' ') bad_char = \"SPACE\";\n    var clean_line = encode(line.substring(0, col_num)) + '<span style=\"text-decoration:underline;font-size:1.3em;font-weight:bold;\">' + bad_char + '</span>' + encode(line.substring(col_num + 1));\n    addWarning(\"Music Line:\" + tune.getNumLines() + \":\" + (col_num + 1) + ': ' + str + \":  \" + clean_line);\n    addWarningObject({\n      message: str,\n      line: line,\n      startChar: multilineVars.iChar + col_num,\n      column: col_num\n    });\n  };\n\n  var header = new ParseHeader(tokenizer, warn, multilineVars, tune);\n\n  this.getWarnings = function () {\n    return multilineVars.warnings;\n  };\n\n  this.getWarningObjects = function () {\n    return multilineVars.warningObjects;\n  };\n\n  var letter_to_chord = function (line, i) {\n    if (line.charAt(i) === '\"') {\n      var chord = tokenizer.getBrackettedSubstring(line, i, 5);\n      if (!chord[2]) warn(\"Missing the closing quote while parsing the chord symbol\", line, i); // If it starts with ^, then the chord appears above.\n      // If it starts with _ then the chord appears below.\n      // (note that the 2.0 draft standard defines them as not chords, but annotations and also defines @.)\n\n      if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '^') {\n        chord[1] = chord[1].substring(1);\n        chord[2] = 'above';\n      } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '_') {\n        chord[1] = chord[1].substring(1);\n        chord[2] = 'below';\n      } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '<') {\n        chord[1] = chord[1].substring(1);\n        chord[2] = 'left';\n      } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '>') {\n        chord[1] = chord[1].substring(1);\n        chord[2] = 'right';\n      } else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '@') {\n        // @-15,5.7\n        chord[1] = chord[1].substring(1);\n        var x = tokenizer.getFloat(chord[1]);\n        if (x.digits === 0) warn(\"Missing first position in absolutely positioned annotation.\", line, i);\n        chord[1] = chord[1].substring(x.digits);\n        if (chord[1][0] !== ',') warn(\"Missing comma absolutely positioned annotation.\", line, i);\n        chord[1] = chord[1].substring(1);\n        var y = tokenizer.getFloat(chord[1]);\n        if (y.digits === 0) warn(\"Missing second position in absolutely positioned annotation.\", line, i);\n        chord[1] = chord[1].substring(y.digits);\n        var ws = tokenizer.skipWhiteSpace(chord[1]);\n        chord[1] = chord[1].substring(ws);\n        chord[2] = null;\n        chord[3] = {\n          x: x.value,\n          y: y.value\n        };\n      } else {\n        if (multilineVars.freegchord !== true) {\n          chord[1] = chord[1].replace(/([ABCDEFG0-9])b/g, \"$1♭\");\n          chord[1] = chord[1].replace(/([ABCDEFG0-9])#/g, \"$1♯\");\n        }\n\n        chord[2] = 'default';\n        chord[1] = transpose.chordName(multilineVars, chord[1]);\n      }\n\n      return chord;\n    }\n\n    return [0, \"\"];\n  };\n\n  var legalAccents = [\"trill\", \"lowermordent\", \"uppermordent\", \"mordent\", \"pralltriller\", \"accent\", \"fermata\", \"invertedfermata\", \"tenuto\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"+\", \"wedge\", \"open\", \"thumb\", \"snap\", \"turn\", \"roll\", \"breath\", \"shortphrase\", \"mediumphrase\", \"longphrase\", \"segno\", \"coda\", \"D.S.\", \"D.C.\", \"fine\", \"slide\", \"^\", \"marcato\", \"upbow\", \"downbow\", \"/\", \"//\", \"///\", \"////\", \"trem1\", \"trem2\", \"trem3\", \"trem4\", \"turnx\", \"invertedturn\", \"invertedturnx\", \"trill(\", \"trill)\", \"arpeggio\", \"xstem\", \"mark\", \"umarcato\", \"style=normal\", \"style=harmonic\", \"style=rhythm\", \"style=x\"];\n  var volumeDecorations = [\"p\", \"pp\", \"f\", \"ff\", \"mf\", \"mp\", \"ppp\", \"pppp\", \"fff\", \"ffff\", \"sfz\"];\n  var dynamicDecorations = [\"crescendo(\", \"crescendo)\", \"diminuendo(\", \"diminuendo)\"];\n  var accentPseudonyms = [[\"<\", \"accent\"], [\">\", \"accent\"], [\"tr\", \"trill\"], [\"plus\", \"+\"], [\"emphasis\", \"accent\"], [\"^\", \"umarcato\"], [\"marcato\", \"umarcato\"]];\n  var accentDynamicPseudonyms = [[\"<(\", \"crescendo(\"], [\"<)\", \"crescendo)\"], [\">(\", \"diminuendo(\"], [\">)\", \"diminuendo)\"]];\n\n  var letter_to_accent = function (line, i) {\n    var macro = multilineVars.macros[line.charAt(i)];\n\n    if (macro !== undefined) {\n      if (macro.charAt(0) === '!' || macro.charAt(0) === '+') macro = macro.substring(1);\n      if (macro.charAt(macro.length - 1) === '!' || macro.charAt(macro.length - 1) === '+') macro = macro.substring(0, macro.length - 1);\n      if (parseCommon.detect(legalAccents, function (acc) {\n        return macro === acc;\n      })) return [1, macro];else if (parseCommon.detect(volumeDecorations, function (acc) {\n        return macro === acc;\n      })) {\n        if (multilineVars.volumePosition === 'hidden') macro = \"\";\n        return [1, macro];\n      } else if (parseCommon.detect(dynamicDecorations, function (acc) {\n        if (multilineVars.dynamicPosition === 'hidden') macro = \"\";\n        return macro === acc;\n      })) {\n        return [1, macro];\n      } else {\n        if (!parseCommon.detect(multilineVars.ignoredDecorations, function (dec) {\n          return macro === dec;\n        })) warn(\"Unknown macro: \" + macro, line, i);\n        return [1, ''];\n      }\n    }\n\n    switch (line.charAt(i)) {\n      case '.':\n        return [1, 'staccato'];\n\n      case 'u':\n        return [1, 'upbow'];\n\n      case 'v':\n        return [1, 'downbow'];\n\n      case '~':\n        return [1, 'irishroll'];\n\n      case '!':\n      case '+':\n        var ret = tokenizer.getBrackettedSubstring(line, i, 5); // Be sure that the accent is recognizable.\n\n        if (ret[1].length > 0 && (ret[1].charAt(0) === '^' || ret[1].charAt(0) === '_')) ret[1] = ret[1].substring(1); // TODO-PER: The test files have indicators forcing the ornament to the top or bottom, but that isn't in the standard. We'll just ignore them.\n\n        if (parseCommon.detect(legalAccents, function (acc) {\n          return ret[1] === acc;\n        })) return ret;\n\n        if (parseCommon.detect(volumeDecorations, function (acc) {\n          return ret[1] === acc;\n        })) {\n          if (multilineVars.volumePosition === 'hidden') ret[1] = '';\n          return ret;\n        }\n\n        if (parseCommon.detect(dynamicDecorations, function (acc) {\n          return ret[1] === acc;\n        })) {\n          if (multilineVars.dynamicPosition === 'hidden') ret[1] = '';\n          return ret;\n        }\n\n        if (parseCommon.detect(accentPseudonyms, function (acc) {\n          if (ret[1] === acc[0]) {\n            ret[1] = acc[1];\n            return true;\n          } else return false;\n        })) return ret;\n\n        if (parseCommon.detect(accentDynamicPseudonyms, function (acc) {\n          if (ret[1] === acc[0]) {\n            ret[1] = acc[1];\n            return true;\n          } else return false;\n        })) {\n          if (multilineVars.dynamicPosition === 'hidden') ret[1] = '';\n          return ret;\n        } // We didn't find the accent in the list, so consume the space, but don't return an accent.\n        // Although it is possible that ! was used as a line break, so accept that.\n\n\n        if (line.charAt(i) === '!' && (ret[0] === 1 || line.charAt(i + ret[0] - 1) !== '!')) return [1, null];\n        warn(\"Unknown decoration: \" + ret[1], line, i);\n        ret[1] = \"\";\n        return ret;\n\n      case 'H':\n        return [1, 'fermata'];\n\n      case 'J':\n        return [1, 'slide'];\n\n      case 'L':\n        return [1, 'accent'];\n\n      case 'M':\n        return [1, 'mordent'];\n\n      case 'O':\n        return [1, 'coda'];\n\n      case 'P':\n        return [1, 'pralltriller'];\n\n      case 'R':\n        return [1, 'roll'];\n\n      case 'S':\n        return [1, 'segno'];\n\n      case 'T':\n        return [1, 'trill'];\n    }\n\n    return [0, 0];\n  };\n\n  var letter_to_spacer = function (line, i) {\n    var start = i;\n\n    while (tokenizer.isWhiteSpace(line.charAt(i))) i++;\n\n    return [i - start];\n  }; // returns the class of the bar line\n  // the number of the repeat\n  // and the number of characters used up\n  // if 0 is returned, then the next element was not a bar line\n\n\n  var letter_to_bar = function (line, curr_pos) {\n    var ret = tokenizer.getBarLine(line, curr_pos);\n    if (ret.len === 0) return [0, \"\"];\n\n    if (ret.warn) {\n      warn(ret.warn, line, curr_pos);\n      return [ret.len, \"\"];\n    } // Now see if this is a repeated ending\n    // A repeated ending is all of the characters 1,2,3,4,5,6,7,8,9,0,-, and comma\n    // It can also optionally start with '[', which is ignored.\n    // Also, it can have white space before the '['.\n\n\n    for (var ws = 0; ws < line.length; ws++) if (line.charAt(curr_pos + ret.len + ws) !== ' ') break;\n\n    var orig_bar_len = ret.len;\n\n    if (line.charAt(curr_pos + ret.len + ws) === '[') {\n      ret.len += ws + 1;\n    } // It can also be a quoted string. It is unclear whether that construct requires '[', but it seems like it would. otherwise it would be confused with a regular chord.\n\n\n    if (line.charAt(curr_pos + ret.len) === '\"' && line.charAt(curr_pos + ret.len - 1) === '[') {\n      var ending = tokenizer.getBrackettedSubstring(line, curr_pos + ret.len, 5);\n      return [ret.len + ending[0], ret.token, ending[1]];\n    }\n\n    var retRep = tokenizer.getTokenOf(line.substring(curr_pos + ret.len), \"1234567890-,\");\n    if (retRep.len === 0 || retRep.token[0] === '-') return [orig_bar_len, ret.token];\n    return [ret.len + retRep.len, ret.token, retRep.token];\n  };\n\n  var tripletQ = {\n    2: 3,\n    3: 2,\n    4: 3,\n    5: 2,\n    // TODO-PER: not handling 6/8 rhythm yet\n    6: 2,\n    7: 2,\n    // TODO-PER: not handling 6/8 rhythm yet\n    8: 3,\n    9: 2 // TODO-PER: not handling 6/8 rhythm yet\n\n  };\n\n  var letter_to_open_slurs_and_triplets = function (line, i) {\n    // consume spaces, and look for all the open parens. If there is a number after the open paren,\n    // that is a triplet. Otherwise that is a slur. Collect all the slurs and the first triplet.\n    var ret = {};\n    var start = i;\n\n    while (line.charAt(i) === '(' || tokenizer.isWhiteSpace(line.charAt(i))) {\n      if (line.charAt(i) === '(') {\n        if (i + 1 < line.length && line.charAt(i + 1) >= '2' && line.charAt(i + 1) <= '9') {\n          if (ret.triplet !== undefined) warn(\"Can't nest triplets\", line, i);else {\n            ret.triplet = line.charAt(i + 1) - '0';\n            ret.tripletQ = tripletQ[ret.triplet];\n            ret.num_notes = ret.triplet;\n\n            if (i + 2 < line.length && line.charAt(i + 2) === ':') {\n              // We are expecting \"(p:q:r\" or \"(p:q\" or \"(p::r\"\n              // That is: \"put p notes into the time of q for the next r notes\"\n              // if r is missing, then it is equal to p.\n              // if q is missing, it is determined from this table:\n              // (2 notes in the time of 3\n              // (3 notes in the time of 2\n              // (4 notes in the time of 3\n              // (5 notes in the time of n | if time sig is (6/8, 9/8, 12/8), n=3, else n=2\n              // (6 notes in the time of 2\n              // (7 notes in the time of n\n              // (8 notes in the time of 3\n              // (9 notes in the time of n\n              if (i + 3 < line.length && line.charAt(i + 3) === ':') {\n                // The second number, 'q', is not present.\n                if (i + 4 < line.length && line.charAt(i + 4) >= '1' && line.charAt(i + 4) <= '9') {\n                  ret.num_notes = line.charAt(i + 4) - '0';\n                  i += 3;\n                } else warn(\"expected number after the two colons after the triplet to mark the duration\", line, i);\n              } else if (i + 3 < line.length && line.charAt(i + 3) >= '1' && line.charAt(i + 3) <= '9') {\n                ret.tripletQ = line.charAt(i + 3) - '0';\n\n                if (i + 4 < line.length && line.charAt(i + 4) === ':') {\n                  if (i + 5 < line.length && line.charAt(i + 5) >= '1' && line.charAt(i + 5) <= '9') {\n                    ret.num_notes = line.charAt(i + 5) - '0';\n                    i += 4;\n                  }\n                } else {\n                  i += 2;\n                }\n              } else warn(\"expected number after the triplet to mark the duration\", line, i);\n            }\n          }\n          i++;\n        } else {\n          if (ret.startSlur === undefined) ret.startSlur = 1;else ret.startSlur++;\n        }\n      }\n\n      i++;\n    }\n\n    ret.consumed = i - start;\n    return ret;\n  };\n\n  var addWords = function (line, words) {\n    if (!line) {\n      warn(\"Can't add words before the first line of music\", line, 0);\n      return;\n    }\n\n    words = parseCommon.strip(words);\n    if (words.charAt(words.length - 1) !== '-') words = words + ' '; // Just makes it easier to parse below, since every word has a divider after it.\n\n    var word_list = []; // first make a list of words from the string we are passed. A word is divided on either a space or dash.\n\n    var last_divider = 0;\n    var replace = false;\n\n    var addWord = function (i) {\n      var word = parseCommon.strip(words.substring(last_divider, i));\n      last_divider = i + 1;\n\n      if (word.length > 0) {\n        if (replace) word = parseCommon.gsub(word, '~', ' ');\n        var div = words.charAt(i);\n        if (div !== '_' && div !== '-') div = ' ';\n        word_list.push({\n          syllable: tokenizer.translateString(word),\n          divider: div\n        });\n        replace = false;\n        return true;\n      }\n\n      return false;\n    };\n\n    for (var i = 0; i < words.length; i++) {\n      switch (words.charAt(i)) {\n        case ' ':\n        case '\\x12':\n          addWord(i);\n          break;\n\n        case '-':\n          if (!addWord(i) && word_list.length > 0) {\n            parseCommon.last(word_list).divider = '-';\n            word_list.push({\n              skip: true,\n              to: 'next'\n            });\n          }\n\n          break;\n\n        case '_':\n          addWord(i);\n          word_list.push({\n            skip: true,\n            to: 'slur'\n          });\n          break;\n\n        case '*':\n          addWord(i);\n          word_list.push({\n            skip: true,\n            to: 'next'\n          });\n          break;\n\n        case '|':\n          addWord(i);\n          word_list.push({\n            skip: true,\n            to: 'bar'\n          });\n          break;\n\n        case '~':\n          replace = true;\n          break;\n      }\n    }\n\n    var inSlur = false;\n    parseCommon.each(line, function (el) {\n      if (word_list.length !== 0) {\n        if (word_list[0].skip) {\n          switch (word_list[0].to) {\n            case 'next':\n              if (el.el_type === 'note' && el.pitches !== null && !inSlur) word_list.shift();\n              break;\n\n            case 'slur':\n              if (el.el_type === 'note' && el.pitches !== null) word_list.shift();\n              break;\n\n            case 'bar':\n              if (el.el_type === 'bar') word_list.shift();\n              break;\n          }\n\n          if (el.el_type !== 'bar') {\n            if (el.lyric === undefined) el.lyric = [{\n              syllable: \"\",\n              divider: \" \"\n            }];else el.lyric.push({\n              syllable: \"\",\n              divider: \" \"\n            });\n          }\n        } else {\n          if (el.el_type === 'note' && el.rest === undefined && !inSlur) {\n            var lyric = word_list.shift();\n            if (lyric.syllable) lyric.syllable = lyric.syllable.replace(/ +/g, '\\xA0');\n            if (el.lyric === undefined) el.lyric = [lyric];else el.lyric.push(lyric);\n          }\n        }\n      }\n    });\n  };\n\n  var addSymbols = function (line, words) {\n    // TODO-PER: Currently copied from w: line. This needs to be read as symbols instead.\n    if (!line) {\n      warn(\"Can't add symbols before the first line of music\", line, 0);\n      return;\n    }\n\n    words = parseCommon.strip(words);\n    if (words.charAt(words.length - 1) !== '-') words = words + ' '; // Just makes it easier to parse below, since every word has a divider after it.\n\n    var word_list = []; // first make a list of words from the string we are passed. A word is divided on either a space or dash.\n\n    var last_divider = 0;\n    var replace = false;\n\n    var addWord = function (i) {\n      var word = parseCommon.strip(words.substring(last_divider, i));\n      last_divider = i + 1;\n\n      if (word.length > 0) {\n        if (replace) word = parseCommon.gsub(word, '~', ' ');\n        var div = words.charAt(i);\n        if (div !== '_' && div !== '-') div = ' ';\n        word_list.push({\n          syllable: tokenizer.translateString(word),\n          divider: div\n        });\n        replace = false;\n        return true;\n      }\n\n      return false;\n    };\n\n    for (var i = 0; i < words.length; i++) {\n      switch (words.charAt(i)) {\n        case ' ':\n        case '\\x12':\n          addWord(i);\n          break;\n\n        case '-':\n          if (!addWord(i) && word_list.length > 0) {\n            parseCommon.last(word_list).divider = '-';\n            word_list.push({\n              skip: true,\n              to: 'next'\n            });\n          }\n\n          break;\n\n        case '_':\n          addWord(i);\n          word_list.push({\n            skip: true,\n            to: 'slur'\n          });\n          break;\n\n        case '*':\n          addWord(i);\n          word_list.push({\n            skip: true,\n            to: 'next'\n          });\n          break;\n\n        case '|':\n          addWord(i);\n          word_list.push({\n            skip: true,\n            to: 'bar'\n          });\n          break;\n\n        case '~':\n          replace = true;\n          break;\n      }\n    }\n\n    var inSlur = false;\n    parseCommon.each(line, function (el) {\n      if (word_list.length !== 0) {\n        if (word_list[0].skip) {\n          switch (word_list[0].to) {\n            case 'next':\n              if (el.el_type === 'note' && el.pitches !== null && !inSlur) word_list.shift();\n              break;\n\n            case 'slur':\n              if (el.el_type === 'note' && el.pitches !== null) word_list.shift();\n              break;\n\n            case 'bar':\n              if (el.el_type === 'bar') word_list.shift();\n              break;\n          }\n        } else {\n          if (el.el_type === 'note' && el.rest === undefined && !inSlur) {\n            var lyric = word_list.shift();\n            if (el.lyric === undefined) el.lyric = [lyric];else el.lyric.push(lyric);\n          }\n        }\n      }\n    });\n  };\n\n  var getBrokenRhythm = function (line, index) {\n    switch (line.charAt(index)) {\n      case '>':\n        if (index < line.length - 1 && line.charAt(index + 1) === '>') // double >>\n          return [2, 1.75, 0.25];else return [1, 1.5, 0.5];\n        break;\n\n      case '<':\n        if (index < line.length - 1 && line.charAt(index + 1) === '<') // double <<\n          return [2, 0.25, 1.75];else return [1, 0.5, 1.5];\n        break;\n    }\n\n    return null;\n  }; // TODO-PER: make this a method in el.\n\n\n  var addEndBeam = function (el) {\n    if (el.duration !== undefined && el.duration < 0.25) el.end_beam = true;\n    return el;\n  };\n\n  var pitches = {\n    A: 5,\n    B: 6,\n    C: 0,\n    D: 1,\n    E: 2,\n    F: 3,\n    G: 4,\n    a: 12,\n    b: 13,\n    c: 7,\n    d: 8,\n    e: 9,\n    f: 10,\n    g: 11\n  };\n  var rests = {\n    x: 'invisible',\n    y: 'spacer',\n    z: 'rest',\n    Z: 'multimeasure'\n  };\n\n  var getCoreNote = function (line, index, el, canHaveBrokenRhythm) {\n    //var el = { startChar: index };\n    var isComplete = function (state) {\n      return state === 'octave' || state === 'duration' || state === 'Zduration' || state === 'broken_rhythm' || state === 'end_slur';\n    };\n\n    var state = 'startSlur';\n    var durationSetByPreviousNote = false;\n\n    while (1) {\n      switch (line.charAt(index)) {\n        case '(':\n          if (state === 'startSlur') {\n            if (el.startSlur === undefined) el.startSlur = 1;else el.startSlur++;\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case ')':\n          if (isComplete(state)) {\n            if (el.endSlur === undefined) el.endSlur = 1;else el.endSlur++;\n          } else return null;\n\n          break;\n\n        case '^':\n          if (state === 'startSlur') {\n            el.accidental = 'sharp';\n            state = 'sharp2';\n          } else if (state === 'sharp2') {\n            el.accidental = 'dblsharp';\n            state = 'pitch';\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case '_':\n          if (state === 'startSlur') {\n            el.accidental = 'flat';\n            state = 'flat2';\n          } else if (state === 'flat2') {\n            el.accidental = 'dblflat';\n            state = 'pitch';\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case '=':\n          if (state === 'startSlur') {\n            el.accidental = 'natural';\n            state = 'pitch';\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case 'A':\n        case 'B':\n        case 'C':\n        case 'D':\n        case 'E':\n        case 'F':\n        case 'G':\n        case 'a':\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'e':\n        case 'f':\n        case 'g':\n          if (state === 'startSlur' || state === 'sharp2' || state === 'flat2' || state === 'pitch') {\n            el.pitch = pitches[line.charAt(index)];\n            transpose.note(multilineVars, el);\n            state = 'octave'; // At this point we have a valid note. The rest is optional. Set the duration in case we don't get one below\n\n            if (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {\n              el.duration = multilineVars.default_length * multilineVars.next_note_duration;\n              multilineVars.next_note_duration = 0;\n              durationSetByPreviousNote = true;\n            } else el.duration = multilineVars.default_length; // If the clef is percussion, there is probably some translation of the pitch to a particular drum kit item.\n\n\n            if (multilineVars.clef && multilineVars.clef.type === \"perc\" || multilineVars.currentVoice && multilineVars.currentVoice.clef === \"perc\") {\n              var key = line.charAt(index);\n\n              if (el.accidental) {\n                var accMap = {\n                  'dblflat': '__',\n                  'flat': '_',\n                  'natural': '=',\n                  'sharp': '^',\n                  'dblsharp': '^^'\n                };\n                key = accMap[el.accidental] + key;\n              }\n\n              if (tune.formatting && tune.formatting.midi && tune.formatting.midi.drummap) el.midipitch = tune.formatting.midi.drummap[key];\n            }\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case ',':\n          if (state === 'octave') {\n            el.pitch -= 7;\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case '\\'':\n          if (state === 'octave') {\n            el.pitch += 7;\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case 'x':\n        case 'y':\n        case 'z':\n        case 'Z':\n          if (state === 'startSlur') {\n            el.rest = {\n              type: rests[line.charAt(index)]\n            }; // There shouldn't be some of the properties that notes have. If some sneak in due to bad syntax in the abc file,\n            // just nix them here.\n\n            delete el.accidental;\n            delete el.startSlur;\n            delete el.startTie;\n            delete el.endSlur;\n            delete el.endTie;\n            delete el.end_beam;\n            delete el.grace_notes; // At this point we have a valid note. The rest is optional. Set the duration in case we don't get one below\n\n            if (el.rest.type === 'multimeasure') {\n              el.duration = 1;\n              state = 'Zduration';\n            } else {\n              if (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {\n                el.duration = multilineVars.default_length * multilineVars.next_note_duration;\n                multilineVars.next_note_duration = 0;\n                durationSetByPreviousNote = true;\n              } else el.duration = multilineVars.default_length;\n\n              state = 'duration';\n            }\n          } else if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n        case '0':\n        case '/':\n          if (state === 'octave' || state === 'duration') {\n            var fraction = tokenizer.getFraction(line, index); //if (!durationSetByPreviousNote)\n\n            el.duration = el.duration * fraction.value; // TODO-PER: We can test the returned duration here and give a warning if it isn't the one expected.\n\n            el.endChar = fraction.index;\n\n            while (fraction.index < line.length && (tokenizer.isWhiteSpace(line.charAt(fraction.index)) || line.charAt(fraction.index) === '-')) {\n              if (line.charAt(fraction.index) === '-') el.startTie = {};else el = addEndBeam(el);\n              fraction.index++;\n            }\n\n            index = fraction.index - 1;\n            state = 'broken_rhythm';\n          } else if (state === 'sharp2') {\n            el.accidental = 'quartersharp';\n            state = 'pitch';\n          } else if (state === 'flat2') {\n            el.accidental = 'quarterflat';\n            state = 'pitch';\n          } else if (state === 'Zduration') {\n            var num = tokenizer.getNumber(line, index);\n            el.duration = num.num;\n            el.endChar = num.index;\n            return el;\n          } else return null;\n\n          break;\n\n        case '-':\n          if (state === 'startSlur') {\n            // This is the first character, so it must have been meant for the previous note. Correct that here.\n            tune.addTieToLastNote();\n            el.endTie = true;\n          } else if (state === 'octave' || state === 'duration' || state === 'end_slur') {\n            el.startTie = {};\n            if (!durationSetByPreviousNote && canHaveBrokenRhythm) state = 'broken_rhythm';else {\n              // Peek ahead to the next character. If it is a space, then we have an end beam.\n              if (tokenizer.isWhiteSpace(line.charAt(index + 1))) addEndBeam(el);\n              el.endChar = index + 1;\n              return el;\n            }\n          } else if (state === 'broken_rhythm') {\n            el.endChar = index;\n            return el;\n          } else return null;\n\n          break;\n\n        case ' ':\n        case '\\t':\n          if (isComplete(state)) {\n            el.end_beam = true; // look ahead to see if there is a tie\n\n            do {\n              if (line.charAt(index) === '-') el.startTie = {};\n              index++;\n            } while (index < line.length && (tokenizer.isWhiteSpace(line.charAt(index)) || line.charAt(index) === '-'));\n\n            el.endChar = index;\n\n            if (!durationSetByPreviousNote && canHaveBrokenRhythm && (line.charAt(index) === '<' || line.charAt(index) === '>')) {\n              // TODO-PER: Don't need the test for < and >, but that makes the endChar work out for the regression test.\n              index--;\n              state = 'broken_rhythm';\n            } else return el;\n          } else return null;\n\n          break;\n\n        case '>':\n        case '<':\n          if (isComplete(state)) {\n            if (canHaveBrokenRhythm) {\n              var br2 = getBrokenRhythm(line, index);\n              index += br2[0] - 1; // index gets incremented below, so we'll let that happen\n\n              multilineVars.next_note_duration = br2[2];\n              el.duration = br2[1] * el.duration;\n              state = 'end_slur';\n            } else {\n              el.endChar = index;\n              return el;\n            }\n          } else return null;\n\n          break;\n\n        default:\n          if (isComplete(state)) {\n            el.endChar = index;\n            return el;\n          }\n\n          return null;\n      }\n\n      index++;\n\n      if (index === line.length) {\n        if (isComplete(state)) {\n          el.endChar = index;\n          return el;\n        } else return null;\n      }\n    }\n\n    return null;\n  };\n\n  function startNewLine() {\n    var params = {\n      startChar: -1,\n      endChar: -1\n    };\n    if (multilineVars.partForNextLine.title) params.part = multilineVars.partForNextLine;\n    params.clef = multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].clef !== undefined ? parseCommon.clone(multilineVars.staves[multilineVars.currentVoice.staffNum].clef) : parseCommon.clone(multilineVars.clef);\n    var scoreTranspose = multilineVars.currentVoice ? multilineVars.currentVoice.scoreTranspose : 0;\n    params.key = parseKeyVoice.standardKey(multilineVars.key.root + multilineVars.key.acc + multilineVars.key.mode, multilineVars.key.root, multilineVars.key.acc, scoreTranspose);\n    params.key.mode = multilineVars.key.mode;\n    if (multilineVars.key.impliedNaturals) params.key.impliedNaturals = multilineVars.key.impliedNaturals;\n\n    if (multilineVars.key.explicitAccidentals) {\n      for (var i = 0; i < multilineVars.key.explicitAccidentals.length; i++) {\n        var found = false;\n\n        for (var j = 0; j < params.key.accidentals.length; j++) {\n          if (params.key.accidentals[j].note === multilineVars.key.explicitAccidentals[i].note) {\n            // If the note is already in the list, override it with the new value\n            params.key.accidentals[j].acc = multilineVars.key.explicitAccidentals[i].acc;\n            found = true;\n          }\n        }\n\n        if (!found) params.key.accidentals.push(multilineVars.key.explicitAccidentals[i]);\n      }\n    }\n\n    multilineVars.targetKey = params.key;\n    if (params.key.explicitAccidentals) delete params.key.explicitAccidentals;\n    parseKeyVoice.addPosToKey(params.clef, params.key);\n\n    if (multilineVars.meter !== null) {\n      if (multilineVars.currentVoice) {\n        parseCommon.each(multilineVars.staves, function (st) {\n          st.meter = multilineVars.meter;\n        });\n        params.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;\n        multilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;\n      } else params.meter = multilineVars.meter;\n\n      multilineVars.meter = null;\n    } else if (multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].meter) {\n      // Make sure that each voice gets the meter marking.\n      params.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;\n      multilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;\n    }\n\n    if (multilineVars.currentVoice && multilineVars.currentVoice.name) params.name = multilineVars.currentVoice.name;\n    if (multilineVars.vocalfont) params.vocalfont = multilineVars.vocalfont;\n    if (multilineVars.tripletfont) params.tripletfont = multilineVars.tripletfont;\n    if (multilineVars.style) params.style = multilineVars.style;\n\n    if (multilineVars.currentVoice) {\n      var staff = multilineVars.staves[multilineVars.currentVoice.staffNum];\n      if (staff.brace) params.brace = staff.brace;\n      if (staff.bracket) params.bracket = staff.bracket;\n      if (staff.connectBarLines) params.connectBarLines = staff.connectBarLines;\n      if (staff.name) params.name = staff.name[multilineVars.currentVoice.index];\n      if (staff.subname) params.subname = staff.subname[multilineVars.currentVoice.index];\n      if (multilineVars.currentVoice.stem) params.stem = multilineVars.currentVoice.stem;\n      if (multilineVars.currentVoice.stafflines) params.stafflines = multilineVars.currentVoice.stafflines;\n      if (multilineVars.currentVoice.staffscale) params.staffscale = multilineVars.currentVoice.staffscale;\n      if (multilineVars.currentVoice.scale) params.scale = multilineVars.currentVoice.scale;\n      if (multilineVars.currentVoice.style) params.style = multilineVars.currentVoice.style;\n      if (multilineVars.currentVoice.transpose) params.clef.transpose = multilineVars.currentVoice.transpose;\n    }\n\n    var isFirstVoice = multilineVars.currentVoice === undefined || multilineVars.currentVoice.staffNum === 0 && multilineVars.currentVoice.index === 0;\n    if (multilineVars.barNumbers === 0 && isFirstVoice && multilineVars.currBarNumber !== 1) params.barNumber = multilineVars.currBarNumber;\n    tune.startNewLine(params);\n    if (multilineVars.key.impliedNaturals) delete multilineVars.key.impliedNaturals;\n    multilineVars.partForNextLine = {};\n  }\n\n  var letter_to_grace = function (line, i) {\n    // Grace notes are an array of: startslur, note, endslur, space; where note is accidental, pitch, duration\n    if (line.charAt(i) === '{') {\n      // fetch the gracenotes string and consume that into the array\n      var gra = tokenizer.getBrackettedSubstring(line, i, 1, '}');\n      if (!gra[2]) warn(\"Missing the closing '}' while parsing grace note\", line, i); // If there is a slur after the grace construction, then move it to the last note inside the grace construction\n\n      if (line[i + gra[0]] === ')') {\n        gra[0]++;\n        gra[1] += ')';\n      }\n\n      var gracenotes = [];\n      var ii = 0;\n      var inTie = false;\n\n      while (ii < gra[1].length) {\n        var acciaccatura = false;\n\n        if (gra[1].charAt(ii) === '/') {\n          acciaccatura = true;\n          ii++;\n        }\n\n        var note = getCoreNote(gra[1], ii, {}, false);\n\n        if (note !== null) {\n          // The grace note durations should not be affected by the default length: they should be based on 1/16, so if that isn't the default, then multiply here.\n          note.duration = note.duration / (multilineVars.default_length * 8);\n          if (acciaccatura) note.acciaccatura = true;\n          gracenotes.push(note);\n\n          if (inTie) {\n            note.endTie = true;\n            inTie = false;\n          }\n\n          if (note.startTie) inTie = true;\n          ii = note.endChar;\n          delete note.endChar;\n        } else {\n          // We shouldn't get anything but notes or a space here, so report an error\n          if (gra[1].charAt(ii) === ' ') {\n            if (gracenotes.length > 0) gracenotes[gracenotes.length - 1].end_beam = true;\n          } else warn(\"Unknown character '\" + gra[1].charAt(ii) + \"' while parsing grace note\", line, i);\n\n          ii++;\n        }\n      }\n\n      if (gracenotes.length) return [gra[0], gracenotes];\n    }\n\n    return [0];\n  };\n\n  function letter_to_overlay(line, i) {\n    if (line.charAt(i) === '&') {\n      var start = i;\n\n      while (line.charAt(i) && line.charAt(i) !== ':' && line.charAt(i) !== '|') i++;\n\n      return [i - start, line.substring(start + 1, i)];\n    }\n\n    return [0];\n  }\n\n  function durationOfMeasure(multilineVars) {\n    // TODO-PER: This could be more complicated if one of the unusual measures is used.\n    var meter = multilineVars.origMeter;\n    if (!meter || meter.type !== 'specified') return 1;\n    if (!meter.value || meter.value.length === 0) return 1;\n    return parseInt(meter.value[0].num, 10) / parseInt(meter.value[0].den, 10);\n  } //\n  // Parse line of music\n  //\n  // This is a stream of <(bar-marking|header|note-group)...> in any order, with optional spaces between each element\n  // core-note is <open-slur, accidental, pitch:required, octave, duration, close-slur&|tie> with no spaces within that\n  // chord is <open-bracket:required, core-note:required... close-bracket:required duration> with no spaces within that\n  // grace-notes is <open-brace:required, (open-slur|core-note:required|close-slur)..., close-brace:required> spaces are allowed\n  // note-group is <grace-notes, chord symbols&|decorations..., grace-notes, slur&|triplet, chord|core-note, end-slur|tie> spaces are allowed between items\n  // bar-marking is <ampersand> or <chord symbols&|decorations..., bar:required> spaces allowed\n  // header is <open-bracket:required, K|M|L|V:required, colon:required, field:required, close-bracket:required> spaces can occur between the colon, in the field, and before the close bracket\n  // header can also be the only thing on a line. This is true even if it is a continuation line. In this case the brackets are not required.\n  // a space is a back-tick, a space, or a tab. If it is a back-tick, then there is no end-beam.\n  // Line preprocessing: anything after a % is ignored (the double %% should have been taken care of before this)\n  // Then, all leading and trailing spaces are ignored.\n  // If there was a line continuation, the \\n was replaced by a \\r and the \\ was replaced by a space. This allows the construct\n  // of having a header mid-line conceptually, but actually be at the start of the line. This is equivolent to putting the header in [ ].\n  // TODO-PER: How to handle ! for line break?\n  // TODO-PER: dots before bar, dots before slur\n  // TODO-PER: U: redefinable symbols.\n  // Ambiguous symbols:\n  // \"[\" can be the start of a chord, the start of a header element or part of a bar line.\n  // --- if it is immediately followed by \"|\", it is a bar line\n  // --- if it is immediately followed by K: L: M: V: it is a header (note: there are other headers mentioned in the standard, but I'm not sure how they would be used.)\n  // --- otherwise it is the beginning of a chord\n  // \"(\" can be the start of a slur or a triplet\n  // --- if it is followed by a number from 2-9, then it is a triplet\n  // --- otherwise it is a slur\n  // \"]\"\n  // --- if there is a chord open, then this is the close\n  // --- if it is after a [|, then it is an invisible bar line\n  // --- otherwise, it is par of a bar\n  // \".\" can be a bar modifier or a slur modifier, or a decoration\n  // --- if it comes immediately before a bar, it is a bar modifier\n  // --- if it comes immediately before a slur, it is a slur modifier\n  // --- otherwise it is a decoration for the next note.\n  // number:\n  // --- if it is after a bar, with no space, it is an ending marker\n  // --- if it is after a ( with no space, it is a triplet count\n  // --- if it is after a pitch or octave or slash, then it is a duration\n  // Unambiguous symbols (except inside quoted strings):\n  // vertical-bar, colon: part of a bar\n  // ABCDEFGabcdefg: pitch\n  // xyzZ: rest\n  // comma, prime: octave\n  // close-paren: end-slur\n  // hyphen: tie\n  // tilde, v, u, bang, plus, THLMPSO: decoration\n  // carat, underscore, equal: accidental\n  // ampersand: time reset\n  // open-curly, close-curly: grace notes\n  // double-quote: chord symbol\n  // less-than, greater-than, slash: duration\n  // back-tick, space, tab: space\n\n\n  var nonDecorations = \"ABCDEFGabcdefgxyzZ[]|^_{\"; // use this to prescreen so we don't have to look for a decoration at every note.\n\n  var parseRegularMusicLine = function (line) {\n    header.resolveTempo(); //multilineVars.havent_set_length = false;\t// To late to set this now.\n\n    multilineVars.is_in_header = false; // We should have gotten a key header by now, but just in case, this is definitely out of the header.\n\n    var i = 0;\n    var startOfLine = multilineVars.iChar; // see if there is nothing but a comment on this line. If so, just ignore it. A full line comment is optional white space followed by %\n\n    while (tokenizer.isWhiteSpace(line.charAt(i)) && i < line.length) i++;\n\n    if (i === line.length || line.charAt(i) === '%') return; // Start with the standard staff, clef and key symbols on each line\n\n    var delayStartNewLine = multilineVars.start_new_line;\n    if (multilineVars.continueall === undefined) multilineVars.start_new_line = true;else multilineVars.start_new_line = false;\n    var tripletNotesLeft = 0; // See if the line starts with a header field\n\n    var retHeader = header.letter_to_body_header(line, i);\n\n    if (retHeader[0] > 0) {\n      i += retHeader[0];\n      if (retHeader[1] === 'V') delayStartNewLine = true; // fixes bug on this: c[V:2]d\n      // TODO-PER: Handle inline headers\n    }\n\n    var el = {};\n    var overlayLevel = 0;\n\n    while (i < line.length) {\n      var startI = i;\n      if (line.charAt(i) === '%') break;\n      var retInlineHeader = header.letter_to_inline_header(line, i);\n\n      if (retInlineHeader[0] > 0) {\n        i += retInlineHeader[0];\n        if (retInlineHeader[1] === 'V') delayStartNewLine = true; // fixes bug on this: c[V:2]d\n        // TODO-PER: Handle inline headers\n        //multilineVars.start_new_line = false;\n      } else {\n        // Wait until here to actually start the line because we know we're past the inline statements.\n        if (delayStartNewLine) {\n          startNewLine();\n          delayStartNewLine = false;\n        } // We need to decide if the following characters are a bar-marking or a note-group.\n        // Unfortunately, that is ambiguous. Both can contain chord symbols and decorations.\n        // If there is a grace note either before or after the chord symbols and decorations, then it is definitely a note-group.\n        // If there is a bar marker, it is definitely a bar-marking.\n        // If there is either a core-note or chord, it is definitely a note-group.\n        // So, loop while we find grace-notes, chords-symbols, or decorations. [It is an error to have more than one grace-note group in a row; the others can be multiple]\n        // Then, if there is a grace-note, we know where to go.\n        // Else see if we have a chord, core-note, slur, triplet, or bar.\n\n\n        var ret;\n\n        while (1) {\n          ret = tokenizer.eatWhiteSpace(line, i);\n\n          if (ret > 0) {\n            i += ret;\n          }\n\n          if (i > 0 && line.charAt(i - 1) === '\\x12') {\n            // there is one case where a line continuation isn't the same as being on the same line, and that is if the next character after it is a header.\n            ret = header.letter_to_body_header(line, i);\n\n            if (ret[0] > 0) {\n              if (ret[1] === 'V') startNewLine(); // fixes bug on this: c\\\\nV:2]\\\\nd\n              // TODO: insert header here\n\n              i = ret[0];\n              multilineVars.start_new_line = false;\n            }\n          } // gather all the grace notes, chord symbols and decorations\n\n\n          ret = letter_to_spacer(line, i);\n\n          if (ret[0] > 0) {\n            i += ret[0];\n          }\n\n          ret = letter_to_chord(line, i);\n\n          if (ret[0] > 0) {\n            // There could be more than one chord here if they have different positions.\n            // If two chords have the same position, then connect them with newline.\n            if (!el.chord) el.chord = [];\n            var chordName = tokenizer.translateString(ret[1]);\n            chordName = chordName.replace(/;/g, \"\\n\");\n            var addedChord = false;\n\n            for (var ci = 0; ci < el.chord.length; ci++) {\n              if (el.chord[ci].position === ret[2]) {\n                addedChord = true;\n                el.chord[ci].name += \"\\n\" + chordName;\n              }\n            }\n\n            if (addedChord === false) {\n              if (ret[2] === null && ret[3]) el.chord.push({\n                name: chordName,\n                rel_position: ret[3]\n              });else el.chord.push({\n                name: chordName,\n                position: ret[2]\n              });\n            }\n\n            i += ret[0];\n            var ii = tokenizer.skipWhiteSpace(line.substring(i));\n            if (ii > 0) el.force_end_beam_last = true;\n            i += ii;\n          } else {\n            if (nonDecorations.indexOf(line.charAt(i)) === -1) ret = letter_to_accent(line, i);else ret = [0];\n\n            if (ret[0] > 0) {\n              if (ret[1] === null) {\n                if (i + 1 < line.length) startNewLine(); // There was a ! in the middle of the line. Start a new line if there is anything after it.\n              } else if (ret[1].length > 0) {\n                if (ret[1].indexOf(\"style=\") === 0) {\n                  el.style = ret[1].substr(6);\n                } else {\n                  if (el.decoration === undefined) el.decoration = [];\n                  el.decoration.push(ret[1]);\n                }\n              }\n\n              i += ret[0];\n            } else {\n              ret = letter_to_grace(line, i); // TODO-PER: Be sure there aren't already grace notes defined. That is an error.\n\n              if (ret[0] > 0) {\n                el.gracenotes = ret[1];\n                i += ret[0];\n              } else break;\n            }\n          }\n        }\n\n        ret = letter_to_bar(line, i);\n\n        if (ret[0] > 0) {\n          // This is definitely a bar\n          overlayLevel = 0;\n\n          if (el.gracenotes !== undefined) {\n            // Attach the grace note to an invisible note\n            el.rest = {\n              type: 'spacer'\n            };\n            el.duration = 0.125; // TODO-PER: I don't think the duration of this matters much, but figure out if it does.\n\n            multilineVars.addFormattingOptions(el, tune.formatting, 'note');\n            tune.appendElement('note', startOfLine + i, startOfLine + i + ret[0], el);\n            multilineVars.measureNotEmpty = true;\n            el = {};\n          }\n\n          var bar = {\n            type: ret[1]\n          };\n          if (bar.type.length === 0) warn(\"Unknown bar type\", line, i);else {\n            if (multilineVars.inEnding && bar.type !== 'bar_thin') {\n              bar.endEnding = true;\n              multilineVars.inEnding = false;\n            }\n\n            if (ret[2]) {\n              bar.startEnding = ret[2];\n              if (multilineVars.inEnding) bar.endEnding = true;\n              multilineVars.inEnding = true;\n            }\n\n            if (el.decoration !== undefined) bar.decoration = el.decoration;\n            if (el.chord !== undefined) bar.chord = el.chord;\n            if (bar.startEnding && multilineVars.barFirstEndingNum === undefined) multilineVars.barFirstEndingNum = multilineVars.currBarNumber;else if (bar.startEnding && bar.endEnding && multilineVars.barFirstEndingNum) multilineVars.currBarNumber = multilineVars.barFirstEndingNum;else if (bar.endEnding) multilineVars.barFirstEndingNum = undefined;\n\n            if (bar.type !== 'bar_invisible' && multilineVars.measureNotEmpty) {\n              var isFirstVoice = multilineVars.currentVoice === undefined || multilineVars.currentVoice.staffNum === 0 && multilineVars.currentVoice.index === 0;\n\n              if (isFirstVoice) {\n                multilineVars.currBarNumber++;\n                if (multilineVars.barNumbers && multilineVars.currBarNumber % multilineVars.barNumbers === 0) bar.barNumber = multilineVars.currBarNumber;\n              }\n            }\n\n            multilineVars.addFormattingOptions(el, tune.formatting, 'bar');\n            tune.appendElement('bar', startOfLine + i, startOfLine + i + ret[0], bar);\n            multilineVars.measureNotEmpty = false;\n            el = {};\n          }\n          i += ret[0];\n          var cv = multilineVars.currentVoice ? multilineVars.currentVoice.staffNum + '-' + multilineVars.currentVoice.index : 'ONLY'; // if (multilineVars.lineBreaks) {\n          // \tif (!multilineVars.barCounter[cv])\n          // \t\tmultilineVars.barCounter[cv] = 0;\n          // \tvar breakNow = multilineVars.lineBreaks[''+multilineVars.barCounter[cv]];\n          // \tmultilineVars.barCounter[cv]++;\n          // \tif (breakNow)\n          // \t\tstartNewLine();\n          // }\n        } else if (line[i] === '&') {\n          // backtrack to beginning of measure\n          ret = letter_to_overlay(line, i);\n\n          if (ret[0] > 0) {\n            tune.appendElement('overlay', startOfLine, startOfLine + 1, {});\n            i += 1;\n            overlayLevel++;\n          }\n        } else {\n          // This is definitely a note group\n          //\n          // Look for as many open slurs and triplets as there are. (Note: only the first triplet is valid.)\n          ret = letter_to_open_slurs_and_triplets(line, i);\n\n          if (ret.consumed > 0) {\n            if (ret.startSlur !== undefined) el.startSlur = ret.startSlur;\n\n            if (ret.triplet !== undefined) {\n              if (tripletNotesLeft > 0) warn(\"Can't nest triplets\", line, i);else {\n                el.startTriplet = ret.triplet;\n                el.tripletMultiplier = ret.tripletQ / ret.triplet;\n                tripletNotesLeft = ret.num_notes === undefined ? ret.triplet : ret.num_notes;\n              }\n            }\n\n            i += ret.consumed;\n          } // handle chords.\n\n\n          if (line.charAt(i) === '[') {\n            var chordStartChar = i;\n            i++;\n            var chordDuration = null;\n            var rememberEndBeam = false;\n            var done = false;\n\n            while (!done) {\n              var accent = letter_to_accent(line, i);\n\n              if (accent[0] > 0) {\n                i += accent[0];\n              }\n\n              var chordNote = getCoreNote(line, i, {}, false);\n\n              if (chordNote !== null) {\n                if (accent[0] > 0) {\n                  // If we found a decoration above, it modifies the entire chord. \"style\" is handled below.\n                  if (accent[1].indexOf(\"style=\") !== 0) {\n                    if (el.decoration === undefined) el.decoration = [];\n                    el.decoration.push(accent[1]);\n                  }\n                }\n\n                if (chordNote.end_beam) {\n                  el.end_beam = true;\n                  delete chordNote.end_beam;\n                }\n\n                if (el.pitches === undefined) {\n                  el.duration = chordNote.duration;\n                  el.pitches = [chordNote];\n                } else // Just ignore the note lengths of all but the first note. The standard isn't clear here, but this seems less confusing.\n                  el.pitches.push(chordNote);\n\n                delete chordNote.duration;\n\n                if (accent[0] > 0) {\n                  // If we found a style above, it modifies the individual pitch, not the entire chord.\n                  if (accent[1].indexOf(\"style=\") === 0) {\n                    el.pitches[el.pitches.length - 1].style = accent[1].substr(6);\n                  }\n                }\n\n                if (multilineVars.inTieChord[el.pitches.length]) {\n                  chordNote.endTie = true;\n                  multilineVars.inTieChord[el.pitches.length] = undefined;\n                }\n\n                if (chordNote.startTie) multilineVars.inTieChord[el.pitches.length] = true;\n                i = chordNote.endChar;\n                delete chordNote.endChar;\n              } else if (line.charAt(i) === ' ') {\n                // Spaces are not allowed in chords, but we can recover from it by ignoring it.\n                warn(\"Spaces are not allowed in chords\", line, i);\n                i++;\n              } else {\n                if (i < line.length && line.charAt(i) === ']') {\n                  // consume the close bracket\n                  i++;\n\n                  if (multilineVars.next_note_duration !== 0) {\n                    el.duration = el.duration * multilineVars.next_note_duration;\n                    multilineVars.next_note_duration = 0;\n                  }\n\n                  if (isInTie(multilineVars, overlayLevel, el)) {\n                    parseCommon.each(el.pitches, function (pitch) {\n                      pitch.endTie = true;\n                    });\n                    setIsInTie(multilineVars, overlayLevel, false);\n                  }\n\n                  if (tripletNotesLeft > 0) {\n                    tripletNotesLeft--;\n\n                    if (tripletNotesLeft === 0) {\n                      el.endTriplet = true;\n                    }\n                  }\n\n                  var postChordDone = false;\n\n                  while (i < line.length && !postChordDone) {\n                    switch (line.charAt(i)) {\n                      case ' ':\n                      case '\\t':\n                        addEndBeam(el);\n                        break;\n\n                      case ')':\n                        if (el.endSlur === undefined) el.endSlur = 1;else el.endSlur++;\n                        break;\n\n                      case '-':\n                        parseCommon.each(el.pitches, function (pitch) {\n                          pitch.startTie = {};\n                        });\n                        setIsInTie(multilineVars, overlayLevel, true);\n                        break;\n\n                      case '>':\n                      case '<':\n                        var br2 = getBrokenRhythm(line, i);\n                        i += br2[0] - 1; // index gets incremented below, so we'll let that happen\n\n                        multilineVars.next_note_duration = br2[2];\n                        if (chordDuration) chordDuration = chordDuration * br2[1];else chordDuration = br2[1];\n                        break;\n\n                      case '1':\n                      case '2':\n                      case '3':\n                      case '4':\n                      case '5':\n                      case '6':\n                      case '7':\n                      case '8':\n                      case '9':\n                      case '/':\n                        var fraction = tokenizer.getFraction(line, i);\n                        chordDuration = fraction.value;\n                        i = fraction.index;\n                        if (line.charAt(i) === ' ') rememberEndBeam = true;\n                        if (line.charAt(i) === '-' || line.charAt(i) === ')' || line.charAt(i) === ' ' || line.charAt(i) === '<' || line.charAt(i) === '>') i--; // Subtracting one because one is automatically added below\n                        else postChordDone = true;\n                        break;\n\n                      default:\n                        postChordDone = true;\n                        break;\n                    }\n\n                    if (!postChordDone) {\n                      i++;\n                    }\n                  }\n                } else warn(\"Expected ']' to end the chords\", line, i);\n\n                if (el.pitches !== undefined) {\n                  if (chordDuration !== null) {\n                    el.duration = el.duration * chordDuration;\n                    if (rememberEndBeam) addEndBeam(el);\n                  }\n\n                  multilineVars.addFormattingOptions(el, tune.formatting, 'note');\n                  tune.appendElement('note', startOfLine + chordStartChar, startOfLine + i, el);\n                  multilineVars.measureNotEmpty = true;\n                  el = {};\n                }\n\n                done = true;\n              }\n            }\n          } else {\n            // Single pitch\n            var el2 = {};\n            var core = getCoreNote(line, i, el2, true);\n            if (el2.endTie !== undefined) setIsInTie(multilineVars, overlayLevel, true);\n\n            if (core !== null) {\n              if (core.pitch !== undefined) {\n                el.pitches = [{}]; // TODO-PER: straighten this out so there is not so much copying: getCoreNote shouldn't change e'\n\n                if (core.accidental !== undefined) el.pitches[0].accidental = core.accidental;\n                el.pitches[0].pitch = core.pitch;\n                if (core.midipitch) el.pitches[0].midipitch = core.midipitch;\n                if (core.endSlur !== undefined) el.pitches[0].endSlur = core.endSlur;\n                if (core.endTie !== undefined) el.pitches[0].endTie = core.endTie;\n                if (core.startSlur !== undefined) el.pitches[0].startSlur = core.startSlur;\n                if (el.startSlur !== undefined) el.pitches[0].startSlur = el.startSlur;\n                if (core.startTie !== undefined) el.pitches[0].startTie = core.startTie;\n                if (el.startTie !== undefined) el.pitches[0].startTie = el.startTie;\n              } else {\n                el.rest = core.rest;\n                if (core.endSlur !== undefined) el.endSlur = core.endSlur;\n                if (core.endTie !== undefined) el.rest.endTie = core.endTie;\n                if (core.startSlur !== undefined) el.startSlur = core.startSlur;\n                if (core.startTie !== undefined) el.rest.startTie = core.startTie;\n                if (el.startTie !== undefined) el.rest.startTie = el.startTie;\n              }\n\n              if (core.chord !== undefined) el.chord = core.chord;\n              if (core.duration !== undefined) el.duration = core.duration;\n              if (core.decoration !== undefined) el.decoration = core.decoration;\n              if (core.graceNotes !== undefined) el.graceNotes = core.graceNotes;\n              delete el.startSlur;\n\n              if (isInTie(multilineVars, overlayLevel, el)) {\n                if (el.pitches !== undefined) {\n                  el.pitches[0].endTie = true;\n                } else if (el.rest.type !== 'spacer') {\n                  el.rest.endTie = true;\n                }\n\n                setIsInTie(multilineVars, overlayLevel, false);\n              }\n\n              if (core.startTie || el.startTie) setIsInTie(multilineVars, overlayLevel, true);\n              i = core.endChar;\n\n              if (tripletNotesLeft > 0) {\n                tripletNotesLeft--;\n\n                if (tripletNotesLeft === 0) {\n                  el.endTriplet = true;\n                }\n              }\n\n              if (core.end_beam) addEndBeam(el); // If there is a whole rest, then it should be the duration of the measure, not it's own duration. We need to special case it.\n              // If the time signature length is greater than 4/4, though, then a whole rest has no special treatment.\n\n              if (el.rest && el.rest.type === 'rest' && el.duration === 1 && durationOfMeasure(multilineVars) <= 1) {\n                el.rest.type = 'whole';\n                el.duration = durationOfMeasure(multilineVars);\n              }\n\n              multilineVars.addFormattingOptions(el, tune.formatting, 'note');\n              tune.appendElement('note', startOfLine + startI, startOfLine + i, el);\n              multilineVars.measureNotEmpty = true;\n              el = {};\n            }\n          }\n\n          if (i === startI) {\n            // don't know what this is, so ignore it.\n            if (line.charAt(i) !== ' ' && line.charAt(i) !== '`') warn(\"Unknown character ignored\", line, i);\n            i++;\n          }\n        }\n      }\n    }\n  };\n\n  var isInTie = function (multilineVars, overlayLevel, el) {\n    if (multilineVars.inTie[overlayLevel] === undefined) return false; // If this is single voice music then the voice index isn't set, so we use the first voice.\n\n    var voiceIndex = multilineVars.currentVoice ? multilineVars.currentVoice.index : 0;\n\n    if (multilineVars.inTie[overlayLevel][voiceIndex]) {\n      if (el.pitches !== undefined || el.rest.type !== 'spacer') return true;\n    }\n\n    return false;\n  };\n\n  var setIsInTie = function (multilineVars, overlayLevel, value) {\n    // If this is single voice music then the voice index isn't set, so we use the first voice.\n    var voiceIndex = multilineVars.currentVoice ? multilineVars.currentVoice.index : 0;\n    if (multilineVars.inTie[overlayLevel] === undefined) multilineVars.inTie[overlayLevel] = [];\n    multilineVars.inTie[overlayLevel][voiceIndex] = value;\n  };\n\n  var parseLine = function (line) {\n    var ret = header.parseHeader(line);\n    if (ret.regular) parseRegularMusicLine(ret.str);\n    if (ret.newline) startNewLine();\n    if (ret.words) addWords(tune.getCurrentVoice(), line.substring(2));\n    if (ret.symbols) addSymbols(tune.getCurrentVoice(), line.substring(2));\n    if (ret.recurse) parseLine(ret.str);\n  };\n\n  function appendLastMeasure(voice, nextVoice) {\n    voice.push({\n      el_type: 'hint'\n    });\n\n    for (var i = 0; i < nextVoice.length; i++) {\n      var element = nextVoice[i];\n      var hint = parseCommon.clone(element);\n      voice.push(hint);\n      if (element.el_type === 'bar') return;\n    }\n  }\n\n  function addHintMeasure(staff, nextStaff) {\n    for (var i = 0; i < staff.length; i++) {\n      var stave = staff[i];\n      var nextStave = nextStaff[i];\n\n      if (nextStave) {\n        // Be sure there is the same number of staves on the next line.\n        for (var j = 0; j < nextStave.voices.length; j++) {\n          var nextVoice = nextStave.voices[j];\n          var voice = stave.voices[j];\n\n          if (voice) {\n            // Be sure there are the same number of voices on the previous line.\n            appendLastMeasure(voice, nextVoice);\n          }\n        }\n      }\n    }\n  }\n\n  function addHintMeasures() {\n    for (var i = 0; i < tune.lines.length; i++) {\n      var line = tune.lines[i].staff;\n\n      if (line) {\n        var j = i + 1;\n\n        while (j < tune.lines.length && tune.lines[j].staff === undefined) j++;\n\n        if (j < tune.lines.length) {\n          var nextLine = tune.lines[j].staff;\n          addHintMeasure(line, nextLine);\n        }\n      }\n    }\n  }\n\n  this.parse = function (strTune, switches, startPos) {\n    // the switches are optional and cause a difference in the way the tune is parsed.\n    // switches.header_only : stop parsing when the header is finished\n    // switches.stop_on_warning : stop at the first warning encountered.\n    // switches.print: format for the page instead of the browser.\n    // switches.format: a hash of the desired formatting commands.\n    // switches.hint_measures: put the next measure at the end of the current line.\n    // switches.transpose: change the key signature, chords, and notes by a number of half-steps.\n    if (!switches) switches = {};\n    if (!startPos) startPos = 0;\n    tune.reset();\n    if (switches.print) tune.media = 'print';\n    multilineVars.reset();\n    multilineVars.iChar = startPos;\n\n    if (switches.visualTranspose) {\n      multilineVars.globalTranspose = parseInt(switches.visualTranspose);\n      if (multilineVars.globalTranspose === 0) multilineVars.globalTranspose = undefined;\n    } else multilineVars.globalTranspose = undefined;\n\n    if (switches.lineBreaks) {\n      // change the format of the the line breaks for easy testing.\n      // The line break numbers are 0-based and they reflect the last measure of the current line.\n      multilineVars.lineBreaks = {}; //multilineVars.continueall = true;\n\n      for (var i = 0; i < switches.lineBreaks.length; i++) multilineVars.lineBreaks['' + (switches.lineBreaks[i] + 1)] = true; // Add 1 so that the line break is the first measure of the next line.\n\n    }\n\n    header.reset(tokenizer, warn, multilineVars, tune); // Take care of whatever line endings come our way\n\n    strTune = parseCommon.gsub(strTune, '\\r\\n', '\\n');\n    strTune = parseCommon.gsub(strTune, '\\r', '\\n');\n    strTune += '\\n'; // Tacked on temporarily to make the last line continuation work\n\n    strTune = strTune.replace(/\\n\\\\.*\\n/g, \"\\n\"); // get rid of latex commands.\n\n    var continuationReplacement = function (all, backslash, comment) {\n      var spaces = \"                                                                                                                                                                                                     \";\n      var padding = comment ? spaces.substring(0, comment.length) : \"\";\n      return backslash + \" \\x12\" + padding;\n    };\n\n    strTune = strTune.replace(/\\\\([ \\t]*)(%.*)*\\n/g, continuationReplacement); // take care of line continuations right away, but keep the same number of characters\n\n    var lines = strTune.split('\\n');\n    if (parseCommon.last(lines).length === 0) // remove the blank line we added above.\n      lines.pop();\n\n    try {\n      if (switches.format) {\n        parseDirective.globalFormatting(switches.format);\n      }\n\n      parseCommon.each(lines, function (line) {\n        if (switches.header_only && multilineVars.is_in_header === false) throw \"normal_abort\";\n        if (switches.stop_on_warning && multilineVars.warnings) throw \"normal_abort\";\n\n        if (multilineVars.is_in_history) {\n          if (line.charAt(1) === ':') {\n            multilineVars.is_in_history = false;\n            parseLine(line);\n          } else tune.addMetaText(\"history\", tokenizer.translateString(tokenizer.stripComment(line)));\n        } else if (multilineVars.inTextBlock) {\n          if (parseCommon.startsWith(line, \"%%endtext\")) {\n            //tune.addMetaText(\"textBlock\", multilineVars.textBlock);\n            tune.addText(multilineVars.textBlock);\n            multilineVars.inTextBlock = false;\n          } else {\n            if (parseCommon.startsWith(line, \"%%\")) multilineVars.textBlock += ' ' + line.substring(2);else multilineVars.textBlock += ' ' + line;\n          }\n        } else if (multilineVars.inPsBlock) {\n          if (parseCommon.startsWith(line, \"%%endps\")) {\n            // Just ignore postscript\n            multilineVars.inPsBlock = false;\n          } else multilineVars.textBlock += ' ' + line;\n        } else parseLine(line);\n\n        multilineVars.iChar += line.length + 1;\n      });\n      var ph = 11 * 72;\n      var pl = 8.5 * 72;\n\n      switch (multilineVars.papersize) {\n        //case \"letter\": ph = 11*72; pl = 8.5*72; break;\n        case \"legal\":\n          ph = 14 * 72;\n          pl = 8.5 * 72;\n          break;\n\n        case \"A4\":\n          ph = 11.7 * 72;\n          pl = 8.3 * 72;\n          break;\n      }\n\n      if (multilineVars.landscape) {\n        var x = ph;\n        ph = pl;\n        pl = x;\n      }\n\n      multilineVars.openSlurs = tune.cleanUp(pl, ph, multilineVars.barsperstaff, multilineVars.staffnonote, multilineVars.openSlurs);\n    } catch (err) {\n      if (err !== \"normal_abort\") throw err;\n    }\n\n    if (switches.hint_measures) {\n      addHintMeasures();\n    }\n\n    wrap.wrapLines(tune, multilineVars.lineBreaks);\n  };\n};\n\nmodule.exports = Parse;","map":{"version":3,"sources":["/home/elad/Desktop/Repos/drums-trainer/frontend/node_modules/react-sheet-music/node_modules/abcjs/src/parse/abc_parse.js"],"names":["parseCommon","require","parseDirective","ParseHeader","parseKeyVoice","Tokenizer","transpose","wrap","Tune","Parse","tune","tokenizer","getTune","formatting","lines","media","metaText","version","addElementToEvents","addUsefulCallbackInfo","getBarLength","getBeatLength","getBeatsPerMeasure","getBpm","getMeter","getMeterFraction","getPickupLength","getKeySignature","makeVoicesArray","millisecondsPerMeasure","setupEvents","setTiming","addPositioning","el","type","value","positioning","addFont","fonts","multilineVars","reset","property","hasOwnProperty","iChar","key","accidentals","root","acc","mode","meter","origMeter","hasMainTitle","default_length","clef","verticalPos","next_note_duration","start_new_line","is_in_header","is_in_history","partForNextLine","havent_set_length","voices","staves","macros","currBarNumber","barCounter","inTextBlock","inPsBlock","ignoredDecorations","textBlock","score_is_present","inEnding","inTie","inTieChord","vocalPosition","dynamicPosition","chordPosition","ornamentPosition","volumePosition","openSlurs","freegchord","differentFont","defaultFonts","decoration","face","size","style","weight","addFormattingOptions","elType","annotationfont","gchordfont","vocalfont","tripletfont","measurefont","repeatfont","addWarning","str","warnings","push","addWarningObject","warningObject","warningObjects","encode","ret","gsub","warn","line","col_num","bad_char","charAt","clean_line","substring","getNumLines","message","startChar","column","header","getWarnings","getWarningObjects","letter_to_chord","i","chord","getBrackettedSubstring","length","x","getFloat","digits","y","ws","skipWhiteSpace","replace","chordName","legalAccents","volumeDecorations","dynamicDecorations","accentPseudonyms","accentDynamicPseudonyms","letter_to_accent","macro","undefined","detect","dec","letter_to_spacer","start","isWhiteSpace","letter_to_bar","curr_pos","getBarLine","len","orig_bar_len","ending","token","retRep","getTokenOf","tripletQ","letter_to_open_slurs_and_triplets","triplet","num_notes","startSlur","consumed","addWords","words","strip","word_list","last_divider","addWord","word","div","syllable","translateString","divider","last","skip","to","inSlur","each","el_type","pitches","shift","lyric","rest","addSymbols","getBrokenRhythm","index","addEndBeam","duration","end_beam","A","B","C","D","E","F","G","a","b","c","d","e","f","g","rests","z","Z","getCoreNote","canHaveBrokenRhythm","isComplete","state","durationSetByPreviousNote","endChar","endSlur","accidental","pitch","note","currentVoice","accMap","midi","drummap","midipitch","startTie","endTie","grace_notes","fraction","getFraction","num","getNumber","addTieToLastNote","br2","startNewLine","params","title","part","staffNum","clone","scoreTranspose","standardKey","impliedNaturals","explicitAccidentals","found","j","targetKey","addPosToKey","st","name","staff","brace","bracket","connectBarLines","subname","stem","stafflines","staffscale","scale","isFirstVoice","barNumbers","barNumber","letter_to_grace","gra","gracenotes","ii","acciaccatura","letter_to_overlay","durationOfMeasure","parseInt","den","nonDecorations","parseRegularMusicLine","resolveTempo","startOfLine","delayStartNewLine","continueall","tripletNotesLeft","retHeader","letter_to_body_header","overlayLevel","startI","retInlineHeader","letter_to_inline_header","eatWhiteSpace","addedChord","ci","position","rel_position","force_end_beam_last","indexOf","substr","appendElement","measureNotEmpty","bar","endEnding","startEnding","barFirstEndingNum","cv","startTriplet","tripletMultiplier","chordStartChar","chordDuration","rememberEndBeam","done","accent","chordNote","isInTie","setIsInTie","endTriplet","postChordDone","el2","core","graceNotes","voiceIndex","parseLine","parseHeader","regular","newline","getCurrentVoice","symbols","recurse","appendLastMeasure","voice","nextVoice","element","hint","addHintMeasure","nextStaff","stave","nextStave","addHintMeasures","nextLine","parse","strTune","switches","startPos","print","visualTranspose","globalTranspose","lineBreaks","continuationReplacement","all","backslash","comment","spaces","padding","split","pop","format","globalFormatting","header_only","stop_on_warning","addMetaText","stripComment","startsWith","addText","ph","pl","papersize","landscape","cleanUp","barsperstaff","staffnonote","err","hint_measures","wrapLines","module","exports"],"mappings":"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","sourcesContent":["//    abc_parse.js: parses a string representing ABC Music Notation into a usable internal structure.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*global window */\n\nvar parseCommon = require('./abc_common');\nvar parseDirective = require('./abc_parse_directive');\nvar ParseHeader = require('./abc_parse_header');\nvar parseKeyVoice = require('./abc_parse_key_voice');\nvar Tokenizer = require('./abc_tokenizer');\nvar transpose = require('./abc_transpose');\nvar wrap = require('./wrap_lines');\n\nvar Tune = require('../data/abc_tune');\n\nvar Parse = function() {\n\t\"use strict\";\n\tvar tune = new Tune();\n\tvar tokenizer = new Tokenizer();\n\n\tthis.getTune = function() {\n\t\treturn {\n\t\t\tformatting: tune.formatting,\n\t\t\tlines: tune.lines,\n\t\t\tmedia: tune.media,\n\t\t\tmetaText: tune.metaText,\n\t\t\tversion: tune.version,\n\n\t\t\taddElementToEvents: tune.addElementToEvents,\n\t\t\taddUsefulCallbackInfo: tune.addUsefulCallbackInfo,\n\t\t\tgetBarLength: tune.getBarLength,\n\t\t\tgetBeatLength: tune.getBeatLength,\n\t\t\tgetBeatsPerMeasure: tune.getBeatsPerMeasure,\n\t\t\tgetBpm: tune.getBpm,\n\t\t\tgetMeter: tune.getMeter,\n\t\t\tgetMeterFraction: tune.getMeterFraction,\n\t\t\tgetPickupLength: tune.getPickupLength,\n\t\t\tgetKeySignature: tune.getKeySignature,\n\t\t\tmakeVoicesArray: tune.makeVoicesArray,\n\t\t\tmillisecondsPerMeasure: tune.millisecondsPerMeasure,\n\t\t\tsetupEvents: tune.setupEvents,\n\t\t\tsetTiming: tune.setTiming\n\t\t};\n\t};\n\n\tfunction addPositioning(el, type, value) {\n\t\tif (!el.positioning) el.positioning = {};\n\t\tel.positioning[type] = value;\n\t}\n\n\tfunction addFont(el, type, value) {\n\t\tif (!el.fonts) el.fonts = {};\n\t\tel.fonts[type] = value;\n\t}\n\n\tvar multilineVars = {\n\t\treset: function() {\n\t\t\tfor (var property in this) {\n\t\t\t\tif (this.hasOwnProperty(property) && typeof this[property] !== \"function\") {\n\t\t\t\t\tdelete this[property];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.iChar = 0;\n\t\t\tthis.key = {accidentals: [], root: 'none', acc: '', mode: '' };\n\t\t\tthis.meter = null; // if no meter is specified, free meter is assumed\n\t\t\tthis.origMeter = null;\t// this is for new voices that are created after we set the meter.\n\t\t\tthis.hasMainTitle = false;\n\t\t\tthis.default_length = 0.125;\n\t\t\tthis.clef = { type: 'treble', verticalPos: 0 };\n\t\t\tthis.next_note_duration = 0;\n\t\t\tthis.start_new_line = true;\n\t\t\tthis.is_in_header = true;\n\t\t\tthis.is_in_history = false;\n\t\t\tthis.partForNextLine = {};\n\t\t\tthis.havent_set_length = true;\n\t\t\tthis.voices = {};\n\t\t\tthis.staves = [];\n\t\t\tthis.macros = {};\n\t\t\tthis.currBarNumber = 1;\n\t\t\tthis.barCounter = {};\n\t\t\tthis.inTextBlock = false;\n\t\t\tthis.inPsBlock = false;\n\t\t\tthis.ignoredDecorations = [];\n\t\t\tthis.textBlock = \"\";\n\t\t\tthis.score_is_present = false;\t// Can't have original V: lines when there is the score directive\n\t\t\tthis.inEnding = false;\n\t\t\tthis.inTie = [];\n\t\t\tthis.inTieChord = {};\n\t\t\tthis.vocalPosition = \"auto\";\n\t\t\tthis.dynamicPosition = \"auto\";\n\t\t\tthis.chordPosition = \"auto\";\n\t\t\tthis.ornamentPosition = \"auto\";\n\t\t\tthis.volumePosition = \"auto\";\n\t\t\tthis.openSlurs = [];\n\t\t\tthis.freegchord = false;\n\t\t},\n\t\tdifferentFont: function(type, defaultFonts) {\n\t\t\tif (this[type].decoration !== defaultFonts[type].decoration) return true;\n\t\t\tif (this[type].face !== defaultFonts[type].face) return true;\n\t\t\tif (this[type].size !== defaultFonts[type].size) return true;\n\t\t\tif (this[type].style !== defaultFonts[type].style) return true;\n\t\t\tif (this[type].weight !== defaultFonts[type].weight) return true;\n\t\t\treturn false;\n\t\t},\n\t\taddFormattingOptions: function(el, defaultFonts, elType) {\n\t\t\tif (elType === 'note') {\n\t\t\t\tif (this.vocalPosition !== 'auto') addPositioning(el, 'vocalPosition', this.vocalPosition);\n\t\t\t\tif (this.dynamicPosition !== 'auto') addPositioning(el, 'dynamicPosition', this.dynamicPosition);\n\t\t\t\tif (this.chordPosition !== 'auto') addPositioning(el, 'chordPosition', this.chordPosition);\n\t\t\t\tif (this.ornamentPosition !== 'auto') addPositioning(el, 'ornamentPosition', this.ornamentPosition);\n\t\t\t\tif (this.volumePosition !== 'auto') addPositioning(el, 'volumePosition', this.volumePosition);\n\t\t\t\tif (this.differentFont(\"annotationfont\", defaultFonts)) addFont(el, 'annotationfont', this.annotationfont);\n\t\t\t\tif (this.differentFont(\"gchordfont\", defaultFonts)) addFont(el, 'gchordfont', this.gchordfont);\n\t\t\t\tif (this.differentFont(\"vocalfont\", defaultFonts)) addFont(el, 'vocalfont', this.vocalfont);\n\t\t\t\tif (this.differentFont(\"tripletfont\", defaultFonts)) addFont(el, 'tripletfont', this.tripletfont);\n\t\t\t} else if (elType === 'bar') {\n\t\t\t\tif (this.dynamicPosition !== 'auto') addPositioning(el, 'dynamicPosition', this.dynamicPosition);\n\t\t\t\tif (this.chordPosition !== 'auto') addPositioning(el, 'chordPosition', this.chordPosition);\n\t\t\t\tif (this.ornamentPosition !== 'auto') addPositioning(el, 'ornamentPosition', this.ornamentPosition);\n\t\t\t\tif (this.volumePosition !== 'auto') addPositioning(el, 'volumePosition', this.volumePosition);\n\t\t\t\tif (this.differentFont(\"measurefont\", defaultFonts)) addFont(el, 'measurefont', this.measurefont);\n\t\t\t\tif (this.differentFont(\"repeatfont\", defaultFonts)) addFont(el, 'repeatfont', this.repeatfont);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar addWarning = function(str) {\n\t\tif (!multilineVars.warnings)\n\t\t\tmultilineVars.warnings = [];\n\t\tmultilineVars.warnings.push(str);\n\t};\n\n\tvar addWarningObject = function(warningObject) {\n\t\tif (!multilineVars.warningObjects)\n\t\t\tmultilineVars.warningObjects = [];\n\t\tmultilineVars.warningObjects.push(warningObject);\n\t};\n\n\tvar encode = function(str) {\n\t\tvar ret = parseCommon.gsub(str, '\\x12', ' ');\n\t\tret = parseCommon.gsub(ret, '&', '&amp;');\n\t\tret = parseCommon.gsub(ret, '<', '&lt;');\n\t\treturn parseCommon.gsub(ret, '>', '&gt;');\n\t};\n\n\tvar warn = function(str, line, col_num) {\n\t\tif (!line) line = \" \";\n\t\tvar bad_char = line.charAt(col_num);\n\t\tif (bad_char === ' ')\n\t\t\tbad_char = \"SPACE\";\n\t\tvar clean_line = encode(line.substring(0, col_num)) +\n\t\t\t'<span style=\"text-decoration:underline;font-size:1.3em;font-weight:bold;\">' + bad_char + '</span>' +\n\t\t\tencode(line.substring(col_num+1));\n\t\taddWarning(\"Music Line:\" + tune.getNumLines() + \":\" + (col_num+1) + ': ' + str + \":  \" + clean_line);\n\t\taddWarningObject({message:str, line:line, startChar: multilineVars.iChar + col_num, column: col_num});\n\t};\n\tvar header = new ParseHeader(tokenizer, warn, multilineVars, tune);\n\n\tthis.getWarnings = function() {\n\t\treturn multilineVars.warnings;\n\t};\n\tthis.getWarningObjects = function() {\n\t\treturn multilineVars.warningObjects;\n\t};\n\n\tvar letter_to_chord = function(line, i)\n\t{\n\t\tif (line.charAt(i) === '\"')\n\t\t{\n\t\t\tvar chord = tokenizer.getBrackettedSubstring(line, i, 5);\n\t\t\tif (!chord[2])\n\t\t\t\twarn(\"Missing the closing quote while parsing the chord symbol\", line , i);\n\t\t\t// If it starts with ^, then the chord appears above.\n\t\t\t// If it starts with _ then the chord appears below.\n\t\t\t// (note that the 2.0 draft standard defines them as not chords, but annotations and also defines @.)\n\t\t\tif (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '^') {\n\t\t\t\tchord[1] = chord[1].substring(1);\n\t\t\t\tchord[2] = 'above';\n\t\t\t} else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '_') {\n\t\t\t\tchord[1] = chord[1].substring(1);\n\t\t\t\tchord[2] = 'below';\n\t\t\t} else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '<') {\n\t\t\t\tchord[1] = chord[1].substring(1);\n\t\t\t\tchord[2] = 'left';\n\t\t\t} else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '>') {\n\t\t\t\tchord[1] = chord[1].substring(1);\n\t\t\t\tchord[2] = 'right';\n\t\t\t} else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '@') {\n\t\t\t\t// @-15,5.7\n\t\t\t\tchord[1] = chord[1].substring(1);\n\t\t\t\tvar x = tokenizer.getFloat(chord[1]);\n\t\t\t\tif (x.digits === 0)\n\t\t\t\t\twarn(\"Missing first position in absolutely positioned annotation.\", line , i);\n\t\t\t\tchord[1] = chord[1].substring(x.digits);\n\t\t\t\tif (chord[1][0] !== ',')\n\t\t\t\t\twarn(\"Missing comma absolutely positioned annotation.\", line , i);\n\t\t\t\tchord[1] = chord[1].substring(1);\n\t\t\t\tvar y = tokenizer.getFloat(chord[1]);\n\t\t\t\tif (y.digits === 0)\n\t\t\t\t\twarn(\"Missing second position in absolutely positioned annotation.\", line , i);\n\t\t\t\tchord[1] = chord[1].substring(y.digits);\n\t\t\t\tvar ws = tokenizer.skipWhiteSpace(chord[1]);\n\t\t\t\tchord[1] = chord[1].substring(ws);\n\t\t\t\tchord[2] = null;\n\t\t\t\tchord[3] = { x: x.value, y: y.value };\n\t\t\t} else {\n\t\t\t\tif (multilineVars.freegchord !== true) {\n\t\t\t\t\tchord[1] = chord[1].replace(/([ABCDEFG0-9])b/g, \"$1♭\");\n\t\t\t\t\tchord[1] = chord[1].replace(/([ABCDEFG0-9])#/g, \"$1♯\");\n\t\t\t\t}\n\t\t\t\tchord[2] = 'default';\n\t\t\t\tchord[1] = transpose.chordName(multilineVars, chord[1]);\n\t\t\t}\n\t\t\treturn chord;\n\t\t}\n\t\treturn [0, \"\"];\n\t};\n\n\tvar legalAccents = [ \"trill\", \"lowermordent\", \"uppermordent\", \"mordent\", \"pralltriller\", \"accent\",\n\t\t\"fermata\", \"invertedfermata\", \"tenuto\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"+\", \"wedge\",\n\t\t\"open\", \"thumb\", \"snap\", \"turn\", \"roll\", \"breath\", \"shortphrase\", \"mediumphrase\", \"longphrase\",\n\t\t\"segno\", \"coda\", \"D.S.\", \"D.C.\", \"fine\",\n\t\t\"slide\", \"^\", \"marcato\",\n\t\t\"upbow\", \"downbow\", \"/\", \"//\", \"///\", \"////\", \"trem1\", \"trem2\", \"trem3\", \"trem4\",\n\t\t\"turnx\", \"invertedturn\", \"invertedturnx\", \"trill(\", \"trill)\", \"arpeggio\", \"xstem\", \"mark\", \"umarcato\",\n\t\t\"style=normal\", \"style=harmonic\", \"style=rhythm\", \"style=x\"\n\t];\n\tvar volumeDecorations = [ \"p\", \"pp\", \"f\", \"ff\", \"mf\", \"mp\", \"ppp\", \"pppp\",  \"fff\", \"ffff\", \"sfz\" ];\n\tvar dynamicDecorations = [\"crescendo(\", \"crescendo)\", \"diminuendo(\", \"diminuendo)\"];\n\n\tvar accentPseudonyms = [ [\"<\", \"accent\"], [\">\", \"accent\"], [\"tr\", \"trill\"],\n\t\t[\"plus\", \"+\"], [ \"emphasis\", \"accent\"],\n\t\t[ \"^\", \"umarcato\" ], [ \"marcato\", \"umarcato\" ] ];\n\tvar accentDynamicPseudonyms = [ [\"<(\", \"crescendo(\"], [\"<)\", \"crescendo)\"],\n\t\t[\">(\", \"diminuendo(\"], [\">)\", \"diminuendo)\"] ];\n\tvar letter_to_accent = function(line, i)\n\t{\n\t\tvar macro = multilineVars.macros[line.charAt(i)];\n\n\t\tif (macro !== undefined) {\n\t\t\tif (macro.charAt(0) === '!' || macro.charAt(0) === '+')\n\t\t\t\tmacro = macro.substring(1);\n\t\t\tif (macro.charAt(macro.length-1) === '!' || macro.charAt(macro.length-1) === '+')\n\t\t\t\tmacro = macro.substring(0, macro.length-1);\n\t\t\tif (parseCommon.detect(legalAccents, function(acc) {\n\t\t\t\t\treturn (macro === acc);\n\t\t\t\t}))\n\t\t\t\treturn [ 1, macro ];\n\t\t\telse if (parseCommon.detect(volumeDecorations, function(acc) {\n\t\t\t\t\treturn (macro === acc);\n\t\t\t\t})) {\n\t\t\t\tif (multilineVars.volumePosition === 'hidden')\n\t\t\t\t\tmacro = \"\";\n\t\t\t\treturn [1, macro];\n\t\t\t} else if (parseCommon.detect(dynamicDecorations, function(acc) {\n\t\t\t\t\tif (multilineVars.dynamicPosition === 'hidden')\n\t\t\t\t\t\tmacro = \"\";\n\t\t\t\t\treturn (macro === acc);\n\t\t\t\t})) {\n\t\t\t\treturn [1, macro];\n\t\t\t} else {\n\t\t\t\tif (!parseCommon.detect(multilineVars.ignoredDecorations, function(dec) {\n\t\t\t\t\treturn (macro === dec);\n\t\t\t\t}))\n\t\t\t\t\twarn(\"Unknown macro: \" + macro, line, i);\n\t\t\t\treturn [1, '' ];\n\t\t\t}\n\t\t}\n\t\tswitch (line.charAt(i))\n\t\t{\n\t\t\tcase '.':return [1, 'staccato'];\n\t\t\tcase 'u':return [1, 'upbow'];\n\t\t\tcase 'v':return [1, 'downbow'];\n\t\t\tcase '~':return [1, 'irishroll'];\n\t\t\tcase '!':\n\t\t\tcase '+':\n\t\t\t\tvar ret = tokenizer.getBrackettedSubstring(line, i, 5);\n\t\t\t\t// Be sure that the accent is recognizable.\n\t\t\tif (ret[1].length > 0 && (ret[1].charAt(0) === '^' || ret[1].charAt(0) ==='_'))\n\t\t\t\t\tret[1] = ret[1].substring(1);\t// TODO-PER: The test files have indicators forcing the ornament to the top or bottom, but that isn't in the standard. We'll just ignore them.\n\t\t\t\tif (parseCommon.detect(legalAccents, function(acc) {\n\t\t\t\t\treturn (ret[1] === acc);\n\t\t\t\t}))\n\t\t\t\t\treturn ret;\n\t\t\t\tif (parseCommon.detect(volumeDecorations, function(acc) {\n\t\t\t\t\t\treturn (ret[1] === acc);\n\t\t\t\t\t})) {\n\t\t\t\t\tif (multilineVars.volumePosition === 'hidden' )\n\t\t\t\t\t\tret[1] = '';\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tif (parseCommon.detect(dynamicDecorations, function(acc) {\n\t\t\t\t\t\treturn (ret[1] === acc);\n\t\t\t\t\t})) {\n\t\t\t\t\tif (multilineVars.dynamicPosition === 'hidden' )\n\t\t\t\t\t\tret[1] = '';\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tif (parseCommon.detect(accentPseudonyms, function(acc) {\n\t\t\t\t\tif (ret[1] === acc[0]) {\n\t\t\t\t\t\tret[1] = acc[1];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn false;\n\t\t\t\t}))\n\t\t\t\t\treturn ret;\n\n\t\t\t\tif (parseCommon.detect(accentDynamicPseudonyms, function(acc) {\n\t\t\t\t\tif (ret[1] === acc[0]) {\n\t\t\t\t\t\tret[1] = acc[1];\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn false;\n\t\t\t\t})) {\n\t\t\t\t\tif (multilineVars.dynamicPosition === 'hidden' )\n\t\t\t\t\t\tret[1] = '';\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\t// We didn't find the accent in the list, so consume the space, but don't return an accent.\n\t\t\t\t// Although it is possible that ! was used as a line break, so accept that.\n\t\t\tif (line.charAt(i) === '!' && (ret[0] === 1 || line.charAt(i+ret[0]-1) !== '!'))\n\t\t\t\t\treturn [1, null ];\n\t\t\t\twarn(\"Unknown decoration: \" + ret[1], line, i);\n\t\t\t\tret[1] = \"\";\n\t\t\t\treturn ret;\n\t\t\tcase 'H':return [1, 'fermata'];\n\t\t\tcase 'J':return [1, 'slide'];\n\t\t\tcase 'L':return [1, 'accent'];\n\t\t\tcase 'M':return [1, 'mordent'];\n\t\t\tcase 'O':return[1, 'coda'];\n\t\t\tcase 'P':return[1, 'pralltriller'];\n\t\t\tcase 'R':return [1, 'roll'];\n\t\t\tcase 'S':return [1, 'segno'];\n\t\t\tcase 'T':return [1, 'trill'];\n\t\t}\n\t\treturn [0, 0];\n\t};\n\n\tvar letter_to_spacer = function(line, i)\n\t{\n\t\tvar start = i;\n\t\twhile (tokenizer.isWhiteSpace(line.charAt(i)))\n\t\t\ti++;\n\t\treturn [ i-start ];\n\t};\n\n\t// returns the class of the bar line\n\t// the number of the repeat\n\t// and the number of characters used up\n\t// if 0 is returned, then the next element was not a bar line\n\tvar letter_to_bar = function(line, curr_pos)\n\t{\n\t\tvar ret = tokenizer.getBarLine(line, curr_pos);\n\t\tif (ret.len === 0)\n\t\t\treturn [0,\"\"];\n\t\tif (ret.warn) {\n\t\t\twarn(ret.warn, line, curr_pos);\n\t\t\treturn [ret.len,\"\"];\n\t\t}\n\n\t\t// Now see if this is a repeated ending\n\t\t// A repeated ending is all of the characters 1,2,3,4,5,6,7,8,9,0,-, and comma\n\t\t// It can also optionally start with '[', which is ignored.\n\t\t// Also, it can have white space before the '['.\n\t\tfor (var ws = 0; ws < line.length; ws++)\n\t\t\tif (line.charAt(curr_pos + ret.len + ws) !== ' ')\n\t\t\t\tbreak;\n\t\tvar orig_bar_len = ret.len;\n\t\tif (line.charAt(curr_pos+ret.len+ws) === '[') {\n\t\t\tret.len += ws + 1;\n\t\t}\n\n\t\t// It can also be a quoted string. It is unclear whether that construct requires '[', but it seems like it would. otherwise it would be confused with a regular chord.\n\t\tif (line.charAt(curr_pos+ret.len) === '\"' && line.charAt(curr_pos+ret.len-1) === '[') {\n\t\t\tvar ending = tokenizer.getBrackettedSubstring(line, curr_pos+ret.len, 5);\n\t\t\treturn [ret.len+ending[0], ret.token, ending[1]];\n\t\t}\n\t\tvar retRep = tokenizer.getTokenOf(line.substring(curr_pos+ret.len), \"1234567890-,\");\n\t\tif (retRep.len === 0 || retRep.token[0] === '-')\n\t\t\treturn [orig_bar_len, ret.token];\n\n\t\treturn [ret.len+retRep.len, ret.token, retRep.token];\n\t};\n\n\tvar tripletQ = {\n\t\t2: 3,\n\t\t3: 2,\n\t\t4: 3,\n\t\t5: 2, // TODO-PER: not handling 6/8 rhythm yet\n\t\t6: 2,\n\t\t7: 2, // TODO-PER: not handling 6/8 rhythm yet\n\t\t8: 3,\n\t\t9: 2 // TODO-PER: not handling 6/8 rhythm yet\n\t};\n\tvar letter_to_open_slurs_and_triplets =  function(line, i) {\n\t\t// consume spaces, and look for all the open parens. If there is a number after the open paren,\n\t\t// that is a triplet. Otherwise that is a slur. Collect all the slurs and the first triplet.\n\t\tvar ret = {};\n\t\tvar start = i;\n\t\twhile (line.charAt(i) === '(' || tokenizer.isWhiteSpace(line.charAt(i))) {\n\t\t\tif (line.charAt(i) === '(') {\n\t\t\t\tif (i+1 < line.length && (line.charAt(i+1) >= '2' && line.charAt(i+1) <= '9')) {\n\t\t\t\t\tif (ret.triplet !== undefined)\n\t\t\t\t\t\twarn(\"Can't nest triplets\", line, i);\n\t\t\t\t\telse {\n\t\t\t\t\t\tret.triplet = line.charAt(i+1) - '0';\n\t\t\t\t\t\tret.tripletQ = tripletQ[ret.triplet];\n\t\t\t\t\t\tret.num_notes = ret.triplet;\n\t\t\t\t\t\tif (i+2 < line.length && line.charAt(i+2) === ':') {\n\t\t\t\t\t\t\t// We are expecting \"(p:q:r\" or \"(p:q\" or \"(p::r\"\n\t\t\t\t\t\t\t// That is: \"put p notes into the time of q for the next r notes\"\n\t\t\t\t\t\t\t// if r is missing, then it is equal to p.\n\t\t\t\t\t\t\t// if q is missing, it is determined from this table:\n\t\t\t\t\t\t\t// (2 notes in the time of 3\n\t\t\t\t\t\t\t// (3 notes in the time of 2\n\t\t\t\t\t\t\t// (4 notes in the time of 3\n\t\t\t\t\t\t\t// (5 notes in the time of n | if time sig is (6/8, 9/8, 12/8), n=3, else n=2\n\t\t\t\t\t\t\t// (6 notes in the time of 2\n\t\t\t\t\t\t\t// (7 notes in the time of n\n\t\t\t\t\t\t\t// (8 notes in the time of 3\n\t\t\t\t\t\t\t// (9 notes in the time of n\n\t\t\t\t\t\t\tif (i+3 < line.length && line.charAt(i+3) === ':') {\n\t\t\t\t\t\t\t\t// The second number, 'q', is not present.\n\t\t\t\t\t\t\t\tif (i+4 < line.length && (line.charAt(i+4) >= '1' && line.charAt(i+4) <= '9')) {\n\t\t\t\t\t\t\t\t\tret.num_notes = line.charAt(i+4) - '0';\n\t\t\t\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\twarn(\"expected number after the two colons after the triplet to mark the duration\", line, i);\n\t\t\t\t\t\t\t} else if (i+3 < line.length && (line.charAt(i+3) >= '1' && line.charAt(i+3) <= '9')) {\n\t\t\t\t\t\t\t\tret.tripletQ = line.charAt(i+3) - '0';\n\t\t\t\t\t\t\t\tif (i+4 < line.length && line.charAt(i+4) === ':') {\n\t\t\t\t\t\t\t\t\tif (i+5 < line.length && (line.charAt(i+5) >= '1' && line.charAt(i+5) <= '9')) {\n\t\t\t\t\t\t\t\t\t\tret.num_notes = line.charAt(i+5) - '0';\n\t\t\t\t\t\t\t\t\t\ti += 4;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\twarn(\"expected number after the triplet to mark the duration\", line, i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ret.startSlur === undefined)\n\t\t\t\t\t\tret.startSlur = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tret.startSlur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tret.consumed = i-start;\n\t\treturn ret;\n\t};\n\n\tvar addWords = function(line, words) {\n\t\tif (!line) { warn(\"Can't add words before the first line of music\", line, 0); return; }\n\t\twords = parseCommon.strip(words);\n\t\tif (words.charAt(words.length-1) !== '-')\n\t\t\twords = words + ' ';\t// Just makes it easier to parse below, since every word has a divider after it.\n\t\tvar word_list = [];\n\t\t// first make a list of words from the string we are passed. A word is divided on either a space or dash.\n\t\tvar last_divider = 0;\n\t\tvar replace = false;\n\t\tvar addWord = function(i) {\n\t\t\tvar word = parseCommon.strip(words.substring(last_divider, i));\n\t\t\tlast_divider = i+1;\n\t\t\tif (word.length > 0) {\n\t\t\t\tif (replace)\n\t\t\t\t\tword = parseCommon.gsub(word,'~', ' ');\n\t\t\t\tvar div = words.charAt(i);\n\t\t\t\tif (div !== '_' && div !== '-')\n\t\t\t\t\tdiv = ' ';\n\t\t\t\tword_list.push({syllable: tokenizer.translateString(word), divider: div});\n\t\t\t\treplace = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; i < words.length; i++) {\n\t\t\tswitch (words.charAt(i)) {\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\x12':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif (!addWord(i) && word_list.length > 0) {\n\t\t\t\t\t\tparseCommon.last(word_list).divider = '-';\n\t\t\t\t\t\tword_list.push({skip: true, to: 'next'});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tword_list.push({skip: true, to: 'slur'});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tword_list.push({skip: true, to: 'next'});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tword_list.push({skip: true, to: 'bar'});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '~':\n\t\t\t\t\treplace = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvar inSlur = false;\n\t\tparseCommon.each(line, function(el) {\n\t\t\tif (word_list.length !== 0) {\n\t\t\t\tif (word_list[0].skip) {\n\t\t\t\t\tswitch (word_list[0].to) {\n\t\t\t\t\t\tcase 'next': if (el.el_type === 'note' && el.pitches !== null && !inSlur) word_list.shift(); break;\n\t\t\t\t\t\tcase 'slur': if (el.el_type === 'note' && el.pitches !== null) word_list.shift(); break;\n\t\t\t\t\t\tcase 'bar': if (el.el_type === 'bar') word_list.shift(); break;\n\t\t\t\t\t}\n\t\t\t\t\tif (el.el_type !== 'bar') {\n\t\t\t\t\t\tif (el.lyric === undefined)\n\t\t\t\t\t\t\tel.lyric = [{syllable: \"\", divider: \" \"}];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tel.lyric.push({syllable: \"\", divider: \" \"});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (el.el_type === 'note' && el.rest === undefined && !inSlur) {\n\t\t\t\t\t\tvar lyric = word_list.shift();\n\t\t\t\t\t\tif (lyric.syllable)\n\t\t\t\t\t\t\tlyric.syllable = lyric.syllable.replace(/ +/g,'\\xA0');\n\t\t\t\t\t\tif (el.lyric === undefined)\n\t\t\t\t\t\t\tel.lyric = [ lyric ];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tel.lyric.push(lyric);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\tvar addSymbols = function(line, words) {\n\t\t// TODO-PER: Currently copied from w: line. This needs to be read as symbols instead.\n\t\tif (!line) { warn(\"Can't add symbols before the first line of music\", line, 0); return; }\n\t\twords = parseCommon.strip(words);\n\t\tif (words.charAt(words.length-1) !== '-')\n\t\t\twords = words + ' ';\t// Just makes it easier to parse below, since every word has a divider after it.\n\t\tvar word_list = [];\n\t\t// first make a list of words from the string we are passed. A word is divided on either a space or dash.\n\t\tvar last_divider = 0;\n\t\tvar replace = false;\n\t\tvar addWord = function(i) {\n\t\t\tvar word = parseCommon.strip(words.substring(last_divider, i));\n\t\t\tlast_divider = i+1;\n\t\t\tif (word.length > 0) {\n\t\t\t\tif (replace)\n\t\t\t\t\tword = parseCommon.gsub(word, '~', ' ');\n\t\t\t\tvar div = words.charAt(i);\n\t\t\t\tif (div !== '_' && div !== '-')\n\t\t\t\t\tdiv = ' ';\n\t\t\t\tword_list.push({syllable: tokenizer.translateString(word), divider: div});\n\t\t\t\treplace = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; i < words.length; i++) {\n\t\t\tswitch (words.charAt(i)) {\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\x12':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif (!addWord(i) && word_list.length > 0) {\n\t\t\t\t\t\tparseCommon.last(word_list).divider = '-';\n\t\t\t\t\t\tword_list.push({skip: true, to: 'next'});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tword_list.push({skip: true, to: 'slur'});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tword_list.push({skip: true, to: 'next'});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '|':\n\t\t\t\t\taddWord(i);\n\t\t\t\t\tword_list.push({skip: true, to: 'bar'});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '~':\n\t\t\t\t\treplace = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvar inSlur = false;\n\t\tparseCommon.each(line, function(el) {\n\t\t\tif (word_list.length !== 0) {\n\t\t\t\tif (word_list[0].skip) {\n\t\t\t\t\tswitch (word_list[0].to) {\n\t\t\t\t\t\tcase 'next': if (el.el_type === 'note' && el.pitches !== null && !inSlur) word_list.shift(); break;\n\t\t\t\t\t\tcase 'slur': if (el.el_type === 'note' && el.pitches !== null) word_list.shift(); break;\n\t\t\t\t\t\tcase 'bar': if (el.el_type === 'bar') word_list.shift(); break;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (el.el_type === 'note' && el.rest === undefined && !inSlur) {\n\t\t\t\t\t\tvar lyric = word_list.shift();\n\t\t\t\t\t\tif (el.lyric === undefined)\n\t\t\t\t\t\t\tel.lyric = [ lyric ];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tel.lyric.push(lyric);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\tvar getBrokenRhythm = function(line, index) {\n\t\tswitch (line.charAt(index)) {\n\t\t\tcase '>':\n\t\t\tif (index < line.length - 1 && line.charAt(index+1) === '>')\t// double >>\n\t\t\t\t\treturn [2, 1.75, 0.25];\n\t\t\t\telse\n\t\t\t\t\treturn [1, 1.5, 0.5];\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\tif (index < line.length - 1 && line.charAt(index+1) === '<')\t// double <<\n\t\t\t\t\treturn [2, 0.25, 1.75];\n\t\t\t\telse\n\t\t\t\t\treturn [1, 0.5, 1.5];\n\t\t\t\tbreak;\n\t\t}\n\t\treturn null;\n\t};\n\n\t// TODO-PER: make this a method in el.\n\tvar addEndBeam = function(el) {\n\t\tif (el.duration !== undefined && el.duration < 0.25)\n\t\t\tel.end_beam = true;\n\t\treturn el;\n\t};\n\n\tvar pitches = {A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11};\n\tvar rests = {x: 'invisible', y: 'spacer', z: 'rest', Z: 'multimeasure' };\n\tvar getCoreNote = function(line, index, el, canHaveBrokenRhythm) {\n\t\t//var el = { startChar: index };\n\t\tvar isComplete = function(state) {\n\t\t\treturn (state === 'octave' || state === 'duration' || state === 'Zduration' || state === 'broken_rhythm' || state === 'end_slur');\n\t\t};\n\t\tvar state = 'startSlur';\n\t\tvar durationSetByPreviousNote = false;\n\t\twhile (1) {\n\t\t\tswitch(line.charAt(index)) {\n\t\t\t\tcase '(':\n\t\t\t\t\tif (state === 'startSlur') {\n\t\t\t\t\t\tif (el.startSlur === undefined) el.startSlur = 1; else el.startSlur++;\n\t\t\t\t\t} else if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\tif (isComplete(state)) {\n\t\t\t\t\t\tif (el.endSlur === undefined) el.endSlur = 1; else el.endSlur++;\n\t\t\t\t\t} else return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '^':\n\t\t\t\t\tif (state === 'startSlur') {el.accidental = 'sharp';state = 'sharp2';}\n\t\t\t\t\telse if (state === 'sharp2') {el.accidental = 'dblsharp';state = 'pitch';}\n\t\t\t\t\telse if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '_':\n\t\t\t\t\tif (state === 'startSlur') {el.accidental = 'flat';state = 'flat2';}\n\t\t\t\t\telse if (state === 'flat2') {el.accidental = 'dblflat';state = 'pitch';}\n\t\t\t\t\telse if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '=':\n\t\t\t\t\tif (state === 'startSlur') {el.accidental = 'natural';state = 'pitch';}\n\t\t\t\t\telse if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'A':\n\t\t\t\tcase 'B':\n\t\t\t\tcase 'C':\n\t\t\t\tcase 'D':\n\t\t\t\tcase 'E':\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'G':\n\t\t\t\tcase 'a':\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'e':\n\t\t\t\tcase 'f':\n\t\t\t\tcase 'g':\n\t\t\t\t\tif (state === 'startSlur' || state === 'sharp2' || state === 'flat2' || state === 'pitch') {\n\t\t\t\t\t\tel.pitch = pitches[line.charAt(index)];\n\t\t\t\t\t\ttranspose.note(multilineVars, el);\n\t\t\t\t\t\tstate = 'octave';\n\t\t\t\t\t\t// At this point we have a valid note. The rest is optional. Set the duration in case we don't get one below\n\t\t\t\t\t\tif (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {\n\t\t\t\t\t\t\tel.duration = multilineVars.default_length * multilineVars.next_note_duration;\n\t\t\t\t\t\t\tmultilineVars.next_note_duration = 0;\n\t\t\t\t\t\t\tdurationSetByPreviousNote = true;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tel.duration = multilineVars.default_length;\n\t\t\t\t\t\t// If the clef is percussion, there is probably some translation of the pitch to a particular drum kit item.\n\t\t\t\t\t\tif ((multilineVars.clef && multilineVars.clef.type === \"perc\") ||\n\t\t\t\t\t\t\t(multilineVars.currentVoice && multilineVars.currentVoice.clef === \"perc\")) {\n\t\t\t\t\t\t\tvar key = line.charAt(index);\n\t\t\t\t\t\t\tif (el.accidental) {\n\t\t\t\t\t\t\t\tvar accMap = { 'dblflat': '__', 'flat': '_', 'natural': '=', 'sharp': '^', 'dblsharp': '^^'};\n\t\t\t\t\t\t\t\tkey = accMap[el.accidental] + key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (tune.formatting && tune.formatting.midi && tune.formatting.midi.drummap)\n\t\t\t\t\t\t\t\tel.midipitch = tune.formatting.midi.drummap[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ',':\n\t\t\t\t\tif (state === 'octave') {el.pitch -= 7;}\n\t\t\t\t\telse if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tif (state === 'octave') {el.pitch += 7;}\n\t\t\t\t\telse if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\n\t\t\t\tcase 'y':\n\t\t\t\tcase 'z':\n\t\t\t\tcase 'Z':\n\t\t\t\t\tif (state === 'startSlur') {\n\t\t\t\t\t\tel.rest = { type: rests[line.charAt(index)] };\n\t\t\t\t\t\t// There shouldn't be some of the properties that notes have. If some sneak in due to bad syntax in the abc file,\n\t\t\t\t\t\t// just nix them here.\n\t\t\t\t\t\tdelete el.accidental;\n\t\t\t\t\t\tdelete el.startSlur;\n\t\t\t\t\t\tdelete el.startTie;\n\t\t\t\t\t\tdelete el.endSlur;\n\t\t\t\t\t\tdelete el.endTie;\n\t\t\t\t\t\tdelete el.end_beam;\n\t\t\t\t\t\tdelete el.grace_notes;\n\t\t\t\t\t\t// At this point we have a valid note. The rest is optional. Set the duration in case we don't get one below\n\t\t\t\t\t\tif (el.rest.type === 'multimeasure') {\n\t\t\t\t\t\t\tel.duration = 1;\n\t\t\t\t\t\t\tstate = 'Zduration';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {\n\t\t\t\t\t\t\t\tel.duration = multilineVars.default_length * multilineVars.next_note_duration;\n\t\t\t\t\t\t\t\tmultilineVars.next_note_duration = 0;\n\t\t\t\t\t\t\t\tdurationSetByPreviousNote = true;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tel.duration = multilineVars.default_length;\n\t\t\t\t\t\t\tstate = 'duration';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\tcase '0':\n\t\t\t\tcase '/':\n\t\t\t\t\tif (state === 'octave' || state === 'duration') {\n\t\t\t\t\t\tvar fraction = tokenizer.getFraction(line, index);\n\t\t\t\t\t\t//if (!durationSetByPreviousNote)\n\t\t\t\t\t\t\tel.duration = el.duration * fraction.value;\n\t\t\t\t\t\t// TODO-PER: We can test the returned duration here and give a warning if it isn't the one expected.\n\t\t\t\t\t\tel.endChar = fraction.index;\n\t\t\t\t\t\twhile (fraction.index < line.length && (tokenizer.isWhiteSpace(line.charAt(fraction.index)) || line.charAt(fraction.index) === '-')) {\n\t\t\t\t\t\t\tif (line.charAt(fraction.index) === '-')\n\t\t\t\t\t\t\t\tel.startTie = {};\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tel = addEndBeam(el);\n\t\t\t\t\t\t\tfraction.index++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex = fraction.index-1;\n\t\t\t\t\t\tstate = 'broken_rhythm';\n\t\t\t\t\t} else if (state === 'sharp2') {\n\t\t\t\t\t\tel.accidental = 'quartersharp';state = 'pitch';\n\t\t\t\t\t} else if (state === 'flat2') {\n\t\t\t\t\t\tel.accidental = 'quarterflat';state = 'pitch';\n\t\t\t\t\t} else if (state === 'Zduration') {\n\t\t\t\t\t\tvar num = tokenizer.getNumber(line, index);\n\t\t\t\t\t\tel.duration = num.num;\n\t\t\t\t\t\tel.endChar = num.index;\n\t\t\t\t\t\treturn el;\n\t\t\t\t\t} else return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tif (state === 'startSlur') {\n\t\t\t\t\t\t// This is the first character, so it must have been meant for the previous note. Correct that here.\n\t\t\t\t\t\ttune.addTieToLastNote();\n\t\t\t\t\t\tel.endTie = true;\n\t\t\t\t\t} else if (state === 'octave' || state === 'duration' || state === 'end_slur') {\n\t\t\t\t\t\tel.startTie = {};\n\t\t\t\t\t\tif (!durationSetByPreviousNote && canHaveBrokenRhythm)\n\t\t\t\t\t\t\tstate = 'broken_rhythm';\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// Peek ahead to the next character. If it is a space, then we have an end beam.\n\t\t\t\t\t\t\tif (tokenizer.isWhiteSpace(line.charAt(index + 1)))\n\t\t\t\t\t\t\t\taddEndBeam(el);\n\t\t\t\t\t\t\tel.endChar = index+1;\n\t\t\t\t\t\t\treturn el;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (state === 'broken_rhythm') {el.endChar = index;return el;}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ' ':\n\t\t\t\tcase '\\t':\n\t\t\t\t\tif (isComplete(state)) {\n\t\t\t\t\t\tel.end_beam = true;\n\t\t\t\t\t\t// look ahead to see if there is a tie\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (line.charAt(index) === '-')\n\t\t\t\t\t\t\t\tel.startTie = {};\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} while (index < line.length && (tokenizer.isWhiteSpace(line.charAt(index)) || line.charAt(index) === '-'));\n\t\t\t\t\t\tel.endChar = index;\n\t\t\t\t\t\tif (!durationSetByPreviousNote && canHaveBrokenRhythm && (line.charAt(index) === '<' || line.charAt(index) === '>')) {\t// TODO-PER: Don't need the test for < and >, but that makes the endChar work out for the regression test.\n\t\t\t\t\t\t\tindex--;\n\t\t\t\t\t\t\tstate = 'broken_rhythm';\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn el;\n\t\t\t\t\t}\n\t\t\t\t\telse return null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\tcase '<':\n\t\t\t\t\tif (isComplete(state)) {\n\t\t\t\t\t\tif (canHaveBrokenRhythm) {\n\t\t\t\t\t\t\tvar br2 = getBrokenRhythm(line, index);\n\t\t\t\t\t\t\tindex += br2[0] - 1;\t// index gets incremented below, so we'll let that happen\n\t\t\t\t\t\t\tmultilineVars.next_note_duration = br2[2];\n\t\t\t\t\t\t\tel.duration = br2[1]*el.duration;\n\t\t\t\t\t\t\tstate = 'end_slur';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tel.endChar = index;\n\t\t\t\t\t\t\treturn el;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (isComplete(state)) {\n\t\t\t\t\t\tel.endChar = index;\n\t\t\t\t\t\treturn el;\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t\tindex++;\n\t\t\tif (index === line.length) {\n\t\t\t\tif (isComplete(state)) {el.endChar = index;return el;}\n\t\t\t\telse return null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\tfunction startNewLine() {\n\t\tvar params = { startChar: -1, endChar: -1};\n\t\tif (multilineVars.partForNextLine.title)\n\t\t\tparams.part = multilineVars.partForNextLine;\n\t\tparams.clef = multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].clef !== undefined ? parseCommon.clone(multilineVars.staves[multilineVars.currentVoice.staffNum].clef) : parseCommon.clone(multilineVars.clef);\n\t\tvar scoreTranspose = multilineVars.currentVoice ? multilineVars.currentVoice.scoreTranspose : 0;\n\t\tparams.key = parseKeyVoice.standardKey(multilineVars.key.root+multilineVars.key.acc+multilineVars.key.mode, multilineVars.key.root, multilineVars.key.acc, scoreTranspose);\n\t\tparams.key.mode = multilineVars.key.mode;\n\t\tif (multilineVars.key.impliedNaturals)\n\t\t\tparams.key.impliedNaturals = multilineVars.key.impliedNaturals;\n\t\tif (multilineVars.key.explicitAccidentals) {\n\t\t\tfor (var i = 0; i < multilineVars.key.explicitAccidentals.length; i++) {\n\t\t\t\tvar found = false;\n\t\t\t\tfor (var j = 0; j < params.key.accidentals.length; j++) {\n\t\t\t\t\tif (params.key.accidentals[j].note === multilineVars.key.explicitAccidentals[i].note) {\n\t\t\t\t\t\t// If the note is already in the list, override it with the new value\n\t\t\t\t\t\tparams.key.accidentals[j].acc = multilineVars.key.explicitAccidentals[i].acc;\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found)\n\t\t\t\t\tparams.key.accidentals.push(multilineVars.key.explicitAccidentals[i]);\n\t\t\t}\n\t\t}\n\t\tmultilineVars.targetKey = params.key;\n\t\tif (params.key.explicitAccidentals)\n\t\t\tdelete params.key.explicitAccidentals;\n\t\tparseKeyVoice.addPosToKey(params.clef, params.key);\n\t\tif (multilineVars.meter !== null) {\n\t\t\tif (multilineVars.currentVoice) {\n\t\t\t\tparseCommon.each(multilineVars.staves, function(st) {\n\t\t\t\t\tst.meter = multilineVars.meter;\n\t\t\t\t});\n\t\t\t\tparams.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;\n\t\t\t\tmultilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;\n\t\t\t} else\n\t\t\t\tparams.meter = multilineVars.meter;\n\t\t\tmultilineVars.meter = null;\n\t\t} else if (multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].meter) {\n\t\t\t// Make sure that each voice gets the meter marking.\n\t\t\tparams.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;\n\t\t\tmultilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;\n\t\t}\n\t\tif (multilineVars.currentVoice && multilineVars.currentVoice.name)\n\t\t\tparams.name = multilineVars.currentVoice.name;\n\t\tif (multilineVars.vocalfont)\n\t\t\tparams.vocalfont = multilineVars.vocalfont;\n\t\tif (multilineVars.tripletfont)\n\t\t\tparams.tripletfont = multilineVars.tripletfont;\n\t\tif (multilineVars.style)\n\t\t\tparams.style = multilineVars.style;\n\t\tif (multilineVars.currentVoice) {\n\t\t\tvar staff = multilineVars.staves[multilineVars.currentVoice.staffNum];\n\t\t\tif (staff.brace) params.brace = staff.brace;\n\t\t\tif (staff.bracket) params.bracket = staff.bracket;\n\t\t\tif (staff.connectBarLines) params.connectBarLines = staff.connectBarLines;\n\t\t\tif (staff.name) params.name = staff.name[multilineVars.currentVoice.index];\n\t\t\tif (staff.subname) params.subname = staff.subname[multilineVars.currentVoice.index];\n\t\t\tif (multilineVars.currentVoice.stem)\n\t\t\t\tparams.stem = multilineVars.currentVoice.stem;\n\t\t\tif (multilineVars.currentVoice.stafflines)\n\t\t\t\tparams.stafflines = multilineVars.currentVoice.stafflines;\n\t\t\tif (multilineVars.currentVoice.staffscale)\n\t\t\t\tparams.staffscale = multilineVars.currentVoice.staffscale;\n\t\t\tif (multilineVars.currentVoice.scale)\n\t\t\t\tparams.scale = multilineVars.currentVoice.scale;\n\t\t\tif (multilineVars.currentVoice.style)\n\t\t\t\tparams.style = multilineVars.currentVoice.style;\n\t\t\tif (multilineVars.currentVoice.transpose)\n\t\t\t\tparams.clef.transpose = multilineVars.currentVoice.transpose;\n\t\t}\n\t\tvar isFirstVoice = multilineVars.currentVoice === undefined || (multilineVars.currentVoice.staffNum ===  0 && multilineVars.currentVoice.index ===  0);\n\t\tif (multilineVars.barNumbers === 0 && isFirstVoice && multilineVars.currBarNumber !== 1)\n\t\t\tparams.barNumber = multilineVars.currBarNumber;\n\t\ttune.startNewLine(params);\n\t\tif (multilineVars.key.impliedNaturals)\n\t\t\tdelete multilineVars.key.impliedNaturals;\n\n\t\tmultilineVars.partForNextLine = {};\n\t}\n\n\tvar letter_to_grace =  function(line, i) {\n\t\t// Grace notes are an array of: startslur, note, endslur, space; where note is accidental, pitch, duration\n\t\tif (line.charAt(i) === '{') {\n\t\t\t// fetch the gracenotes string and consume that into the array\n\t\t\tvar gra = tokenizer.getBrackettedSubstring(line, i, 1, '}');\n\t\t\tif (!gra[2])\n\t\t\t\twarn(\"Missing the closing '}' while parsing grace note\", line, i);\n\t\t\t// If there is a slur after the grace construction, then move it to the last note inside the grace construction\n\t\t\tif (line[i+gra[0]] === ')') {\n\t\t\t\tgra[0]++;\n\t\t\t\tgra[1] += ')';\n\t\t\t}\n\n\t\t\tvar gracenotes = [];\n\t\t\tvar ii = 0;\n\t\t\tvar inTie = false;\n\t\t\twhile (ii < gra[1].length) {\n\t\t\t\tvar acciaccatura = false;\n\t\t\t\tif (gra[1].charAt(ii) === '/') {\n\t\t\t\t\tacciaccatura = true;\n\t\t\t\t\tii++;\n\t\t\t\t}\n\t\t\t\tvar note = getCoreNote(gra[1], ii, {}, false);\n\t\t\t\tif (note !== null) {\n\t\t\t\t\t// The grace note durations should not be affected by the default length: they should be based on 1/16, so if that isn't the default, then multiply here.\n\t\t\t\t\tnote.duration = note.duration / (multilineVars.default_length * 8);\n\t\t\t\t\tif (acciaccatura)\n\t\t\t\t\t\tnote.acciaccatura = true;\n\t\t\t\t\tgracenotes.push(note);\n\n\t\t\t\t\tif (inTie) {\n\t\t\t\t\t\tnote.endTie = true;\n\t\t\t\t\t\tinTie = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (note.startTie)\n\t\t\t\t\t\tinTie = true;\n\n\t\t\t\t\tii  = note.endChar;\n\t\t\t\t\tdelete note.endChar;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// We shouldn't get anything but notes or a space here, so report an error\n\t\t\t\t\tif (gra[1].charAt(ii) === ' ') {\n\t\t\t\t\t\tif (gracenotes.length > 0)\n\t\t\t\t\t\t\tgracenotes[gracenotes.length-1].end_beam = true;\n\t\t\t\t\t} else\n\t\t\t\t\t\twarn(\"Unknown character '\" + gra[1].charAt(ii) + \"' while parsing grace note\", line, i);\n\t\t\t\t\tii++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (gracenotes.length)\n\t\t\t\treturn [gra[0], gracenotes];\n\t\t}\n\t\treturn [ 0 ];\n\t};\n\n\tfunction letter_to_overlay(line, i) {\n\t\tif (line.charAt(i) === '&') {\n\t\t\tvar start = i;\n\t\t\twhile (line.charAt(i) && line.charAt(i) !== ':' && line.charAt(i) !== '|')\n\t\t\t\ti++;\n\t\t\treturn [ i-start, line.substring(start+1, i) ];\n\t\t}\n\t\treturn [ 0 ];\n\t}\n\n\tfunction durationOfMeasure(multilineVars) {\n\t\t// TODO-PER: This could be more complicated if one of the unusual measures is used.\n\t\tvar meter = multilineVars.origMeter;\n\t\tif (!meter || meter.type !== 'specified')\n\t\t\treturn 1;\n\t\tif (!meter.value || meter.value.length === 0)\n\t\t\treturn 1;\n\t\treturn parseInt(meter.value[0].num, 10) / parseInt(meter.value[0].den, 10);\n\t}\n\n\t//\n\t// Parse line of music\n\t//\n\t// This is a stream of <(bar-marking|header|note-group)...> in any order, with optional spaces between each element\n\t// core-note is <open-slur, accidental, pitch:required, octave, duration, close-slur&|tie> with no spaces within that\n\t// chord is <open-bracket:required, core-note:required... close-bracket:required duration> with no spaces within that\n\t// grace-notes is <open-brace:required, (open-slur|core-note:required|close-slur)..., close-brace:required> spaces are allowed\n\t// note-group is <grace-notes, chord symbols&|decorations..., grace-notes, slur&|triplet, chord|core-note, end-slur|tie> spaces are allowed between items\n\t// bar-marking is <ampersand> or <chord symbols&|decorations..., bar:required> spaces allowed\n\t// header is <open-bracket:required, K|M|L|V:required, colon:required, field:required, close-bracket:required> spaces can occur between the colon, in the field, and before the close bracket\n\t// header can also be the only thing on a line. This is true even if it is a continuation line. In this case the brackets are not required.\n\t// a space is a back-tick, a space, or a tab. If it is a back-tick, then there is no end-beam.\n\n\t// Line preprocessing: anything after a % is ignored (the double %% should have been taken care of before this)\n\t// Then, all leading and trailing spaces are ignored.\n\t// If there was a line continuation, the \\n was replaced by a \\r and the \\ was replaced by a space. This allows the construct\n\t// of having a header mid-line conceptually, but actually be at the start of the line. This is equivolent to putting the header in [ ].\n\n\t// TODO-PER: How to handle ! for line break?\n\t// TODO-PER: dots before bar, dots before slur\n\t// TODO-PER: U: redefinable symbols.\n\n\t// Ambiguous symbols:\n\t// \"[\" can be the start of a chord, the start of a header element or part of a bar line.\n\t// --- if it is immediately followed by \"|\", it is a bar line\n\t// --- if it is immediately followed by K: L: M: V: it is a header (note: there are other headers mentioned in the standard, but I'm not sure how they would be used.)\n\t// --- otherwise it is the beginning of a chord\n\t// \"(\" can be the start of a slur or a triplet\n\t// --- if it is followed by a number from 2-9, then it is a triplet\n\t// --- otherwise it is a slur\n\t// \"]\"\n\t// --- if there is a chord open, then this is the close\n\t// --- if it is after a [|, then it is an invisible bar line\n\t// --- otherwise, it is par of a bar\n\t// \".\" can be a bar modifier or a slur modifier, or a decoration\n\t// --- if it comes immediately before a bar, it is a bar modifier\n\t// --- if it comes immediately before a slur, it is a slur modifier\n\t// --- otherwise it is a decoration for the next note.\n\t// number:\n\t// --- if it is after a bar, with no space, it is an ending marker\n\t// --- if it is after a ( with no space, it is a triplet count\n\t// --- if it is after a pitch or octave or slash, then it is a duration\n\n\t// Unambiguous symbols (except inside quoted strings):\n\t// vertical-bar, colon: part of a bar\n\t// ABCDEFGabcdefg: pitch\n\t// xyzZ: rest\n\t// comma, prime: octave\n\t// close-paren: end-slur\n\t// hyphen: tie\n\t// tilde, v, u, bang, plus, THLMPSO: decoration\n\t// carat, underscore, equal: accidental\n\t// ampersand: time reset\n\t// open-curly, close-curly: grace notes\n\t// double-quote: chord symbol\n\t// less-than, greater-than, slash: duration\n\t// back-tick, space, tab: space\n\tvar nonDecorations = \"ABCDEFGabcdefgxyzZ[]|^_{\";\t// use this to prescreen so we don't have to look for a decoration at every note.\n\n\tvar parseRegularMusicLine = function(line) {\n\t\theader.resolveTempo();\n\t\t//multilineVars.havent_set_length = false;\t// To late to set this now.\n\t\tmultilineVars.is_in_header = false;\t// We should have gotten a key header by now, but just in case, this is definitely out of the header.\n\t\tvar i = 0;\n\t\tvar startOfLine = multilineVars.iChar;\n\t\t// see if there is nothing but a comment on this line. If so, just ignore it. A full line comment is optional white space followed by %\n\t\twhile (tokenizer.isWhiteSpace(line.charAt(i)) && i < line.length)\n\t\t\ti++;\n\t\tif (i === line.length || line.charAt(i) === '%')\n\t\t\treturn;\n\n\t\t// Start with the standard staff, clef and key symbols on each line\n\t\tvar delayStartNewLine = multilineVars.start_new_line;\n\t\tif (multilineVars.continueall === undefined)\n\t\t\tmultilineVars.start_new_line = true;\n\t\telse\n\t\t\tmultilineVars.start_new_line = false;\n\t\tvar tripletNotesLeft = 0;\n\n\t\t// See if the line starts with a header field\n\t\tvar retHeader = header.letter_to_body_header(line, i);\n\t\tif (retHeader[0] > 0) {\n\t\t\ti += retHeader[0];\n\t\t\tif (retHeader[1] === 'V')\n\t\t\t\tdelayStartNewLine = true; // fixes bug on this: c[V:2]d\n\t\t\t// TODO-PER: Handle inline headers\n\t\t}\n\t\tvar el = { };\n\n\t\tvar overlayLevel = 0;\n\t\twhile (i < line.length)\n\t\t{\n\t\t\tvar startI = i;\n\t\t\tif (line.charAt(i) === '%')\n\t\t\t\tbreak;\n\n\t\t\tvar retInlineHeader = header.letter_to_inline_header(line, i);\n\t\t\tif (retInlineHeader[0] > 0) {\n\t\t\t\t\ti += retInlineHeader[0];\n\t\t\t\t\tif (retInlineHeader[1] === 'V')\n\t\t\t\t\t\tdelayStartNewLine = true; // fixes bug on this: c[V:2]d\n\t\t\t\t\t// TODO-PER: Handle inline headers\n\t\t\t\t\t//multilineVars.start_new_line = false;\n\t\t\t} else {\n\t\t\t\t// Wait until here to actually start the line because we know we're past the inline statements.\n\t\t\t\tif (delayStartNewLine) {\n\t\t\t\t\tstartNewLine();\n\t\t\t\t\tdelayStartNewLine = false;\n\t\t\t\t}\n\n\t\t\t\t// We need to decide if the following characters are a bar-marking or a note-group.\n\t\t\t\t// Unfortunately, that is ambiguous. Both can contain chord symbols and decorations.\n\t\t\t\t// If there is a grace note either before or after the chord symbols and decorations, then it is definitely a note-group.\n\t\t\t\t// If there is a bar marker, it is definitely a bar-marking.\n\t\t\t\t// If there is either a core-note or chord, it is definitely a note-group.\n\t\t\t\t// So, loop while we find grace-notes, chords-symbols, or decorations. [It is an error to have more than one grace-note group in a row; the others can be multiple]\n\t\t\t\t// Then, if there is a grace-note, we know where to go.\n\t\t\t\t// Else see if we have a chord, core-note, slur, triplet, or bar.\n\n\t\t\t\tvar ret;\n\t\t\t\twhile (1) {\n\t\t\t\t\tret = tokenizer.eatWhiteSpace(line, i);\n\t\t\t\t\tif (ret > 0) {\n\t\t\t\t\t\ti += ret;\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 0 && line.charAt(i-1) === '\\x12') {\n\t\t\t\t\t\t// there is one case where a line continuation isn't the same as being on the same line, and that is if the next character after it is a header.\n\t\t\t\t\t\tret = header.letter_to_body_header(line, i);\n\t\t\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t\t\tif (ret[1] === 'V')\n\t\t\t\t\t\t\t\tstartNewLine(); // fixes bug on this: c\\\\nV:2]\\\\nd\n\t\t\t\t\t\t\t// TODO: insert header here\n\t\t\t\t\t\t\ti = ret[0];\n\t\t\t\t\t\t\tmultilineVars.start_new_line = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// gather all the grace notes, chord symbols and decorations\n\t\t\t\t\tret = letter_to_spacer(line, i);\n\t\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t\ti += ret[0];\n\t\t\t\t\t}\n\n\t\t\t\t\tret = letter_to_chord(line, i);\n\t\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t\t// There could be more than one chord here if they have different positions.\n\t\t\t\t\t\t// If two chords have the same position, then connect them with newline.\n\t\t\t\t\t\tif (!el.chord)\n\t\t\t\t\t\t\tel.chord = [];\n\t\t\t\t\t\tvar chordName = tokenizer.translateString(ret[1]);\n\t\t\t\t\t\tchordName = chordName.replace(/;/g, \"\\n\");\n\t\t\t\t\t\tvar addedChord = false;\n\t\t\t\t\t\tfor (var ci = 0; ci < el.chord.length; ci++) {\n\t\t\t\t\t\t\tif (el.chord[ci].position === ret[2]) {\n\t\t\t\t\t\t\t\taddedChord = true;\n\t\t\t\t\t\t\t\tel.chord[ci].name += \"\\n\" + chordName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (addedChord === false) {\n\t\t\t\t\t\t\tif (ret[2] === null && ret[3])\n\t\t\t\t\t\t\t\tel.chord.push({name: chordName, rel_position: ret[3]});\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tel.chord.push({name: chordName, position: ret[2]});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti += ret[0];\n\t\t\t\t\t\tvar ii = tokenizer.skipWhiteSpace(line.substring(i));\n\t\t\t\t\t\tif (ii > 0)\n\t\t\t\t\t\t\tel.force_end_beam_last = true;\n\t\t\t\t\t\ti += ii;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (nonDecorations.indexOf(line.charAt(i)) === -1)\n\t\t\t\t\t\t\tret = letter_to_accent(line, i);\n\t\t\t\t\t\telse ret = [ 0 ];\n\t\t\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t\t\tif (ret[1] === null) {\n\t\t\t\t\t\t\t\tif (i + 1 < line.length)\n\t\t\t\t\t\t\t\t\tstartNewLine();\t// There was a ! in the middle of the line. Start a new line if there is anything after it.\n\t\t\t\t\t\t\t} else if (ret[1].length > 0) {\n\t\t\t\t\t\t\t\tif (ret[1].indexOf(\"style=\") === 0) {\n\t\t\t\t\t\t\t\t\tel.style = ret[1].substr(6);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (el.decoration === undefined)\n\t\t\t\t\t\t\t\t\t\tel.decoration = [];\n\t\t\t\t\t\t\t\t\tel.decoration.push(ret[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti += ret[0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tret = letter_to_grace(line, i);\n\t\t\t\t\t\t\t// TODO-PER: Be sure there aren't already grace notes defined. That is an error.\n\t\t\t\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t\t\t\tel.gracenotes = ret[1];\n\t\t\t\t\t\t\t\ti += ret[0];\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tret = letter_to_bar(line, i);\n\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t// This is definitely a bar\n\t\t\t\t\toverlayLevel = 0;\n\t\t\t\t\tif (el.gracenotes !== undefined) {\n\t\t\t\t\t\t// Attach the grace note to an invisible note\n\t\t\t\t\t\tel.rest = { type: 'spacer' };\n\t\t\t\t\t\tel.duration = 0.125; // TODO-PER: I don't think the duration of this matters much, but figure out if it does.\n\t\t\t\t\t\tmultilineVars.addFormattingOptions(el, tune.formatting, 'note');\n\t\t\t\t\t\ttune.appendElement('note', startOfLine+i, startOfLine+i+ret[0], el);\n\t\t\t\t\t\tmultilineVars.measureNotEmpty = true;\n\t\t\t\t\t\tel = {};\n\t\t\t\t\t}\n\t\t\t\t\tvar bar = {type: ret[1]};\n\t\t\t\t\tif (bar.type.length === 0)\n\t\t\t\t\t\twarn(\"Unknown bar type\", line, i);\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (multilineVars.inEnding && bar.type !== 'bar_thin') {\n\t\t\t\t\t\t\tbar.endEnding = true;\n\t\t\t\t\t\t\tmultilineVars.inEnding = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ret[2]) {\n\t\t\t\t\t\t\tbar.startEnding = ret[2];\n\t\t\t\t\t\t\tif (multilineVars.inEnding)\n\t\t\t\t\t\t\t\tbar.endEnding = true;\n\t\t\t\t\t\t\tmultilineVars.inEnding = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (el.decoration !== undefined)\n\t\t\t\t\t\t\tbar.decoration = el.decoration;\n\t\t\t\t\t\tif (el.chord !== undefined)\n\t\t\t\t\t\t\tbar.chord = el.chord;\n\t\t\t\t\t\tif (bar.startEnding && multilineVars.barFirstEndingNum === undefined)\n\t\t\t\t\t\t\tmultilineVars.barFirstEndingNum = multilineVars.currBarNumber;\n\t\t\t\t\t\telse if (bar.startEnding && bar.endEnding && multilineVars.barFirstEndingNum)\n\t\t\t\t\t\t\tmultilineVars.currBarNumber = multilineVars.barFirstEndingNum;\n\t\t\t\t\t\telse if (bar.endEnding)\n\t\t\t\t\t\t\tmultilineVars.barFirstEndingNum = undefined;\n\t\t\t\t\t\tif (bar.type !== 'bar_invisible' && multilineVars.measureNotEmpty) {\n\t\t\t\t\t\t\tvar isFirstVoice = multilineVars.currentVoice === undefined || (multilineVars.currentVoice.staffNum ===  0 && multilineVars.currentVoice.index ===  0);\n\t\t\t\t\t\t\tif (isFirstVoice) {\n\t\t\t\t\t\t\t\tmultilineVars.currBarNumber++;\n\t\t\t\t\t\t\t\tif (multilineVars.barNumbers && multilineVars.currBarNumber % multilineVars.barNumbers === 0)\n\t\t\t\t\t\t\t\t\tbar.barNumber = multilineVars.currBarNumber;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmultilineVars.addFormattingOptions(el, tune.formatting, 'bar');\n\t\t\t\t\t\ttune.appendElement('bar', startOfLine+i, startOfLine+i+ret[0], bar);\n\t\t\t\t\t\tmultilineVars.measureNotEmpty = false;\n\t\t\t\t\t\tel = {};\n\t\t\t\t\t}\n\t\t\t\t\ti += ret[0];\n\t\t\t\t\tvar cv = multilineVars.currentVoice ? multilineVars.currentVoice.staffNum + '-' + multilineVars.currentVoice.index : 'ONLY';\n\t\t\t\t\t// if (multilineVars.lineBreaks) {\n\t\t\t\t\t// \tif (!multilineVars.barCounter[cv])\n\t\t\t\t\t// \t\tmultilineVars.barCounter[cv] = 0;\n\t\t\t\t\t// \tvar breakNow = multilineVars.lineBreaks[''+multilineVars.barCounter[cv]];\n\t\t\t\t\t// \tmultilineVars.barCounter[cv]++;\n\t\t\t\t\t// \tif (breakNow)\n\t\t\t\t\t// \t\tstartNewLine();\n\t\t\t\t\t// }\n\t\t\t\t} else if (line[i] === '&') {\t// backtrack to beginning of measure\n\t\t\t\t\tret = letter_to_overlay(line, i);\n\t\t\t\t\tif (ret[0] > 0) {\n\t\t\t\t\t\ttune.appendElement('overlay', startOfLine, startOfLine+1, {});\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\toverlayLevel++;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// This is definitely a note group\n\t\t\t\t\t//\n\t\t\t\t\t// Look for as many open slurs and triplets as there are. (Note: only the first triplet is valid.)\n\t\t\t\t\tret = letter_to_open_slurs_and_triplets(line, i);\n\t\t\t\t\tif (ret.consumed > 0) {\n\t\t\t\t\t\tif (ret.startSlur !== undefined)\n\t\t\t\t\t\t\tel.startSlur = ret.startSlur;\n\t\t\t\t\t\tif (ret.triplet !== undefined) {\n\t\t\t\t\t\t\tif (tripletNotesLeft > 0)\n\t\t\t\t\t\t\t\twarn(\"Can't nest triplets\", line, i);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tel.startTriplet = ret.triplet;\n\t\t\t\t\t\t\t\tel.tripletMultiplier = ret.tripletQ / ret.triplet;\n\t\t\t\t\t\t\t\ttripletNotesLeft = ret.num_notes === undefined ? ret.triplet : ret.num_notes;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti += ret.consumed;\n\t\t\t\t\t}\n\n\t\t\t\t\t// handle chords.\n\t\t\t\t\tif (line.charAt(i) === '[') {\n\t\t\t\t\t\tvar chordStartChar = i;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tvar chordDuration = null;\n\t\t\t\t\t\tvar rememberEndBeam = false;\n\n\t\t\t\t\t\tvar done = false;\n\t\t\t\t\t\twhile (!done) {\n\t\t\t\t\t\t\tvar accent = letter_to_accent(line, i);\n\t\t\t\t\t\t\tif (accent[0] > 0) {\n\t\t\t\t\t\t\t\ti += accent[0];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar chordNote = getCoreNote(line, i, {}, false);\n\t\t\t\t\t\t\tif (chordNote !== null) {\n\t\t\t\t\t\t\t\tif (accent[0] > 0) { // If we found a decoration above, it modifies the entire chord. \"style\" is handled below.\n\t\t\t\t\t\t\t\t\tif (accent[1].indexOf(\"style=\") !== 0) {\n\t\t\t\t\t\t\t\t\t\tif (el.decoration === undefined)\n\t\t\t\t\t\t\t\t\t\t\tel.decoration = [];\n\t\t\t\t\t\t\t\t\t\tel.decoration.push(accent[1]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (chordNote.end_beam) {\n\t\t\t\t\t\t\t\t\tel.end_beam = true;\n\t\t\t\t\t\t\t\t\tdelete chordNote.end_beam;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (el.pitches === undefined) {\n\t\t\t\t\t\t\t\t\tel.duration = chordNote.duration;\n\t\t\t\t\t\t\t\t\tel.pitches = [ chordNote ];\n\t\t\t\t\t\t\t\t} else\t// Just ignore the note lengths of all but the first note. The standard isn't clear here, but this seems less confusing.\n\t\t\t\t\t\t\t\t\tel.pitches.push(chordNote);\n\t\t\t\t\t\t\t\tdelete chordNote.duration;\n\t\t\t\t\t\t\t\tif (accent[0] > 0) { // If we found a style above, it modifies the individual pitch, not the entire chord.\n\t\t\t\t\t\t\t\t\tif (accent[1].indexOf(\"style=\") === 0) {\n\t\t\t\t\t\t\t\t\t\tel.pitches[el.pitches.length-1].style = accent[1].substr(6);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (multilineVars.inTieChord[el.pitches.length]) {\n\t\t\t\t\t\t\t\t\tchordNote.endTie = true;\n\t\t\t\t\t\t\t\t\tmultilineVars.inTieChord[el.pitches.length] = undefined;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (chordNote.startTie)\n\t\t\t\t\t\t\t\t\tmultilineVars.inTieChord[el.pitches.length] = true;\n\n\t\t\t\t\t\t\t\ti  = chordNote.endChar;\n\t\t\t\t\t\t\t\tdelete chordNote.endChar;\n\t\t\t\t\t\t\t} else if (line.charAt(i) === ' ') {\n\t\t\t\t\t\t\t\t// Spaces are not allowed in chords, but we can recover from it by ignoring it.\n\t\t\t\t\t\t\t\twarn(\"Spaces are not allowed in chords\", line, i);\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (i < line.length && line.charAt(i) === ']') {\n\t\t\t\t\t\t\t\t\t// consume the close bracket\n\t\t\t\t\t\t\t\t\ti++;\n\n\t\t\t\t\t\t\t\t\tif (multilineVars.next_note_duration !== 0) {\n\t\t\t\t\t\t\t\t\t\tel.duration = el.duration * multilineVars.next_note_duration;\n\t\t\t\t\t\t\t\t\t\tmultilineVars.next_note_duration = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (isInTie(multilineVars,  overlayLevel, el)) {\n\t\t\t\t\t\t\t\t\t\tparseCommon.each(el.pitches, function(pitch) { pitch.endTie = true; });\n\t\t\t\t\t\t\t\t\t\tsetIsInTie(multilineVars,  overlayLevel, false);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (tripletNotesLeft > 0) {\n\t\t\t\t\t\t\t\t\t\ttripletNotesLeft--;\n\t\t\t\t\t\t\t\t\t\tif (tripletNotesLeft === 0) {\n\t\t\t\t\t\t\t\t\t\t\tel.endTriplet = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar postChordDone = false;\n\t\t\t\t\t\t\t\t\twhile (i < line.length && !postChordDone) {\n\t\t\t\t\t\t\t\t\t\tswitch (line.charAt(i)) {\n\t\t\t\t\t\t\t\t\t\t\tcase ' ':\n\t\t\t\t\t\t\t\t\t\t\tcase '\\t':\n\t\t\t\t\t\t\t\t\t\t\t\taddEndBeam(el);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase ')':\n\t\t\t\t\t\t\t\t\t\t\t\tif (el.endSlur === undefined) el.endSlur = 1; else el.endSlur++;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\t\t\t\t\t\tparseCommon.each(el.pitches, function(pitch) { pitch.startTie = {}; });\n\t\t\t\t\t\t\t\t\t\t\t\tsetIsInTie(multilineVars,  overlayLevel, true);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\t\t\t\t\t\tvar br2 = getBrokenRhythm(line, i);\n\t\t\t\t\t\t\t\t\t\t\t\ti += br2[0] - 1;\t// index gets incremented below, so we'll let that happen\n\t\t\t\t\t\t\t\t\t\t\t\tmultilineVars.next_note_duration = br2[2];\n\t\t\t\t\t\t\t\t\t\t\t\tif (chordDuration)\n\t\t\t\t\t\t\t\t\t\t\t\t\tchordDuration = chordDuration * br2[1];\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\tchordDuration = br2[1];\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tcase '1':\n\t\t\t\t\t\t\t\t\t\t\tcase '2':\n\t\t\t\t\t\t\t\t\t\t\tcase '3':\n\t\t\t\t\t\t\t\t\t\t\tcase '4':\n\t\t\t\t\t\t\t\t\t\t\tcase '5':\n\t\t\t\t\t\t\t\t\t\t\tcase '6':\n\t\t\t\t\t\t\t\t\t\t\tcase '7':\n\t\t\t\t\t\t\t\t\t\t\tcase '8':\n\t\t\t\t\t\t\t\t\t\t\tcase '9':\n\t\t\t\t\t\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\t\t\t\t\t\tvar fraction = tokenizer.getFraction(line, i);\n\t\t\t\t\t\t\t\t\t\t\t\tchordDuration = fraction.value;\n\t\t\t\t\t\t\t\t\t\t\t\ti = fraction.index;\n\t\t\t\t\t\t\t\t\t\t\t\tif (line.charAt(i) === ' ')\n\t\t\t\t\t\t\t\t\t\t\t\t\trememberEndBeam = true;\n\t\t\t\t\t\t\t\t\t\t\t\tif (line.charAt(i) === '-' || line.charAt(i) === ')' || line.charAt(i) === ' ' || line.charAt(i) === '<' || line.charAt(i) === '>')\n\t\t\t\t\t\t\t\t\t\t\t\t\ti--; // Subtracting one because one is automatically added below\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\tpostChordDone = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\tpostChordDone = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!postChordDone) {\n\t\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\twarn(\"Expected ']' to end the chords\", line, i);\n\n\t\t\t\t\t\t\t\tif (el.pitches !== undefined) {\n\t\t\t\t\t\t\t\t\tif (chordDuration !== null) {\n\t\t\t\t\t\t\t\t\t\tel.duration = el.duration * chordDuration;\n\t\t\t\t\t\t\t\t\t\tif (rememberEndBeam)\n\t\t\t\t\t\t\t\t\t\t\taddEndBeam(el);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tmultilineVars.addFormattingOptions(el, tune.formatting, 'note');\n\t\t\t\t\t\t\t\t\ttune.appendElement('note', startOfLine+chordStartChar, startOfLine+i, el);\n\t\t\t\t\t\t\t\t\tmultilineVars.measureNotEmpty = true;\n\t\t\t\t\t\t\t\t\tel = {};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Single pitch\n\t\t\t\t\t\tvar el2 = {};\n\t\t\t\t\t\tvar core = getCoreNote(line, i, el2, true);\n\t\t\t\t\t\tif (el2.endTie !== undefined) setIsInTie(multilineVars,  overlayLevel, true);\n\t\t\t\t\t\tif (core !== null) {\n\t\t\t\t\t\t\tif (core.pitch !== undefined) {\n\t\t\t\t\t\t\t\tel.pitches = [ { } ];\n\t\t\t\t\t\t\t\t// TODO-PER: straighten this out so there is not so much copying: getCoreNote shouldn't change e'\n\t\t\t\t\t\t\t\tif (core.accidental !== undefined) el.pitches[0].accidental = core.accidental;\n\t\t\t\t\t\t\t\tel.pitches[0].pitch = core.pitch;\n\t\t\t\t\t\t\t\tif (core.midipitch)\n\t\t\t\t\t\t\t\t\tel.pitches[0].midipitch = core.midipitch;\n\t\t\t\t\t\t\t\tif (core.endSlur !== undefined) el.pitches[0].endSlur = core.endSlur;\n\t\t\t\t\t\t\t\tif (core.endTie !== undefined) el.pitches[0].endTie = core.endTie;\n\t\t\t\t\t\t\t\tif (core.startSlur !== undefined) el.pitches[0].startSlur = core.startSlur;\n\t\t\t\t\t\t\t\tif (el.startSlur !== undefined) el.pitches[0].startSlur = el.startSlur;\n\t\t\t\t\t\t\t\tif (core.startTie !== undefined) el.pitches[0].startTie = core.startTie;\n\t\t\t\t\t\t\t\tif (el.startTie !== undefined) el.pitches[0].startTie = el.startTie;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tel.rest = core.rest;\n\t\t\t\t\t\t\t\tif (core.endSlur !== undefined) el.endSlur = core.endSlur;\n\t\t\t\t\t\t\t\tif (core.endTie !== undefined) el.rest.endTie = core.endTie;\n\t\t\t\t\t\t\t\tif (core.startSlur !== undefined) el.startSlur = core.startSlur;\n\t\t\t\t\t\t\t\tif (core.startTie !== undefined) el.rest.startTie = core.startTie;\n\t\t\t\t\t\t\t\tif (el.startTie !== undefined) el.rest.startTie = el.startTie;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (core.chord !== undefined) el.chord = core.chord;\n\t\t\t\t\t\t\tif (core.duration !== undefined) el.duration = core.duration;\n\t\t\t\t\t\t\tif (core.decoration !== undefined) el.decoration = core.decoration;\n\t\t\t\t\t\t\tif (core.graceNotes !== undefined) el.graceNotes = core.graceNotes;\n\t\t\t\t\t\t\tdelete el.startSlur;\n\t\t\t\t\t\t\tif (isInTie(multilineVars,  overlayLevel, el)) {\n\t\t\t\t\t\t\t\tif (el.pitches !== undefined) {\n\t\t\t\t\t\t\t\t\tel.pitches[0].endTie = true;\n\t\t\t\t\t\t\t\t} else if (el.rest.type !== 'spacer') {\n\t\t\t\t\t\t\t\t\tel.rest.endTie = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsetIsInTie(multilineVars,  overlayLevel, false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (core.startTie || el.startTie)\n\t\t\t\t\t\t\t\tsetIsInTie(multilineVars,  overlayLevel, true);\n\t\t\t\t\t\t\ti  = core.endChar;\n\n\t\t\t\t\t\t\tif (tripletNotesLeft > 0) {\n\t\t\t\t\t\t\t\ttripletNotesLeft--;\n\t\t\t\t\t\t\t\tif (tripletNotesLeft === 0) {\n\t\t\t\t\t\t\t\t\tel.endTriplet = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (core.end_beam)\n\t\t\t\t\t\t\t\taddEndBeam(el);\n\n\t\t\t\t\t\t\t// If there is a whole rest, then it should be the duration of the measure, not it's own duration. We need to special case it.\n\t\t\t\t\t\t\t// If the time signature length is greater than 4/4, though, then a whole rest has no special treatment.\n\t\t\t\t\t\t\tif (el.rest && el.rest.type === 'rest' && el.duration === 1 && durationOfMeasure(multilineVars) <= 1) {\n\t\t\t\t\t\t\t\tel.rest.type = 'whole';\n\n\t\t\t\t\t\t\t\tel.duration = durationOfMeasure(multilineVars);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmultilineVars.addFormattingOptions(el, tune.formatting, 'note');\n\t\t\t\t\t\t\ttune.appendElement('note', startOfLine+startI, startOfLine+i, el);\n\t\t\t\t\t\t\tmultilineVars.measureNotEmpty = true;\n\t\t\t\t\t\t\tel = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i === startI) {\t// don't know what this is, so ignore it.\n\t\t\t\t\t\tif (line.charAt(i) !== ' ' && line.charAt(i) !== '`')\n\t\t\t\t\t\t\twarn(\"Unknown character ignored\", line, i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar isInTie = function(multilineVars, overlayLevel, el) {\n\t\tif (multilineVars.inTie[overlayLevel] === undefined)\n\t\t\treturn false;\n\t\t// If this is single voice music then the voice index isn't set, so we use the first voice.\n\t\tvar voiceIndex = multilineVars.currentVoice ? multilineVars.currentVoice.index : 0;\n\t\tif (multilineVars.inTie[overlayLevel][voiceIndex]) {\n\t\t\tif (el.pitches !== undefined || el.rest.type !== 'spacer')\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tvar setIsInTie =function(multilineVars, overlayLevel, value) {\n\t\t// If this is single voice music then the voice index isn't set, so we use the first voice.\n\t\tvar voiceIndex = multilineVars.currentVoice ? multilineVars.currentVoice.index : 0;\n\t\tif (multilineVars.inTie[overlayLevel] === undefined)\n\t\t\tmultilineVars.inTie[overlayLevel] = [];\n\t\tmultilineVars.inTie[overlayLevel][voiceIndex] = value;\n\t};\n\n\tvar parseLine = function(line) {\n\t\tvar ret = header.parseHeader(line);\n\t\tif (ret.regular)\n\t\t\tparseRegularMusicLine(ret.str);\n\t\tif (ret.newline)\n\t\t\tstartNewLine();\n\t\tif (ret.words)\n\t\t\taddWords(tune.getCurrentVoice(), line.substring(2));\n\t\tif (ret.symbols)\n\t\t\taddSymbols(tune.getCurrentVoice(), line.substring(2));\n\t\tif (ret.recurse)\n\t\t\tparseLine(ret.str);\n\t};\n\n\tfunction appendLastMeasure(voice, nextVoice) {\n\t\tvoice.push({\n\t\t\tel_type: 'hint'\n\t\t});\n\t\tfor (var i = 0; i < nextVoice.length; i++) {\n\t\t\tvar element = nextVoice[i];\n\t\t\tvar hint = parseCommon.clone(element);\n\t\t\tvoice.push(hint);\n\t\t\tif (element.el_type === 'bar')\n\t\t\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction addHintMeasure(staff, nextStaff) {\n\t\tfor (var i = 0; i < staff.length; i++) {\n\t\t\tvar stave = staff[i];\n\t\t\tvar nextStave = nextStaff[i];\n\t\t\tif (nextStave) { // Be sure there is the same number of staves on the next line.\n\t\t\t\tfor (var j = 0; j < nextStave.voices.length; j++) {\n\t\t\t\t\tvar nextVoice = nextStave.voices[j];\n\t\t\t\t\tvar voice = stave.voices[j];\n\t\t\t\t\tif (voice) { // Be sure there are the same number of voices on the previous line.\n\t\t\t\t\t\tappendLastMeasure(voice, nextVoice);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addHintMeasures() {\n\t\tfor (var i = 0; i < tune.lines.length; i++) {\n\t\t\tvar line = tune.lines[i].staff;\n\t\t\tif (line) {\n\t\t\t\tvar j = i+1;\n\t\t\t\twhile (j < tune.lines.length && tune.lines[j].staff === undefined)\n\t\t\t\t\tj++;\n\t\t\t\tif (j < tune.lines.length) {\n\t\t\t\t\tvar nextLine = tune.lines[j].staff;\n\t\t\t\t\taddHintMeasure(line, nextLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.parse = function(strTune, switches, startPos) {\n\t\t// the switches are optional and cause a difference in the way the tune is parsed.\n\t\t// switches.header_only : stop parsing when the header is finished\n\t\t// switches.stop_on_warning : stop at the first warning encountered.\n\t\t// switches.print: format for the page instead of the browser.\n\t\t// switches.format: a hash of the desired formatting commands.\n\t\t// switches.hint_measures: put the next measure at the end of the current line.\n\t\t// switches.transpose: change the key signature, chords, and notes by a number of half-steps.\n\t\tif (!switches) switches = {};\n\t\tif (!startPos) startPos = 0;\n\t\ttune.reset();\n\t\tif (switches.print)\n\t\t\ttune.media = 'print';\n\t\tmultilineVars.reset();\n\t\tmultilineVars.iChar = startPos;\n\t\tif (switches.visualTranspose) {\n\t\t\tmultilineVars.globalTranspose = parseInt(switches.visualTranspose);\n\t\t\tif (multilineVars.globalTranspose === 0)\n\t\t\t\tmultilineVars.globalTranspose = undefined;\n\t\t} else\n\t\t\tmultilineVars.globalTranspose = undefined;\n\t\tif (switches.lineBreaks) {\n\t\t\t// change the format of the the line breaks for easy testing.\n\t\t\t// The line break numbers are 0-based and they reflect the last measure of the current line.\n\t\t\tmultilineVars.lineBreaks = {};\n\t\t\t//multilineVars.continueall = true;\n\t\t\tfor (var i = 0; i < switches.lineBreaks.length; i++)\n\t\t\t\tmultilineVars.lineBreaks[''+(switches.lineBreaks[i]+1)] = true; // Add 1 so that the line break is the first measure of the next line.\n\t\t}\n\t\theader.reset(tokenizer, warn, multilineVars, tune);\n\n\t\t// Take care of whatever line endings come our way\n\t\tstrTune = parseCommon.gsub(strTune, '\\r\\n', '\\n');\n\t\tstrTune = parseCommon.gsub(strTune, '\\r', '\\n');\n\t\tstrTune += '\\n';\t// Tacked on temporarily to make the last line continuation work\n\t\tstrTune = strTune.replace(/\\n\\\\.*\\n/g, \"\\n\");\t// get rid of latex commands.\n\t\tvar continuationReplacement = function(all, backslash, comment){\n\t\t\tvar spaces = \"                                                                                                                                                                                                     \";\n\t\t\tvar padding = comment ? spaces.substring(0, comment.length) : \"\";\n\t\t\treturn backslash + \" \\x12\" + padding;\n\t\t};\n\t\tstrTune = strTune.replace(/\\\\([ \\t]*)(%.*)*\\n/g, continuationReplacement);\t// take care of line continuations right away, but keep the same number of characters\n\t\tvar lines = strTune.split('\\n');\n\t\tif (parseCommon.last(lines).length === 0)\t// remove the blank line we added above.\n\t\t\tlines.pop();\n\t\ttry {\n\t\t\tif (switches.format) {\n\t\t\t\tparseDirective.globalFormatting(switches.format);\n\t\t\t}\n\t\t\tparseCommon.each(lines,  function(line) {\n\t\t\t\tif (switches.header_only && multilineVars.is_in_header === false)\n\t\t\t\t\tthrow \"normal_abort\";\n\t\t\t\tif (switches.stop_on_warning && multilineVars.warnings)\n\t\t\t\t\tthrow \"normal_abort\";\n\t\t\t\tif (multilineVars.is_in_history) {\n\t\t\t\t\tif (line.charAt(1) === ':') {\n\t\t\t\t\t\tmultilineVars.is_in_history = false;\n\t\t\t\t\t\tparseLine(line);\n\t\t\t\t\t} else\n\t\t\t\t\t\ttune.addMetaText(\"history\", tokenizer.translateString(tokenizer.stripComment(line)));\n\t\t\t\t} else if (multilineVars.inTextBlock) {\n\t\t\t\t\tif (parseCommon.startsWith(line, \"%%endtext\")) {\n\t\t\t\t\t\t//tune.addMetaText(\"textBlock\", multilineVars.textBlock);\n\t\t\t\t\t\ttune.addText(multilineVars.textBlock);\n\t\t\t\t\t\tmultilineVars.inTextBlock = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (parseCommon.startsWith(line, \"%%\"))\n\t\t\t\t\t\t\tmultilineVars.textBlock += ' ' + line.substring(2);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmultilineVars.textBlock += ' ' + line;\n\t\t\t\t\t}\n\t\t\t\t} else if (multilineVars.inPsBlock) {\n\t\t\t\t\tif (parseCommon.startsWith(line, \"%%endps\")) {\n\t\t\t\t\t\t// Just ignore postscript\n\t\t\t\t\t\tmultilineVars.inPsBlock = false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tmultilineVars.textBlock += ' ' + line;\n\t\t\t\t} else\n\t\t\t\t\tparseLine(line);\n\t\t\t\tmultilineVars.iChar += line.length + 1;\n\t\t\t});\n\t\t\tvar ph = 11*72;\n\t\t\tvar pl = 8.5*72;\n\t\t\tswitch (multilineVars.papersize) {\n\t\t\t\t//case \"letter\": ph = 11*72; pl = 8.5*72; break;\n\t\t\t\tcase \"legal\": ph = 14*72; pl = 8.5*72; break;\n\t\t\t\tcase \"A4\": ph = 11.7*72; pl = 8.3*72; break;\n\t\t\t}\n\t\t\tif (multilineVars.landscape) {\n\t\t\t\tvar x = ph;\n\t\t\t\tph = pl;\n\t\t\t\tpl = x;\n\t\t\t}\n\t\t\tmultilineVars.openSlurs = tune.cleanUp(pl, ph, multilineVars.barsperstaff, multilineVars.staffnonote, multilineVars.openSlurs);\n\t\t} catch (err) {\n\t\t\tif (err !== \"normal_abort\")\n\t\t\t\tthrow err;\n\t\t}\n\t\tif (switches.hint_measures) {\n\t\t\taddHintMeasures();\n\t\t}\n\n\t\twrap.wrapLines(tune, multilineVars.lineBreaks);\n\t};\n};\n\nmodule.exports = Parse;\n"]},"metadata":{},"sourceType":"script"}