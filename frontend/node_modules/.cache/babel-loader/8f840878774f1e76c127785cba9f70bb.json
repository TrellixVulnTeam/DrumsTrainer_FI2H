{"ast":null,"code":"//    abc_tunebook.js: splits a string representing ABC Music Notation into individual tunes.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*global document */\n\n/*global window, ABCJS, console */\nvar parseCommon = require('../parse/abc_common');\n\nvar Parse = require('../parse/abc_parse');\n\nvar tunebook = {};\n\n(function () {\n  \"use strict\";\n\n  tunebook.numberOfTunes = function (abc) {\n    var tunes = abc.split(\"\\nX:\");\n    var num = tunes.length;\n    if (num === 0) num = 1;\n    return num;\n  };\n\n  var TuneBook = tunebook.TuneBook = function (book) {\n    var This = this;\n    var directives = \"\";\n    book = parseCommon.strip(book);\n    var tunes = book.split(\"\\nX:\");\n\n    for (var i = 1; i < tunes.length; i++) // Put back the X: that we lost when splitting the tunes.\n    tunes[i] = \"X:\" + tunes[i]; // Keep track of the character position each tune starts with.\n\n\n    var pos = 0;\n    This.tunes = [];\n    parseCommon.each(tunes, function (tune) {\n      This.tunes.push({\n        abc: tune,\n        startPos: pos\n      });\n      pos += tune.length + 1; // We also lost a newline when splitting, so count that.\n    });\n\n    if (This.tunes.length > 1 && !parseCommon.startsWith(This.tunes[0].abc, 'X:')) {\n      // If there is only one tune, the X: might be missing, otherwise assume the top of the file is \"intertune\"\n      // There could be file-wide directives in this, if so, we need to insert it into each tune. We can probably get away with\n      // just looking for file-wide directives here (before the first tune) and inserting them at the bottom of each tune, since\n      // the tune is parsed all at once. The directives will be seen before the engraver begins processing.\n      var dir = This.tunes.shift();\n      var arrDir = dir.abc.split('\\n');\n      parseCommon.each(arrDir, function (line) {\n        if (parseCommon.startsWith(line, '%%')) directives += line + '\\n';\n      });\n    }\n\n    This.header = directives; // Now, the tune ends at a blank line, so truncate it if needed. There may be \"intertune\" stuff.\n\n    parseCommon.each(This.tunes, function (tune) {\n      var end = tune.abc.indexOf('\\n\\n');\n      if (end > 0) tune.abc = tune.abc.substring(0, end);\n      tune.pure = tune.abc;\n      tune.abc = directives + tune.abc; // for the user's convenience, parse and store the title separately. The title is between the first T: and the next \\n\n\n      var title = tune.pure.split(\"T:\");\n\n      if (title.length > 1) {\n        title = title[1].split(\"\\n\");\n        tune.title = title[0].replace(/^\\s+|\\s+$/g, '');\n      } else tune.title = \"\"; // for the user's convenience, parse and store the id separately. The id is between the first X: and the next \\n\n\n\n      var id = tune.pure.substring(2, tune.pure.indexOf(\"\\n\"));\n      tune.id = id.replace(/^\\s+|\\s+$/g, '');\n    });\n  };\n\n  TuneBook.prototype.getTuneById = function (id) {\n    for (var i = 0; i < this.tunes.length; i++) {\n      if (this.tunes[i].id === '' + id) return this.tunes[i];\n    }\n\n    return null;\n  };\n\n  TuneBook.prototype.getTuneByTitle = function (title) {\n    for (var i = 0; i < this.tunes.length; i++) {\n      if (this.tunes[i].title === title) return this.tunes[i];\n    }\n\n    return null;\n  };\n\n  tunebook.parseOnly = function (abc, params) {\n    var tunes = [];\n    var numTunes = tunebook.numberOfTunes(abc); // this just needs to be passed in because this tells the engine how many tunes to process.\n\n    var output = [];\n\n    for (var i = 0; i < numTunes; i++) {\n      output.push(1);\n    }\n\n    function callback() {// Don't need to do anything with the parsed tunes.\n    }\n\n    return tunebook.renderEngine(callback, output, abc, params);\n  };\n\n  tunebook.renderEngine = function (callback, output, abc, params) {\n    var ret = [];\n\n    var isArray = function (testObject) {\n      return testObject && !testObject.propertyIsEnumerable('length') && typeof testObject === 'object' && typeof testObject.length === 'number';\n    }; // check and normalize input parameters\n\n\n    if (output === undefined || abc === undefined) return;\n    if (!isArray(output)) output = [output];\n    if (params === undefined) params = {};\n    var currentTune = params.startingTune ? parseInt(params.startingTune, 10) : 0; // parse the abc string\n\n    var book = new TuneBook(abc);\n    var abcParser = new Parse(); // output each tune, if it exists. Otherwise clear the div.\n\n    for (var i = 0; i < output.length; i++) {\n      var div = output[i];\n\n      if (div === \"*\") {// This is for \"headless\" rendering: doing the work but not showing the svg.\n      } else if (typeof div === \"string\") div = document.getElementById(div);\n\n      if (div) {\n        if (currentTune >= 0 && currentTune < book.tunes.length) {\n          abcParser.parse(book.tunes[currentTune].abc, params, book.tunes[currentTune].startPos - book.header.length);\n          var tune = abcParser.getTune();\n          var override = callback(div, tune, i, book.tunes[currentTune].abc);\n          ret.push(override ? override : tune);\n        } else {\n          if (div.hasOwnProperty('innerHTML')) div.innerHTML = \"\";\n        }\n      }\n\n      currentTune++;\n    }\n\n    return ret;\n  };\n\n  function flattenTune(tuneObj) {\n    // This removes the line breaks and removes the non-music lines.\n    var staves = [];\n\n    for (var j = 0; j < tuneObj.lines.length; j++) {\n      var line = tuneObj.lines[j];\n\n      if (line.staff) {\n        for (var k = 0; k < line.staff.length; k++) {\n          var staff = line.staff[k];\n          if (!staves[k]) staves[k] = staff;else {\n            for (var i = 0; i < staff.voices.length; i++) {\n              if (staves[k].voices[i]) staves[k].voices[i] = staves[k].voices[i].concat(staff.voices[i]); // TODO-PER: If staves[k].voices[i] doesn't exist, that means a voice appeared in the middle of the tune. That isn't handled yet.\n            }\n          }\n        }\n      }\n    }\n\n    return staves;\n  }\n\n  function measuresParser(staff, tune) {\n    var voices = [];\n    var lastChord = null;\n    var measureStartChord = null;\n    var fragStart = null;\n    var hasNotes = false;\n\n    for (var i = 0; i < staff.voices.length; i++) {\n      var voice = staff.voices[i];\n      voices.push([]);\n\n      for (var j = 0; j < voice.length; j++) {\n        var elem = voice[j];\n\n        if (fragStart === null && elem.startChar >= 0) {\n          fragStart = elem.startChar;\n          if (elem.chord === undefined) measureStartChord = lastChord;else measureStartChord = null;\n        }\n\n        if (elem.chord) lastChord = elem;\n\n        if (elem.el_type === 'bar') {\n          if (hasNotes) {\n            var frag = tune.abc.substring(fragStart, elem.endChar);\n            var measure = {\n              abc: frag\n            };\n            lastChord = measureStartChord && measureStartChord.chord && measureStartChord.chord.length > 0 ? measureStartChord.chord[0].name : null;\n            if (lastChord) measure.lastChord = lastChord;\n            if (elem.startEnding) measure.startEnding = elem.startEnding;\n            if (elem.endEnding) measure.endEnding = elem.endEnding;\n            voices[i].push(measure);\n            fragStart = null;\n            hasNotes = false;\n          }\n        } else if (elem.el_type === 'note') {\n          hasNotes = true;\n        }\n      }\n    }\n\n    return voices;\n  }\n\n  tunebook.extractMeasures = function (abc) {\n    var tunes = [];\n    var book = new TuneBook(abc);\n\n    for (var i = 0; i < book.tunes.length; i++) {\n      var tune = book.tunes[i];\n      var arr = tune.abc.split(\"K:\");\n      var arr2 = arr[1].split(\"\\n\");\n      var header = arr[0] + \"K:\" + arr2[0] + \"\\n\";\n      var lastChord = null;\n      var measureStartChord = null;\n      var fragStart = null;\n      var measures = [];\n      var hasNotes = false;\n      var tuneObj = tunebook.parseOnly(tune.abc)[0];\n      var hasPickup = tuneObj.getPickupLength() > 0; // var staves = flattenTune(tuneObj);\n      // for (var s = 0; s < staves.length; s++) {\n      // \tvar voices = measuresParser(staves[s], tune);\n      // \tif (s === 0)\n      // \t\tmeasures = voices;\n      // \telse {\n      // \t\tfor (var ss = 0; ss < voices.length; ss++) {\n      // \t\t\tvar voice = voices[ss];\n      // \t\t\tif (measures.length <= ss)\n      // \t\t\t\tmeasures.push([]);\n      // \t\t\tvar measureVoice = measures[ss];\n      // \t\t\tfor (var sss = 0; sss < voice.length; sss++) {\n      // \t\t\t\tif (measureVoice.length > sss)\n      // \t\t\t\t\tmeasureVoice[sss].abc += \"\\n\" + voice[sss].abc;\n      // \t\t\t\telse\n      // \t\t\t\t\tmeasures.push(voice[sss]);\n      // \t\t\t}\n      // \t\t}\n      // \t}\n      // \tconsole.log(voices);\n      // }\n      // measures = measures[0];\n\n      for (var j = 0; j < tuneObj.lines.length; j++) {\n        var line = tuneObj.lines[j];\n\n        if (line.staff) {\n          for (var k = 0; k < 1\n          /*line.staff.length*/\n          ; k++) {\n            var staff = line.staff[k];\n\n            for (var kk = 0; kk < 1\n            /*staff.voices.length*/\n            ; kk++) {\n              var voice = staff.voices[kk];\n\n              for (var kkk = 0; kkk < voice.length; kkk++) {\n                var elem = voice[kkk];\n\n                if (fragStart === null && elem.startChar >= 0) {\n                  fragStart = elem.startChar;\n                  if (elem.chord === undefined) measureStartChord = lastChord;else measureStartChord = null;\n                }\n\n                if (elem.chord) lastChord = elem;\n\n                if (elem.el_type === 'bar') {\n                  if (hasNotes) {\n                    var frag = tune.abc.substring(fragStart, elem.endChar);\n                    var measure = {\n                      abc: frag\n                    };\n                    lastChord = measureStartChord && measureStartChord.chord && measureStartChord.chord.length > 0 ? measureStartChord.chord[0].name : null;\n                    if (lastChord) measure.lastChord = lastChord;\n                    if (elem.startEnding) measure.startEnding = elem.startEnding;\n                    if (elem.endEnding) measure.endEnding = elem.endEnding;\n                    measures.push(measure);\n                    fragStart = null;\n                    hasNotes = false;\n                  }\n                } else if (elem.el_type === 'note') {\n                  hasNotes = true;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      tunes.push({\n        header: header,\n        measures: measures,\n        hasPickup: hasPickup\n      });\n    }\n\n    return tunes;\n  };\n})();\n\nmodule.exports = tunebook;","map":{"version":3,"sources":["/home/elad/Desktop/Repos/drums-trainer/frontend/node_modules/react-sheet-music/node_modules/abcjs/src/api/abc_tunebook.js"],"names":["parseCommon","require","Parse","tunebook","numberOfTunes","abc","tunes","split","num","length","TuneBook","book","This","directives","strip","i","pos","each","tune","push","startPos","startsWith","dir","shift","arrDir","line","header","end","indexOf","substring","pure","title","replace","id","prototype","getTuneById","getTuneByTitle","parseOnly","params","numTunes","output","callback","renderEngine","ret","isArray","testObject","propertyIsEnumerable","undefined","currentTune","startingTune","parseInt","abcParser","div","document","getElementById","parse","getTune","override","hasOwnProperty","innerHTML","flattenTune","tuneObj","staves","j","lines","staff","k","voices","concat","measuresParser","lastChord","measureStartChord","fragStart","hasNotes","voice","elem","startChar","chord","el_type","frag","endChar","measure","name","startEnding","endEnding","extractMeasures","arr","arr2","measures","hasPickup","getPickupLength","kk","kkk","module","exports"],"mappings":"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","sourcesContent":["//    abc_tunebook.js: splits a string representing ABC Music Notation into individual tunes.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*global document */\n/*global window, ABCJS, console */\n\nvar parseCommon = require('../parse/abc_common');\nvar Parse = require('../parse/abc_parse');\n\nvar tunebook = {};\n\n(function() {\n\t\"use strict\";\n\n\ttunebook.numberOfTunes = function(abc) {\n\t\tvar tunes = abc.split(\"\\nX:\");\n\t\tvar num = tunes.length;\n\t\tif (num === 0) num = 1;\n\t\treturn num;\n\t};\n\n\tvar TuneBook = tunebook.TuneBook = function(book) {\n\t\tvar This = this;\n\t\tvar directives = \"\";\n\t\tbook = parseCommon.strip(book);\n\t\tvar tunes = book.split(\"\\nX:\");\n\t\tfor (var i = 1; i < tunes.length; i++)\t// Put back the X: that we lost when splitting the tunes.\n\t\t\ttunes[i] = \"X:\" + tunes[i];\n\t\t// Keep track of the character position each tune starts with.\n\t\tvar pos = 0;\n\t\tThis.tunes = [];\n\t\tparseCommon.each(tunes, function(tune) {\n\t\t\tThis.tunes.push({ abc: tune, startPos: pos});\n\t\t\tpos += tune.length + 1; // We also lost a newline when splitting, so count that.\n\t\t});\n\t\tif (This.tunes.length > 1 && !parseCommon.startsWith(This.tunes[0].abc, 'X:')) {\t// If there is only one tune, the X: might be missing, otherwise assume the top of the file is \"intertune\"\n\t\t\t// There could be file-wide directives in this, if so, we need to insert it into each tune. We can probably get away with\n\t\t\t// just looking for file-wide directives here (before the first tune) and inserting them at the bottom of each tune, since\n\t\t\t// the tune is parsed all at once. The directives will be seen before the engraver begins processing.\n\t\t\tvar dir = This.tunes.shift();\n\t\t\tvar arrDir = dir.abc.split('\\n');\n\t\t\tparseCommon.each(arrDir, function(line) {\n\t\t\t\tif (parseCommon.startsWith(line, '%%'))\n\t\t\t\t\tdirectives += line + '\\n';\n\t\t\t});\n\t\t}\n\t\tThis.header = directives;\n\n\t\t// Now, the tune ends at a blank line, so truncate it if needed. There may be \"intertune\" stuff.\n\t\tparseCommon.each(This.tunes, function(tune) {\n\t\t\tvar end = tune.abc.indexOf('\\n\\n');\n\t\t\tif (end > 0)\n\t\t\t\ttune.abc = tune.abc.substring(0, end);\n\t\t\ttune.pure = tune.abc;\n\t\t\ttune.abc = directives + tune.abc;\n\n\t\t\t// for the user's convenience, parse and store the title separately. The title is between the first T: and the next \\n\n\t\t\tvar title = tune.pure.split(\"T:\");\n\t\t\tif (title.length > 1) {\n\t\t\t\ttitle = title[1].split(\"\\n\");\n\t\t\t\ttune.title = title[0].replace(/^\\s+|\\s+$/g, '');\n\t\t\t} else\n\t\t\t\ttune.title = \"\";\n\n\t\t\t// for the user's convenience, parse and store the id separately. The id is between the first X: and the next \\n\n\t\t\tvar id = tune.pure.substring(2, tune.pure.indexOf(\"\\n\"));\n\t\t\ttune.id = id.replace(/^\\s+|\\s+$/g, '');\n\t\t});\n\t};\n\n\tTuneBook.prototype.getTuneById = function(id) {\n\t\tfor (var i = 0; i < this.tunes.length; i++) {\n\t\t\tif (this.tunes[i].id === ''+id)\n\t\t\t\treturn this.tunes[i];\n\t\t}\n\t\treturn null;\n\t};\n\n\tTuneBook.prototype.getTuneByTitle = function(title) {\n\t\tfor (var i = 0; i < this.tunes.length; i++) {\n\t\t\tif (this.tunes[i].title === title)\n\t\t\t\treturn this.tunes[i];\n\t\t}\n\t\treturn null;\n\t};\n\n\ttunebook.parseOnly = function(abc, params) {\n\t\tvar tunes = [];\n\t\tvar numTunes = tunebook.numberOfTunes(abc);\n\n\t\t// this just needs to be passed in because this tells the engine how many tunes to process.\n\t\tvar output = [];\n\t\tfor (var i = 0; i < numTunes; i++) {\n\t\t\toutput.push(1);\n\t\t}\n\t\tfunction callback() {\n\t\t\t// Don't need to do anything with the parsed tunes.\n\t\t}\n\t\treturn tunebook.renderEngine(callback, output, abc, params);\n\t};\n\n\ttunebook.renderEngine = function (callback, output, abc, params) {\n\t\tvar ret = [];\n\t\tvar isArray = function(testObject) {\n\t\t\treturn testObject && !(testObject.propertyIsEnumerable('length')) && typeof testObject === 'object' && typeof testObject.length === 'number';\n\t\t};\n\n\t\t// check and normalize input parameters\n\t\tif (output === undefined || abc === undefined)\n\t\t\treturn;\n\t\tif (!isArray(output))\n\t\t\toutput = [ output ];\n\t\tif (params === undefined)\n\t\t\tparams = {};\n\t\tvar currentTune = params.startingTune ? parseInt(params.startingTune, 10) : 0;\n\n\t\t// parse the abc string\n\t\tvar book = new TuneBook(abc);\n\t\tvar abcParser = new Parse();\n\n\t\t// output each tune, if it exists. Otherwise clear the div.\n\t\tfor (var i = 0; i < output.length; i++) {\n\t\t\tvar div = output[i];\n\t\t\tif (div === \"*\") {\n\t\t\t\t// This is for \"headless\" rendering: doing the work but not showing the svg.\n\t\t\t} else if (typeof(div) === \"string\")\n\t\t\t\tdiv = document.getElementById(div);\n\t\t\tif (div) {\n\t\t\t\tif (currentTune >= 0 && currentTune < book.tunes.length) {\n\t\t\t\t\tabcParser.parse(book.tunes[currentTune].abc, params, book.tunes[currentTune].startPos - book.header.length);\n\t\t\t\t\tvar tune = abcParser.getTune();\n\t\t\t\t\tvar override = callback(div, tune, i, book.tunes[currentTune].abc);\n\t\t\t\t\tret.push(override ? override : tune);\n\t\t\t\t} else {\n\t\t\t\t\tif (div.hasOwnProperty('innerHTML'))\n\t\t\t\t\t\tdiv.innerHTML = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrentTune++;\n\t\t}\n\t\treturn ret;\n\t};\n\n\tfunction flattenTune(tuneObj) {\n\t\t// This removes the line breaks and removes the non-music lines.\n\t\tvar staves = [];\n\t\tfor (var j = 0; j < tuneObj.lines.length; j++) {\n\t\t\tvar line = tuneObj.lines[j];\n\t\t\tif (line.staff) {\n\t\t\t\tfor (var k = 0; k < line.staff.length; k++) {\n\t\t\t\t\tvar staff = line.staff[k];\n\t\t\t\t\tif (!staves[k])\n\t\t\t\t\t\tstaves[k] = staff;\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (var i = 0; i < staff.voices.length; i++) {\n\t\t\t\t\t\t\tif (staves[k].voices[i])\n\t\t\t\t\t\t\t\tstaves[k].voices[i] = staves[k].voices[i].concat(staff.voices[i]);\n\t\t\t\t\t\t\t// TODO-PER: If staves[k].voices[i] doesn't exist, that means a voice appeared in the middle of the tune. That isn't handled yet.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn staves;\n\t}\n\n\tfunction measuresParser(staff, tune) {\n\t\tvar voices = [];\n\t\tvar lastChord = null;\n\t\tvar measureStartChord = null;\n\t\tvar fragStart = null;\n\t\tvar hasNotes = false;\n\n\t\tfor (var i = 0; i < staff.voices.length; i++) {\n\t\t\tvar voice = staff.voices[i];\n\t\t\tvoices.push([]);\n\t\t\tfor (var j = 0; j < voice.length; j++) {\n\t\t\t\tvar elem = voice[j];\n\t\t\t\tif (fragStart === null && elem.startChar >= 0) {\n\t\t\t\t\tfragStart = elem.startChar;\n\t\t\t\t\tif (elem.chord === undefined)\n\t\t\t\t\t\tmeasureStartChord = lastChord;\n\t\t\t\t\telse\n\t\t\t\t\t\tmeasureStartChord = null;\n\t\t\t\t}\n\t\t\t\tif (elem.chord)\n\t\t\t\t\tlastChord = elem;\n\t\t\t\tif (elem.el_type === 'bar') {\n\t\t\t\t\tif (hasNotes) {\n\t\t\t\t\t\tvar frag = tune.abc.substring(fragStart, elem.endChar);\n\t\t\t\t\t\tvar measure = {abc: frag};\n\t\t\t\t\t\tlastChord = measureStartChord && measureStartChord.chord && measureStartChord.chord.length > 0 ? measureStartChord.chord[0].name : null;\n\t\t\t\t\t\tif (lastChord)\n\t\t\t\t\t\t\tmeasure.lastChord = lastChord;\n\t\t\t\t\t\tif (elem.startEnding)\n\t\t\t\t\t\t\tmeasure.startEnding = elem.startEnding;\n\t\t\t\t\t\tif (elem.endEnding)\n\t\t\t\t\t\t\tmeasure.endEnding = elem.endEnding;\n\t\t\t\t\t\tvoices[i].push(measure);\n\t\t\t\t\t\tfragStart = null;\n\t\t\t\t\t\thasNotes = false;\n\t\t\t\t\t}\n\t\t\t\t} else if (elem.el_type === 'note') {\n\t\t\t\t\thasNotes = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn voices;\n\t}\n\n\ttunebook.extractMeasures = function(abc) {\n\t\tvar tunes = [];\n\t\tvar book = new TuneBook(abc);\n\t\tfor (var i = 0; i < book.tunes.length; i++) {\n\t\t\tvar tune = book.tunes[i];\n\t\t\tvar arr = tune.abc.split(\"K:\");\n\t\t\tvar arr2 = arr[1].split(\"\\n\");\n\t\t\tvar header = arr[0] + \"K:\" + arr2[0] + \"\\n\";\n\t\t\tvar lastChord = null;\n\t\t\tvar measureStartChord = null;\n\t\t\tvar fragStart = null;\n\t\t\tvar measures = [];\n\t\t\tvar hasNotes = false;\n\t\t\tvar tuneObj = tunebook.parseOnly(tune.abc)[0];\n\t\t\tvar hasPickup = tuneObj.getPickupLength() > 0;\n\t\t\t// var staves = flattenTune(tuneObj);\n\t\t\t// for (var s = 0; s < staves.length; s++) {\n\t\t\t// \tvar voices = measuresParser(staves[s], tune);\n\t\t\t// \tif (s === 0)\n\t\t\t// \t\tmeasures = voices;\n\t\t\t// \telse {\n\t\t\t// \t\tfor (var ss = 0; ss < voices.length; ss++) {\n\t\t\t// \t\t\tvar voice = voices[ss];\n\t\t\t// \t\t\tif (measures.length <= ss)\n\t\t\t// \t\t\t\tmeasures.push([]);\n\t\t\t// \t\t\tvar measureVoice = measures[ss];\n\t\t\t// \t\t\tfor (var sss = 0; sss < voice.length; sss++) {\n\t\t\t// \t\t\t\tif (measureVoice.length > sss)\n\t\t\t// \t\t\t\t\tmeasureVoice[sss].abc += \"\\n\" + voice[sss].abc;\n\t\t\t// \t\t\t\telse\n\t\t\t// \t\t\t\t\tmeasures.push(voice[sss]);\n\t\t\t// \t\t\t}\n\t\t\t// \t\t}\n\t\t\t// \t}\n\t\t\t// \tconsole.log(voices);\n\t\t\t// }\n\t\t\t// measures = measures[0];\n\n\t\t\tfor (var j = 0; j < tuneObj.lines.length; j++) {\n\t\t\t\tvar line = tuneObj.lines[j];\n\t\t\t\tif (line.staff) {\n\t\t\t\t\tfor (var k = 0; k < 1 /*line.staff.length*/; k++) {\n\t\t\t\t\t\tvar staff = line.staff[k];\n\t\t\t\t\t\tfor (var kk = 0; kk < 1 /*staff.voices.length*/; kk++) {\n\t\t\t\t\t\t\tvar voice = staff.voices[kk];\n\t\t\t\t\t\t\tfor (var kkk = 0; kkk < voice.length; kkk++) {\n\t\t\t\t\t\t\t\tvar elem = voice[kkk];\n\t\t\t\t\t\t\t\tif (fragStart === null && elem.startChar >= 0) {\n\t\t\t\t\t\t\t\t\tfragStart = elem.startChar;\n\t\t\t\t\t\t\t\t\tif (elem.chord === undefined)\n\t\t\t\t\t\t\t\t\t\tmeasureStartChord = lastChord;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tmeasureStartChord = null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (elem.chord)\n\t\t\t\t\t\t\t\t\tlastChord = elem;\n\t\t\t\t\t\t\t\tif (elem.el_type === 'bar') {\n\t\t\t\t\t\t\t\t\tif (hasNotes) {\n\t\t\t\t\t\t\t\t\t\tvar frag = tune.abc.substring(fragStart, elem.endChar);\n\t\t\t\t\t\t\t\t\t\tvar measure = {abc: frag};\n\t\t\t\t\t\t\t\t\t\tlastChord = measureStartChord && measureStartChord.chord && measureStartChord.chord.length > 0 ? measureStartChord.chord[0].name : null;\n\t\t\t\t\t\t\t\t\t\tif (lastChord)\n\t\t\t\t\t\t\t\t\t\t\tmeasure.lastChord = lastChord;\n\t\t\t\t\t\t\t\t\t\tif (elem.startEnding)\n\t\t\t\t\t\t\t\t\t\t\tmeasure.startEnding = elem.startEnding;\n\t\t\t\t\t\t\t\t\t\tif (elem.endEnding)\n\t\t\t\t\t\t\t\t\t\t\tmeasure.endEnding = elem.endEnding;\n\t\t\t\t\t\t\t\t\t\tmeasures.push(measure);\n\t\t\t\t\t\t\t\t\t\tfragStart = null;\n\t\t\t\t\t\t\t\t\t\thasNotes = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (elem.el_type === 'note') {\n\t\t\t\t\t\t\t\t\thasNotes = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttunes.push({\n\t\t\t\theader: header,\n\t\t\t\tmeasures: measures,\n\t\t\t\thasPickup: hasPickup\n\t\t\t});\n\t\t}\n\t\treturn tunes;\n\t};\n})();\n\nmodule.exports = tunebook;\n"]},"metadata":{},"sourceType":"script"}