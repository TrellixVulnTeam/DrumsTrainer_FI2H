{"ast":null,"code":"//    wrap_lines.js: does line wrap on an already parsed tune.\n//    Copyright (C) 2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfunction wrapLines(tune, lineBreaks) {\n  if (!lineBreaks || tune.lines.length === 0) return; // tune.lines contains nested arrays: there is an array of lines (that's the part this function rewrites),\n  // there is an array of staffs per line (for instance, piano will have 2, orchestra will have many)\n  // there is an array of voices per staff (for instance, 4-part harmony might have bass and tenor on a single staff)\n  // The measure numbers start at zero for each staff, but on the succeeding lines, the measure numbers are reset to the beginning of the line.\n\n  var newLines = []; // keep track of our counters for each staff and voice\n\n  var startNewLine = [];\n  var currentLine = [];\n  var measureNumber = [];\n  var measureMarker = [];\n  var lastMeter = '';\n  var voiceStart = {};\n  var linesWithoutStaff = 0;\n\n  for (var i = 0; i < tune.lines.length; i++) {\n    var line = tune.lines[i];\n\n    if (line.staff) {\n      var staffs = line.staff;\n\n      for (var j = 0; j < staffs.length; j++) {\n        if (startNewLine[j] === undefined) {\n          startNewLine[j] = [];\n          currentLine[j] = [];\n          measureNumber[j] = [];\n          measureMarker[j] = [];\n        }\n\n        var staff = staffs[j];\n        var voices = staff.voices;\n\n        for (var k = 0; k < voices.length; k++) {\n          if (startNewLine[j][k] === undefined) {\n            startNewLine[j][k] = true;\n            currentLine[j][k] = 0;\n            measureNumber[j][k] = 0;\n            measureMarker[j][k] = 0;\n          }\n\n          if (linesWithoutStaff > 0) currentLine[j][k] += linesWithoutStaff;\n          var voice = voices[k];\n\n          for (var e = 0; e < voice.length; e++) {\n            if (startNewLine[j][k]) {\n              if (!newLines[currentLine[j][k]]) newLines[currentLine[j][k]] = {\n                staff: []\n              };\n\n              if (!newLines[currentLine[j][k]].staff[j]) {\n                newLines[currentLine[j][k]].staff[j] = {\n                  voices: []\n                };\n\n                for (var key in staff) {\n                  if (staff.hasOwnProperty(key)) {\n                    if (key === 'meter') {\n                      if (newLines.length === 1 || lastMeter !== JSON.stringify(staff[key])) {\n                        lastMeter = JSON.stringify(staff[key]);\n                        newLines[currentLine[j][k]].staff[j][key] = staff[key];\n                      }\n                    } else if (key !== 'voices') {\n                      newLines[currentLine[j][k]].staff[j][key] = staff[key];\n                    }\n                  }\n                }\n              }\n\n              if (measureMarker[j][k]) newLines[currentLine[j][k]].staff[j].barNumber = measureMarker[j][k];\n              startNewLine[j][k] = false;\n            }\n\n            var element = voice[e];\n\n            if (!newLines[currentLine[j][k]].staff[j].voices[k]) {\n              newLines[currentLine[j][k]].staff[j].voices[k] = [];\n\n              for (var startItem in voiceStart) {\n                if (voiceStart.hasOwnProperty(startItem)) {\n                  newLines[currentLine[j][k]].staff[j].voices[k].push(voiceStart[startItem]);\n                }\n              }\n            }\n\n            newLines[currentLine[j][k]].staff[j].voices[k].push(element);\n\n            if (element.el_type === 'stem') {\n              // This is a nice trick to just pay attention to the last setting of each type.\n              voiceStart[element.el_type] = element;\n            }\n\n            if (element.el_type === 'bar') {\n              measureNumber[j][k]++;\n\n              if (lineBreaks[measureNumber[j][k]]) {\n                startNewLine[j][k] = true;\n                currentLine[j][k]++;\n                measureMarker[j][k] = element.barNumber;\n                delete element.barNumber;\n              }\n            }\n          }\n        }\n      }\n\n      linesWithoutStaff = 0;\n    } else {\n      newLines.push(line);\n      linesWithoutStaff++;\n    }\n  }\n\n  tune.lines = newLines;\n}\n\nfunction freeFormLineBreaks(widths, lineBreakPoint) {\n  var lineBreaks = [];\n  var totals = [];\n  var totalThisLine = 0; // run through each measure and see if the accumulation is less than the ideal.\n  // if it passes the ideal, then see whether the last or this one is closer to the ideal.\n\n  for (var i = 0; i < widths.length; i++) {\n    var width = widths[i];\n    var attemptedWidth = totalThisLine + width;\n    if (attemptedWidth < lineBreakPoint) totalThisLine = attemptedWidth;else {\n      // This just passed the ideal, so see whether the previous or the current number of measures is closer.\n      var oldDistance = lineBreakPoint - totalThisLine;\n      var newDistance = attemptedWidth - lineBreakPoint;\n\n      if (oldDistance < newDistance && totalThisLine > 0) {\n        lineBreaks.push(i - 1);\n        totals.push(Math.round(totalThisLine - width));\n        totalThisLine = width;\n      } else {\n        if (i < widths.length - 1) {\n          lineBreaks.push(i);\n          totals.push(Math.round(totalThisLine));\n          totalThisLine = 0;\n        }\n      }\n    }\n  }\n\n  totals.push(Math.round(totalThisLine));\n  return {\n    lineBreaks: lineBreaks,\n    totals: totals\n  };\n} // function createLineTestArray(numLines, numMeasures, maxMeasuresPerLine, minMeasuresPerLine) {\n// \tvar tries = [];\n// \t// To get all the iterations, it is every digit in a particular base-numbering system.\n// \t// That is, we want to generate every number that is (numLines-1) digits, in base (max-min+1)\n// \t// For instance, for 5 lines where the min is 6 and max is 8, we want ever combination of 4 digits in base 3.\n// \tvar base = maxMeasuresPerLine - minMeasuresPerLine + 1;\n// \tvar digits = numLines - 1; // The last digit is fixed: it is what ever is needed to sum up to the total number of measures.\n// \tvar done = false;\n// \tvar iter = 0;\n// \twhile (!done) {\n// \t\tvar attempt = [];\n// \t\tvar num = iter;\n// \t\tvar total = 0;\n// \t\tfor (var d = digits - 1; d >= 0; d--) {\n// \t\t\tattempt[d] = (num % base) + minMeasuresPerLine;\n// \t\t\tnum = Math.floor(num / base);\n// \t\t\ttotal += attempt[d];\n// \t\t}\n// \t\tif (num > 0)\n// \t\t\tdone = true; // continue until we exceed the greatest number. We know because there is a remainer.\n// \t\telse {\n// \t\t\tvar lastLine = numMeasures - total;\n// \t\t\tif (lastLine >= minMeasuresPerLine && lastLine <= maxMeasuresPerLine) {\n// \t\t\t\tattempt[digits] = lastLine;\n// \t\t\t\ttries.push(attempt);\n// \t\t\t}\n// \t\t\titer++;\n// \t\t}\n// \t}\n// \treturn tries;\n// }\n// function getVariance(attempt, idealLineBreak, widths, allowableOverage) {\n// \tvar measureNumber = 0;\n// \tvar thisWorstVariance = 0;\n// \tfor (var j = 0; j < attempt.length; j++) {\n// \t\tvar lineWidth = 0;\n// \t\tvar measuresThisLine = attempt[j];\n// \t\tfor (var k = 0; k < measuresThisLine; k++) {\n// \t\t\tlineWidth += widths[measureNumber++];\n// \t\t}\n// \t\tif (lineWidth > allowableOverage)\n// \t\t\treturn null;\n// \t\tvar variance = Math.abs(lineWidth - idealLineBreak);\n// \t\tif (variance > thisWorstVariance)\n// \t\t\tthisWorstVariance = variance;\n// \t}\n// \treturn thisWorstVariance;\n// }\n// function getMaxVariance(widths, lineBreakPoint, lineBreaks) {\n// \tvar maxVariance = 0;\n// \tvar numLines = lineBreaks.length + 1; // the last line doesn't have an explicit break\n// \tvar measureNumber = 0;\n// \tvar totals = [];\n// \tfor (var i = 0; i <= lineBreaks.length; i++) {\n// \t\tvar breakMeasure = (i === lineBreaks.length) ? widths.length : lineBreaks[i];\n// \t\tvar thisTotal = 0;\n// \t\tfor (var j = measureNumber; j < breakMeasure; j++) {\n// \t\t\tthisTotal += widths[j];\n// \t\t}\n// \t\tmeasureNumber = breakMeasure;\n// \t\tvar thisVariance = thisTotal <= lineBreakPoint ? lineBreakPoint - thisTotal : 1000000;\n// \t\ttotals.push({total: thisTotal, variance: thisVariance})\n// \t\tmaxVariance = Math.max(maxVariance, thisVariance);\n// \t}\n//\n// \tconsole.log(lineBreakPoint, totals)\n// \treturn maxVariance;\n// }\n\n\nfunction getVariance(widths, lineBreaks) {\n  var numLines = lineBreaks.length + 1; // the last line doesn't have an explicit break\n\n  var avg = widths.total / numLines;\n  var largestVariance = 0;\n  var measureNumber = 0;\n\n  for (var i = 0; i <= lineBreaks.length; i++) {\n    var breakMeasure = i === lineBreaks.length ? widths.measureWidths.length - 1 : lineBreaks[i];\n    var thisVariance = lineVariance(widths.measureWidths, measureNumber, breakMeasure, avg);\n    measureNumber = breakMeasure + 1;\n    largestVariance = Math.max(largestVariance, thisVariance);\n  }\n\n  return largestVariance;\n} // function getAvgVariance(widths, lineBreakPoint, lineBreaks) {\n// \tvar totalVariance = 0;\n// \tvar numLines = lineBreaks.length + 1; // the last line doesn't have an explicit break\n// \tvar measureNumber = 0;\n// \tfor (var i = 0; i <= lineBreaks.length; i++) {\n// \t\tvar breakMeasure = (i === lineBreaks.length) ? widths.length : lineBreaks[i];\n// \t\tvar thisTotal = 0;\n// \t\tfor (var j = measureNumber; j < breakMeasure; j++) {\n// \t\t\tthisTotal += widths[j];\n// \t\t}\n// \t\tmeasureNumber = breakMeasure;\n// \t\tvar thisVariance = Math.abs(lineBreakPoint - thisTotal);\n// \t\ttotalVariance += thisVariance;\n// \t}\n//\n// \treturn totalVariance / numLines;\n// }\n\n\nfunction lineVariance(widths, start, end, avg) {\n  var thisTotal = lineWidth(widths, start, end);\n  var thisVariance = Math.abs(avg - thisTotal);\n  return thisVariance;\n}\n\nfunction lineWidth(widths, start, end) {\n  var thisTotal = 0;\n\n  for (var j = start; j <= end; j++) thisTotal += widths[j];\n\n  return thisTotal;\n} // TODO-PER: For long pieces of music, this can get long, so stop finding the combinations at an arbitrary place.\n\n\nfunction getAttempts(widths, start, linesLeft, min, max, lastLines) {\n  var MAX_COMBINATIONS = 1200;\n  var acc = 0;\n  var attempts = [];\n\n  for (var i = start; i < widths.length && acc < max; i++) {\n    acc += widths[i];\n    if (acc > max) break;\n\n    if (acc > min) {\n      if (linesLeft > 0 && attempts.length < MAX_COMBINATIONS) {\n        var nextLines = getAttempts(widths, i + 1, linesLeft - 1, min, max, lastLines);\n\n        for (var j = 0; j < nextLines.length; j++) attempts.push([i].concat(nextLines[j]));\n      }\n\n      if (linesLeft === 1 && lastLines.indexOf(i) >= 0) attempts.push([i]);\n    }\n  }\n\n  return attempts;\n}\n\nfunction lastLinePossibilities(widths, start, min, max) {\n  var acc = 0;\n  var possibilities = [];\n\n  for (var i = widths.length - 1; i >= 0; i--) {\n    acc += widths[i];\n    if (acc > max) break;\n\n    if (acc > min && i < start) {\n      possibilities.push(i - 1);\n    }\n  }\n\n  return possibilities;\n}\n\nfunction clone(arr) {\n  var newArr = [];\n\n  for (var i = 0; i < arr.length; i++) newArr.push(arr[i]);\n\n  return newArr;\n}\n\nfunction oneTry(measureWidths, idealWidths, accumulator, lineAccumulator, lineWidths, lastVariance, highestVariance, currLine, lineBreaks, startIndex, otherTries) {\n  for (var i = startIndex; i < measureWidths.length; i++) {\n    var measureWidth = measureWidths[i];\n    accumulator += measureWidth;\n    lineAccumulator += measureWidth;\n    var thisVariance = Math.abs(accumulator - idealWidths[currLine]);\n    var varianceIsClose = Math.abs(thisVariance - lastVariance) < idealWidths[0] / 10; // see if the difference is less than 10%, if so, run the test both ways.\n\n    if (varianceIsClose) {\n      if (thisVariance < lastVariance) {\n        // Also attempt one less measure on the current line - sometimes that works out better.\n        var newWidths = clone(lineWidths);\n        var newBreaks = clone(lineBreaks);\n        newBreaks.push(i - 1);\n        newWidths.push(lineAccumulator - measureWidth);\n        otherTries.push({\n          accumulator: accumulator,\n          lineAccumulator: measureWidth,\n          lineWidths: newWidths,\n          lastVariance: Math.abs(accumulator - idealWidths[currLine + 1]),\n          highestVariance: Math.max(highestVariance, lastVariance),\n          currLine: currLine + 1,\n          lineBreaks: newBreaks,\n          startIndex: i + 1\n        });\n      } else if (thisVariance > lastVariance && i < measureWidths.length - 1) {\n        // Also attempt one extra measure on this line.\n        newWidths = clone(lineWidths);\n        newBreaks = clone(lineBreaks); // newBreaks[newBreaks.length-1] = i;\n        // newWidths[newWidths.length-1] = lineAccumulator;\n\n        otherTries.push({\n          accumulator: accumulator,\n          lineAccumulator: lineAccumulator,\n          lineWidths: newWidths,\n          lastVariance: thisVariance,\n          highestVariance: Math.max(highestVariance, thisVariance),\n          currLine: currLine,\n          lineBreaks: newBreaks,\n          startIndex: i + 1\n        });\n      }\n    }\n\n    if (thisVariance > lastVariance) {\n      lineBreaks.push(i - 1);\n      currLine++;\n      highestVariance = Math.max(highestVariance, lastVariance);\n      lastVariance = Math.abs(accumulator - idealWidths[currLine]);\n      lineWidths.push(lineAccumulator - measureWidth);\n      lineAccumulator = measureWidth;\n    } else {\n      lastVariance = thisVariance;\n    }\n  }\n\n  lineWidths.push(lineAccumulator);\n}\n\nfunction optimizeLineWidths(widths, lineBreakPoint, lineBreaks, explanation) {\n  //\tfigure out how many lines - That's one more than was tried before.\n  var numLines = Math.ceil(widths.total / lineBreakPoint) + 1; //\tget the ideal width for a line (cumulative width / num lines) - approx the same as lineBreakPoint except for rounding\n\n  var idealWidth = Math.floor(widths.total / numLines); //\tget each ideal line width (1*ideal, 2*ideal, 3*ideal, etc)\n\n  var idealWidths = [];\n\n  for (var i = 0; i < numLines; i++) idealWidths.push(idealWidth * (i + 1)); //\tfrom first measure, step through accum. Widths until the abs of the ideal is greater than the last one.\n  // This can sometimes look funny in edge cases, so when the length is within 10%, try one more or one less to see which is better.\n  // This is better than trying all the possibilities because that would get to be a huge number for even a medium size piece.\n  // This method seems to never generate more than about 16 tries and it is usually 4 or less.\n\n\n  var otherTries = [];\n  otherTries.push({\n    accumulator: 0,\n    lineAccumulator: 0,\n    lineWidths: [],\n    lastVariance: 999999,\n    highestVariance: 0,\n    currLine: 0,\n    lineBreaks: [],\n    // These are the zero-based last measure on each line\n    startIndex: 0\n  });\n  var index = 0;\n\n  while (index < otherTries.length) {\n    oneTry(widths.measureWidths, idealWidths, otherTries[index].accumulator, otherTries[index].lineAccumulator, otherTries[index].lineWidths, otherTries[index].lastVariance, otherTries[index].highestVariance, otherTries[index].currLine, otherTries[index].lineBreaks, otherTries[index].startIndex, otherTries);\n    index++;\n  }\n\n  for (i = 0; i < otherTries.length; i++) {\n    var otherTry = otherTries[i];\n    otherTry.variances = [];\n    otherTry.aveVariance = 0;\n\n    for (var j = 0; j < otherTry.lineWidths.length; j++) {\n      var lineWidth = otherTry.lineWidths[j];\n      otherTry.variances.push(lineWidth - idealWidths[0]);\n      otherTry.aveVariance += Math.abs(lineWidth - idealWidths[0]);\n    }\n\n    otherTry.aveVariance = otherTry.aveVariance / otherTry.lineWidths.length;\n    explanation.attempts.push({\n      type: \"optimizeLineWidths\",\n      lineBreaks: otherTry.lineBreaks,\n      variances: otherTry.variances,\n      aveVariance: otherTry.aveVariance,\n      widths: widths.measureWidths\n    });\n  }\n\n  var smallest = 9999999;\n  var smallestIndex = -1;\n\n  for (i = 0; i < otherTries.length; i++) {\n    otherTry = otherTries[i];\n\n    if (otherTry.aveVariance < smallest) {\n      smallest = otherTry.aveVariance;\n      smallestIndex = i;\n    }\n  }\n\n  return {\n    failed: false,\n    lineBreaks: otherTries[smallestIndex].lineBreaks,\n    variance: otherTries[smallestIndex].highestVariance\n  };\n} // \t// Instead of having to try all the different combinations to find the best, we start with an important piece of knowledge about the lineBreaks we are given:\n// \t// If there is a line too short, it is the last one.\n// \t// So, let's just do a couple of tweaks to see how it works to add one or two measures to the last line.\n// \tvar avg = widths.total / (lineBreaks.length + 1);\n// \tvar variance = getVariance(widths, lineBreaks);\n// \tvar variancePct = variance/lineBreakPoint*100;\n//\n// \tif (lineBreaks.length === 0)\n// \t\treturn { failed: true, reason: \"Only one line.\" };\n//\n// \tvar lastLineStart = lineBreaks[lineBreaks.length-1]+1;\n// \tvar lastLineVariance = lineVariance(widths.measureWidths, lastLineStart, widths.measureWidths.length, avg);\n// \tif (variance > lastLineVariance)\n// \t\treturn { failed: true, reason: \"Last line is not too short.\" };\n//\n// \t// Let's get a list of all combinations that have a possibility of working. That is, all combinations where no line has a variance larger than \"variance\".\n// \tvar lastLines = lastLinePossibilities(widths.measureWidths, lastLineStart, avg - variance, avg + variance);\n// \tvar attempts = getAttempts(widths.measureWidths, 0, lineBreaks.length, avg - variance, avg + variance, lastLines);\n// \t//console.log(attempts, avg - variance, avg + variance);\n//\n// \tvar failed = true;\n// \tfor (var i = 0; i < attempts.length; i++) {\n// \t\tvar newVariance = getVariance(widths, attempts[i]);\n// \t\tif (newVariance < variance) {\n// \t\t\texplanation.attempts.push({\n// \t\t\t\ttype: \"Optimize try\", lineBreaks: attempts[i],\n// \t\t\t\tvariance: Math.round(variance), newVariance: Math.round(newVariance),\n// \t\t\t\ttotalAttempts: attempts.length\n// \t\t\t});\n// \t\t\tvariance = newVariance;\n// \t\t\tlineBreaks = attempts[i];\n// \t\t\tfailed = false;\n// \t\t}\n// \t}\n// \tif (failed) {\n// \t\texplanation.attempts.push({ type: \"Optimize try\", lineBreaks: lineBreaks, variance: variance, reason: \"None of the \" + attempts.length + \" attempts were better.\" });\n// \t\t// TODO-PER: This shouldn't be necessary, but just try to move one measure down and see if it helps.\n// \t\tif (lineBreaks.length > 0) {\n// \t\t\tvar attempt = [].concat(lineBreaks);\n// \t\t\tattempt[attempt.length - 1]--;\n// \t\t\tnewVariance = getVariance(widths, attempt);\n// \t\t\texplanation.attempts.push({\n// \t\t\t\ttype: \"Optimize last try\", lineBreaks: attempts[i],\n// \t\t\t\tvariance: Math.round(variance), newVariance: Math.round(newVariance),\n// \t\t\t\ttotalAttempts: attempts.length\n// \t\t\t});\n// \t\t\tif (newVariance < variance) {\n// \t\t\t\tvariance = newVariance;\n// \t\t\t\tlineBreaks = attempt;\n// \t\t\t\tfailed = false;\n// \t\t\t}\n// \t\t}\n// \t}\n// \t// Let's squeeze the line successively until it spills onto an extra line, then take the option with the lowest variance\n// \t// var targetNumLines = lineBreaks.length;\n// \t// var newNumLines = targetNumLines;\n// \t// var TRY_INCREMENT = 1;\n// \t// var tryBreakPoint = lineBreakPoint - TRY_INCREMENT;\n// \t// var failed = true;\n// \t// while (targetNumLines === newNumLines && tryBreakPoint > 50) {\n// \t// \tvar ff = freeFormLineBreaks(widths.measureWidths, tryBreakPoint);\n// \t// \tnewNumLines = ff.lineBreaks.length;\n// \t// \tif (newNumLines === targetNumLines) {\n// \t// \t\tvar newVariance = getVariance(widths, ff.lineBreaks);\n// \t// \t\tvar newVariancePct = newVariance/tryBreakPoint*100;\n// \t// \t\texplanation.attempts.push({type: \"Optimize try\", tryBreakPoint: Math.round(tryBreakPoint), lineBreaks: ff.lineBreaks, totals: ff.totals,\n// \t// \t\t\tvariance: Math.round(variance), newVariance: Math.round(newVariance), variancePct: Math.round(variancePct), newVariancePct: Math.round(newVariancePct)\n// \t// \t\t});\n// \t// \t\tif (newVariancePct < variancePct) {\n// \t// \t\t\tvariancePct = newVariancePct;\n// \t// \t\t\tlineBreaks = ff.lineBreaks;\n// \t// \t\t\tfailed = false;\n// \t// \t\t}\n// \t// \t} else {\n// \t// \t\texplanation.attempts.push({type: \"Optimize try\", explanation: \"Exceeded number of lines.\" , tryBreakPoint: Math.round(tryBreakPoint), lineBreaks: ff.lineBreaks, totals: ff.totals, variance: variance, avg: avg, variancePct: variancePct});\n// \t// \t}\n// \t// \ttryBreakPoint -= TRY_INCREMENT;\n// \t// }\n//\n// \treturn { failed: failed, lineBreaks: lineBreaks, variance: variance };\n// }\n// function fixedNumLinesBreaks(widths, numLines, allowOver, allowableVariance) {\n// \tvar idealLineBreak = widths.total / numLines;\n// \t// If all the measures had the same amount of stuff, then the ave would be correct.\n// \t// We will test all the combinations from one less to one more than the average.\n// \tvar averageMeasuresPerLine = Math.round(widths.measureWidths.length / numLines);\n// \tvar minMeasuresPerLine = Math.max(averageMeasuresPerLine - 1, 1);\n// \tvar maxMeasuresPerLine = averageMeasuresPerLine + 1;\n// \tvar tries = createLineTestArray(numLines, widths.measureWidths.length, maxMeasuresPerLine, minMeasuresPerLine);\n// \tconsole.log(\"fixedNumLinesBreaks tests (\"+minMeasuresPerLine+'-'+maxMeasuresPerLine+\")\", numLines, tries.length)\n//\n// \t// For each possible number of measures per line, see which has the closest spacing to the ideal.\n// \tvar bestCase = -1;\n// \tvar bestCaseVariance = 1000000;\n// \tfor (var i = 0 ; i < tries.length; i++) {\n// \t\tvar attempt = tries[i];\n// \t\tvar variance = getVariance(attempt, idealLineBreak, widths.measureWidths, allowOver ? allowableVariance : 0);\n// \t\tif (variance !== null) {\n// \t\t\tif (variance < bestCaseVariance) {\n// \t\t\t\tbestCaseVariance = variance;\n// \t\t\t\tbestCase = i;\n// \t\t\t}\n// \t\t}\n// \t}\n// \tvar failed = true;\n// \t// For debugging, recreate the line widths\n// \tvar totals = [];\n// \tif (bestCase >= 0) {\n// \t\tfailed = false;\n// \t\tvar index = 0;\n// \t\tfor (i = 0; i < tries[bestCase].length; i++) {\n// \t\t\tvar total = 0;\n// \t\t\tfor (var j = 0; j < tries[bestCase][i]; j++) {\n// \t\t\t\ttotal += widths.measureWidths[index++];\n// \t\t\t}\n// \t\t\ttotals.push(Math.round(total));\n// \t\t}\n// \t\t// We now have an array that contains the number of measures per line, but we want to return the absolute measure number to break on.\n// \t\tif (tries[bestCase].length > 0) {\n// \t\t\ttries[bestCase][0]--; // The results should contain the last measure number on the line, zero-based.\n// \t\t\tfor (i = 1; i < tries[bestCase].length; i++)\n// \t\t\t\ttries[bestCase][i] += tries[bestCase][i - 1]; // This sets the zero-based measure number\n// \t\t\t// The last line is implied and we don't need to return it\n// \t\t\ttries[bestCase].pop();\n// \t\t}\n// \t}\n// \treturn { failed: failed, lineBreaks: tries[bestCase], bestCaseVariance: Math.round(bestCaseVariance), totals: totals };\n// }\n\n\nfunction fixedMeasureLineBreaks(widths, lineBreakPoint, preferredMeasuresPerLine) {\n  var lineBreaks = [];\n  var totals = [];\n  var thisWidth = 0;\n  var failed = false;\n\n  for (var i = 0; i < widths.length; i++) {\n    thisWidth += widths[i];\n\n    if (thisWidth > lineBreakPoint) {\n      failed = true;\n    }\n\n    if (i % preferredMeasuresPerLine === preferredMeasuresPerLine - 1) {\n      if (i !== widths.length - 1) // Don't bother putting a line break for the last line - it's already a break.\n        lineBreaks.push(i);\n      totals.push(Math.round(thisWidth));\n      thisWidth = 0;\n    }\n  }\n\n  return {\n    failed: failed,\n    totals: totals,\n    lineBreaks: lineBreaks\n  };\n}\n\nfunction getRevisedTune(lineBreaks, staffWidth, abcString, params, Parse) {\n  var abcParser = new Parse();\n  var revisedParams = {\n    lineBreaks: lineBreaks,\n    staffwidth: staffWidth\n  };\n\n  for (var key in params) {\n    if (params.hasOwnProperty(key) && key !== 'wrap' && key !== 'staffwidth') {\n      revisedParams[key] = params[key];\n    }\n  }\n\n  abcParser.parse(abcString, revisedParams);\n  return {\n    tune: abcParser.getTune(),\n    revisedParams: revisedParams\n  };\n}\n\nfunction calcLineWraps(tune, widths, abcString, params, Parse, engraver_controller) {\n  // For calculating how much can go on the line, it depends on the width of the line. It is a convenience to just divide it here\n  // by the minimum spacing instead of multiplying the min spacing later.\n  // The scaling works differently: this is done by changing the scaling of the outer SVG, so the scaling needs to be compensated\n  // for here, because the actual width will be different from the calculated numbers.\n  // If the desired width is less than the margin, just punt and return the original tune\n  if (params.staffwidth < widths.left) {\n    return {\n      explanation: \"Staffwidth is narrower than the margin\",\n      tune: tune,\n      revisedParams: params\n    };\n  }\n\n  var scale = params.scale ? Math.max(params.scale, 0.1) : 1;\n  var minSpacing = params.wrap.minSpacing ? Math.max(parseFloat(params.wrap.minSpacing), 1) : 1;\n  var minSpacingLimit = params.wrap.minSpacingLimit ? Math.max(parseFloat(params.wrap.minSpacingLimit), 1) : minSpacing - 0.1;\n  var maxSpacing = params.wrap.maxSpacing ? Math.max(parseFloat(params.wrap.maxSpacing), 1) : undefined;\n  if (params.wrap.lastLineLimit && !maxSpacing) maxSpacing = Math.max(parseFloat(params.wrap.lastLineLimit), 1);\n  var targetHeight = params.wrap.targetHeight ? Math.max(parseInt(params.wrap.targetHeight, 10), 100) : undefined;\n  var preferredMeasuresPerLine = params.wrap.preferredMeasuresPerLine ? Math.max(parseInt(params.wrap.preferredMeasuresPerLine, 10), 1) : undefined;\n  var lineBreakPoint = (params.staffwidth - widths.left) / minSpacing / scale;\n  var minLineSize = (params.staffwidth - widths.left) / maxSpacing / scale;\n  var allowableVariance = (params.staffwidth - widths.left) / minSpacingLimit / scale;\n  var explanation = {\n    widths: widths,\n    lineBreakPoint: lineBreakPoint,\n    minLineSize: minLineSize,\n    attempts: [],\n    staffWidth: params.staffwidth,\n    minWidth: Math.round(allowableVariance)\n  }; // If there is a preferred number of measures per line, test that first. If none of the lines is too long, then we're finished.\n\n  var lineBreaks = null;\n\n  if (preferredMeasuresPerLine) {\n    var f = fixedMeasureLineBreaks(widths.measureWidths, lineBreakPoint, preferredMeasuresPerLine);\n    explanation.attempts.push({\n      type: \"Fixed Measures Per Line\",\n      preferredMeasuresPerLine: preferredMeasuresPerLine,\n      lineBreaks: f.lineBreaks,\n      failed: f.failed,\n      totals: f.totals\n    });\n    if (!f.failed) lineBreaks = f.lineBreaks;\n  } // If we don't have lineBreaks yet, use the free form method of line breaks.\n  // This will be called either if Preferred Measures is not used, or if the music is just weird - like a single measure is way too crowded.\n\n\n  if (!lineBreaks) {\n    var ff = freeFormLineBreaks(widths.measureWidths, lineBreakPoint);\n    explanation.attempts.push({\n      type: \"Free Form\",\n      lineBreaks: ff.lineBreaks,\n      totals: ff.totals\n    });\n    lineBreaks = ff.lineBreaks; // We now have an acceptable number of lines, but the measures may not be optimally distributed. See if there is a better distribution.\n\n    ff = optimizeLineWidths(widths, lineBreakPoint, lineBreaks, explanation);\n    explanation.attempts.push({\n      type: \"Optimize\",\n      failed: ff.failed,\n      reason: ff.reason,\n      lineBreaks: ff.lineBreaks,\n      totals: ff.totals\n    });\n    if (!ff.failed) lineBreaks = ff.lineBreaks;\n  } // If the vertical space exceeds targetHeight, remove a line and try again. If that is too crowded, then don't use it.\n\n\n  var staffWidth = params.staffwidth;\n  var ret = getRevisedTune(lineBreaks, staffWidth, abcString, params, Parse);\n  var newWidths = engraver_controller.getMeasureWidths(ret.tune);\n  var gotTune = true; // If we adjust the num lines, set this to false\n\n  explanation.attempts.push({\n    type: \"heightCheck\",\n    height: newWidths.height\n  }); // \tif all of the lines are too sparse, make the width narrower.\n  // TODO-PER: implement this case.\n  // If one line and the spacing is > maxSpacing, make the width narrower.\n\n  if (lineBreaks.length === 0 && minLineSize > widths.total) {\n    staffWidth = widths.total * maxSpacing * scale + widths.left;\n    explanation.attempts.push({\n      type: \"too sparse\",\n      newWidth: Math.round(staffWidth)\n    });\n    gotTune = false;\n  } // if (ret.lineBreaks.length === 0) {\n  // \t// Everything fits on one line, so see if there is TOO much space and the staff width needs to be shortened.\n  // \tif (minLineSize > 0 && ret.totalThisLine > 0 && ret.totalThisLine < minLineSize)\n  // \t\tstaffWidth = staffWidth / (minLineSize / ret.totalThisLine);\n  // } else if (ret.totalThisLine < minLineSize) {\n  // \t// the last line is too short, so attempt to redistribute by changing the min.\n  // \t// We will try more and less space alternatively. The space can't be less than 1.0, and we'll try in 0.1 increments.\n  // \tvar minTrys = [];\n  // \tif (minSpacing > 1.1)\n  // \t\tminTrys.push(minSpacing - 0.1);\n  // \tminTrys.push(minSpacing + 0.1);\n  // \tif (minSpacing > 1.2)\n  // \t\tminTrys.push(minSpacing - 0.2);\n  // \tminTrys.push(minSpacing + 0.2);\n  // \tif (minSpacing > 1.3)\n  // \t\tminTrys.push(minSpacing - 0.3);\n  // \tminTrys.push(minSpacing + 0.3);\n  // \tfor (var i = 0; i < minTrys.length && ret.totalThisLine < minLineSize; i++) {\n  // \t\tlineBreakPoint = (params.staffwidth - widths.left) / minTrys[i] / scale;\n  // \t\tret = calcLineBreaks(widths.measureWidths, lineBreakPoint);\n  // \t}\n  // }\n\n\n  if (!gotTune) ret = getRevisedTune(lineBreaks, staffWidth, abcString, params, Parse);\n  ret.explanation = explanation;\n  return ret;\n}\n\nmodule.exports = {\n  wrapLines: wrapLines,\n  calcLineWraps: calcLineWraps\n};","map":{"version":3,"sources":["/home/elad/Desktop/Repos/drums-trainer/frontend/node_modules/react-sheet-music/node_modules/abcjs/src/parse/wrap_lines.js"],"names":["wrapLines","tune","lineBreaks","lines","length","newLines","startNewLine","currentLine","measureNumber","measureMarker","lastMeter","voiceStart","linesWithoutStaff","i","line","staff","staffs","j","undefined","voices","k","voice","e","key","hasOwnProperty","JSON","stringify","barNumber","element","startItem","push","el_type","freeFormLineBreaks","widths","lineBreakPoint","totals","totalThisLine","width","attemptedWidth","oldDistance","newDistance","Math","round","getVariance","numLines","avg","total","largestVariance","breakMeasure","measureWidths","thisVariance","lineVariance","max","start","end","thisTotal","lineWidth","abs","getAttempts","linesLeft","min","lastLines","MAX_COMBINATIONS","acc","attempts","nextLines","concat","indexOf","lastLinePossibilities","possibilities","clone","arr","newArr","oneTry","idealWidths","accumulator","lineAccumulator","lineWidths","lastVariance","highestVariance","currLine","startIndex","otherTries","measureWidth","varianceIsClose","newWidths","newBreaks","optimizeLineWidths","explanation","ceil","idealWidth","floor","index","otherTry","variances","aveVariance","type","smallest","smallestIndex","failed","variance","fixedMeasureLineBreaks","preferredMeasuresPerLine","thisWidth","getRevisedTune","staffWidth","abcString","params","Parse","abcParser","revisedParams","staffwidth","parse","getTune","calcLineWraps","engraver_controller","left","scale","minSpacing","wrap","parseFloat","minSpacingLimit","maxSpacing","lastLineLimit","targetHeight","parseInt","minLineSize","allowableVariance","minWidth","f","ff","reason","ret","getMeasureWidths","gotTune","height","newWidth","module","exports"],"mappings":"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MAAAA,MAAM,EAAEA,MAAM,CAACgB;AAAhJ,KAA1B;AACA;;AACD,MAAIgD,QAAQ,GAAG,OAAf;AACA,MAAIC,aAAa,GAAG,CAAC,CAArB;;AACA,OAAKrF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGqE,UAAU,CAAC9E,MAA3B,EAAmCS,CAAC,EAApC,EAAwC;AACvCgF,IAAAA,QAAQ,GAAGX,UAAU,CAACrE,CAAD,CAArB;;AACA,QAAIgF,QAAQ,CAACE,WAAT,GAAuBE,QAA3B,EAAqC;AACpCA,MAAAA,QAAQ,GAAGJ,QAAQ,CAACE,WAApB;AACAG,MAAAA,aAAa,GAAGrF,CAAhB;AACA;AACD;;AACD,SAAO;AAAEsF,IAAAA,MAAM,EAAE,KAAV;AAAiBjG,IAAAA,UAAU,EAAEgF,UAAU,CAACgB,aAAD,CAAV,CAA0BhG,UAAvD;AAAmEkG,IAAAA,QAAQ,EAAElB,UAAU,CAACgB,aAAD,CAAV,CAA0BnB;AAAvG,GAAP;AACA,C,CACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASsB,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","sourcesContent":["//    wrap_lines.js: does line wrap on an already parsed tune.\n//    Copyright (C) 2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction wrapLines(tune, lineBreaks) {\n\tif (!lineBreaks || tune.lines.length === 0)\n\t\treturn;\n\n\t// tune.lines contains nested arrays: there is an array of lines (that's the part this function rewrites),\n\t// there is an array of staffs per line (for instance, piano will have 2, orchestra will have many)\n\t// there is an array of voices per staff (for instance, 4-part harmony might have bass and tenor on a single staff)\n\t// The measure numbers start at zero for each staff, but on the succeeding lines, the measure numbers are reset to the beginning of the line.\n\tvar newLines = [];\n\t// keep track of our counters for each staff and voice\n\tvar startNewLine = [];\n\tvar currentLine = [];\n\tvar measureNumber = [];\n\tvar measureMarker = [];\n\tvar lastMeter = '';\n\tvar voiceStart = {};\n\tvar linesWithoutStaff = 0;\n\n\tfor (var i = 0; i < tune.lines.length; i++) {\n\t\tvar line = tune.lines[i];\n\t\tif (line.staff) {\n\t\t\tvar staffs = line.staff;\n\t\t\tfor (var j = 0; j < staffs.length; j++) {\n\t\t\t\tif (startNewLine[j] === undefined) {\n\t\t\t\t\tstartNewLine[j] = [];\n\t\t\t\t\tcurrentLine[j] = [];\n\t\t\t\t\tmeasureNumber[j] = [];\n\t\t\t\t\tmeasureMarker[j] = [];\n\t\t\t\t}\n\t\t\t\tvar staff = staffs[j];\n\t\t\t\tvar voices = staff.voices;\n\t\t\t\tfor (var k = 0; k < voices.length; k++) {\n\t\t\t\t\tif (startNewLine[j][k] === undefined) {\n\t\t\t\t\t\tstartNewLine[j][k] = true;\n\t\t\t\t\t\tcurrentLine[j][k] = 0;\n\t\t\t\t\t\tmeasureNumber[j][k] = 0;\n\t\t\t\t\t\tmeasureMarker[j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (linesWithoutStaff > 0) currentLine[j][k] += linesWithoutStaff;\n\t\t\t\t\tvar voice = voices[k];\n\t\t\t\t\tfor (var e = 0; e < voice.length; e++) {\n\t\t\t\t\t\tif (startNewLine[j][k]) {\n\t\t\t\t\t\t\tif (!newLines[currentLine[j][k]])\n\t\t\t\t\t\t\t\tnewLines[currentLine[j][k]] = { staff: [] };\n\t\t\t\t\t\t\tif (!newLines[currentLine[j][k]].staff[j]) {\n\t\t\t\t\t\t\t\tnewLines[currentLine[j][k]].staff[j] = {voices: []};\n\t\t\t\t\t\t\t\tfor (var key in staff) {\n\t\t\t\t\t\t\t\t\tif (staff.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t\t\tif (key === 'meter') {\n\t\t\t\t\t\t\t\t\t\t\tif (newLines.length === 1 || lastMeter !== JSON.stringify(staff[key])) {\n\t\t\t\t\t\t\t\t\t\t\t\tlastMeter = JSON.stringify(staff[key]);\n\t\t\t\t\t\t\t\t\t\t\t\tnewLines[currentLine[j][k]].staff[j][key] = staff[key];\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else if (key !== 'voices') {\n\t\t\t\t\t\t\t\t\t\t\tnewLines[currentLine[j][k]].staff[j][key] = staff[key];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (measureMarker[j][k])\n\t\t\t\t\t\t\t\tnewLines[currentLine[j][k]].staff[j].barNumber = measureMarker[j][k];\n\t\t\t\t\t\t\tstartNewLine[j][k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar element = voice[e];\n\t\t\t\t\t\tif (!newLines[currentLine[j][k]].staff[j].voices[k]) {\n\t\t\t\t\t\t\tnewLines[currentLine[j][k]].staff[j].voices[k] = [];\n\t\t\t\t\t\t\tfor (var startItem in voiceStart) {\n\t\t\t\t\t\t\t\tif (voiceStart.hasOwnProperty(startItem)) {\n\t\t\t\t\t\t\t\t\tnewLines[currentLine[j][k]].staff[j].voices[k].push(voiceStart[startItem])\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewLines[currentLine[j][k]].staff[j].voices[k].push(element);\n\t\t\t\t\t\tif (element.el_type === 'stem') {\n\t\t\t\t\t\t\t// This is a nice trick to just pay attention to the last setting of each type.\n\t\t\t\t\t\t\tvoiceStart[element.el_type] = element;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (element.el_type === 'bar') {\n\t\t\t\t\t\t\tmeasureNumber[j][k]++;\n\t\t\t\t\t\t\tif (lineBreaks[measureNumber[j][k]]) {\n\t\t\t\t\t\t\t\tstartNewLine[j][k] = true;\n\t\t\t\t\t\t\t\tcurrentLine[j][k]++;\n\t\t\t\t\t\t\t\tmeasureMarker[j][k] = element.barNumber;\n\t\t\t\t\t\t\t\tdelete element.barNumber;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tlinesWithoutStaff = 0;\n\t\t} else {\n\t\t\tnewLines.push(line);\n\t\t\tlinesWithoutStaff++;\n\t\t}\n\t}\n\ttune.lines = newLines;\n}\n\nfunction freeFormLineBreaks(widths, lineBreakPoint) {\n\tvar lineBreaks = [];\n\tvar totals = [];\n\tvar totalThisLine = 0;\n\t// run through each measure and see if the accumulation is less than the ideal.\n\t// if it passes the ideal, then see whether the last or this one is closer to the ideal.\n\tfor (var i = 0; i < widths.length; i++) {\n\t\tvar width = widths[i];\n\t\tvar attemptedWidth = totalThisLine + width;\n\t\tif (attemptedWidth < lineBreakPoint)\n\t\t\ttotalThisLine = attemptedWidth;\n\t\telse {\n\t\t\t// This just passed the ideal, so see whether the previous or the current number of measures is closer.\n\t\t\tvar oldDistance = lineBreakPoint - totalThisLine;\n\t\t\tvar newDistance = attemptedWidth - lineBreakPoint;\n\t\t\tif (oldDistance < newDistance && totalThisLine > 0) {\n\t\t\t\tlineBreaks.push(i - 1);\n\t\t\t\ttotals.push(Math.round(totalThisLine - width));\n\t\t\t\ttotalThisLine = width;\n\t\t\t} else {\n\t\t\t\tif (i < widths.length-1) {\n\t\t\t\t\tlineBreaks.push(i);\n\t\t\t\t\ttotals.push(Math.round(totalThisLine));\n\t\t\t\t\ttotalThisLine = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ttotals.push(Math.round(totalThisLine));\n\treturn { lineBreaks: lineBreaks, totals: totals };\n}\n\n// function createLineTestArray(numLines, numMeasures, maxMeasuresPerLine, minMeasuresPerLine) {\n// \tvar tries = [];\n// \t// To get all the iterations, it is every digit in a particular base-numbering system.\n// \t// That is, we want to generate every number that is (numLines-1) digits, in base (max-min+1)\n// \t// For instance, for 5 lines where the min is 6 and max is 8, we want ever combination of 4 digits in base 3.\n// \tvar base = maxMeasuresPerLine - minMeasuresPerLine + 1;\n// \tvar digits = numLines - 1; // The last digit is fixed: it is what ever is needed to sum up to the total number of measures.\n// \tvar done = false;\n// \tvar iter = 0;\n// \twhile (!done) {\n// \t\tvar attempt = [];\n// \t\tvar num = iter;\n// \t\tvar total = 0;\n// \t\tfor (var d = digits - 1; d >= 0; d--) {\n// \t\t\tattempt[d] = (num % base) + minMeasuresPerLine;\n// \t\t\tnum = Math.floor(num / base);\n// \t\t\ttotal += attempt[d];\n// \t\t}\n// \t\tif (num > 0)\n// \t\t\tdone = true; // continue until we exceed the greatest number. We know because there is a remainer.\n// \t\telse {\n// \t\t\tvar lastLine = numMeasures - total;\n// \t\t\tif (lastLine >= minMeasuresPerLine && lastLine <= maxMeasuresPerLine) {\n// \t\t\t\tattempt[digits] = lastLine;\n// \t\t\t\ttries.push(attempt);\n// \t\t\t}\n// \t\t\titer++;\n// \t\t}\n// \t}\n// \treturn tries;\n// }\n\n// function getVariance(attempt, idealLineBreak, widths, allowableOverage) {\n// \tvar measureNumber = 0;\n// \tvar thisWorstVariance = 0;\n// \tfor (var j = 0; j < attempt.length; j++) {\n// \t\tvar lineWidth = 0;\n// \t\tvar measuresThisLine = attempt[j];\n// \t\tfor (var k = 0; k < measuresThisLine; k++) {\n// \t\t\tlineWidth += widths[measureNumber++];\n// \t\t}\n// \t\tif (lineWidth > allowableOverage)\n// \t\t\treturn null;\n// \t\tvar variance = Math.abs(lineWidth - idealLineBreak);\n// \t\tif (variance > thisWorstVariance)\n// \t\t\tthisWorstVariance = variance;\n// \t}\n// \treturn thisWorstVariance;\n// }\n\n// function getMaxVariance(widths, lineBreakPoint, lineBreaks) {\n// \tvar maxVariance = 0;\n// \tvar numLines = lineBreaks.length + 1; // the last line doesn't have an explicit break\n// \tvar measureNumber = 0;\n// \tvar totals = [];\n// \tfor (var i = 0; i <= lineBreaks.length; i++) {\n// \t\tvar breakMeasure = (i === lineBreaks.length) ? widths.length : lineBreaks[i];\n// \t\tvar thisTotal = 0;\n// \t\tfor (var j = measureNumber; j < breakMeasure; j++) {\n// \t\t\tthisTotal += widths[j];\n// \t\t}\n// \t\tmeasureNumber = breakMeasure;\n// \t\tvar thisVariance = thisTotal <= lineBreakPoint ? lineBreakPoint - thisTotal : 1000000;\n// \t\ttotals.push({total: thisTotal, variance: thisVariance})\n// \t\tmaxVariance = Math.max(maxVariance, thisVariance);\n// \t}\n//\n// \tconsole.log(lineBreakPoint, totals)\n// \treturn maxVariance;\n// }\n\nfunction getVariance(widths, lineBreaks) {\n\tvar numLines = lineBreaks.length + 1; // the last line doesn't have an explicit break\n\tvar avg = widths.total / numLines;\n\tvar largestVariance = 0;\n\tvar measureNumber = 0;\n\tfor (var i = 0; i <= lineBreaks.length; i++) {\n\t\tvar breakMeasure = (i === lineBreaks.length) ? widths.measureWidths.length-1 : lineBreaks[i];\n\t\tvar thisVariance = lineVariance(widths.measureWidths, measureNumber, breakMeasure, avg);\n\t\tmeasureNumber = breakMeasure+1;\n\t\tlargestVariance = Math.max(largestVariance, thisVariance);\n\t}\n\n\treturn largestVariance;\n}\n\n// function getAvgVariance(widths, lineBreakPoint, lineBreaks) {\n// \tvar totalVariance = 0;\n// \tvar numLines = lineBreaks.length + 1; // the last line doesn't have an explicit break\n// \tvar measureNumber = 0;\n// \tfor (var i = 0; i <= lineBreaks.length; i++) {\n// \t\tvar breakMeasure = (i === lineBreaks.length) ? widths.length : lineBreaks[i];\n// \t\tvar thisTotal = 0;\n// \t\tfor (var j = measureNumber; j < breakMeasure; j++) {\n// \t\t\tthisTotal += widths[j];\n// \t\t}\n// \t\tmeasureNumber = breakMeasure;\n// \t\tvar thisVariance = Math.abs(lineBreakPoint - thisTotal);\n// \t\ttotalVariance += thisVariance;\n// \t}\n//\n// \treturn totalVariance / numLines;\n// }\n\nfunction lineVariance(widths, start, end, avg) {\n\tvar thisTotal = lineWidth(widths, start, end);\n\tvar thisVariance = Math.abs(avg - thisTotal);\n\treturn thisVariance;\n}\n\nfunction lineWidth(widths, start, end) {\n\tvar thisTotal = 0;\n\tfor (var j = start; j <= end; j++)\n\t\tthisTotal += widths[j];\n\treturn thisTotal;\n}\n\n// TODO-PER: For long pieces of music, this can get long, so stop finding the combinations at an arbitrary place.\nfunction getAttempts(widths, start, linesLeft, min, max, lastLines) {\n\tvar MAX_COMBINATIONS = 1200;\n\tvar acc = 0;\n\tvar attempts = [];\n\tfor (var i = start; i < widths.length && acc < max; i++) {\n\t\tacc += widths[i];\n\t\tif (acc > max)\n\t\t\tbreak;\n\t\tif (acc > min) {\n\t\t\tif (linesLeft > 0 && attempts.length < MAX_COMBINATIONS) {\n\t\t\t\tvar nextLines = getAttempts(widths, i + 1, linesLeft - 1, min, max, lastLines);\n\t\t\t\tfor (var j = 0; j < nextLines.length; j++)\n\t\t\t\t\tattempts.push([i].concat(nextLines[j]));\n\t\t\t}\n\t\t\tif (linesLeft === 1 && lastLines.indexOf(i) >= 0)\n\t\t\t\tattempts.push([i]);\n\t\t}\n\t}\n\treturn attempts;\n}\n\nfunction lastLinePossibilities(widths, start, min, max) {\n\tvar acc = 0;\n\tvar possibilities = [];\n\tfor (var i = widths.length-1; i >= 0; i--) {\n\t\tacc += widths[i];\n\t\tif (acc > max)\n\t\t\tbreak;\n\t\tif (acc > min && i < start) {\n\t\t\tpossibilities.push(i-1);\n\t\t}\n\t}\n\treturn possibilities;\n}\n\nfunction clone(arr) {\n\tvar newArr = [];\n\tfor (var i = 0; i < arr.length; i++)\n\t\tnewArr.push(arr[i]);\n\treturn newArr;\n}\n\nfunction oneTry(measureWidths, idealWidths, accumulator, lineAccumulator, lineWidths, lastVariance, highestVariance, currLine, lineBreaks, startIndex, otherTries) {\n\tfor (var i = startIndex; i < measureWidths.length; i++) {\n\t\tvar measureWidth = measureWidths[i];\n\t\taccumulator += measureWidth;\n\t\tlineAccumulator += measureWidth;\n\t\tvar thisVariance = Math.abs(accumulator - idealWidths[currLine]);\n\t\tvar varianceIsClose = Math.abs(thisVariance - lastVariance) < idealWidths[0] / 10; // see if the difference is less than 10%, if so, run the test both ways.\n\t\tif (varianceIsClose) {\n\t\t\tif (thisVariance < lastVariance) {\n\t\t\t\t// Also attempt one less measure on the current line - sometimes that works out better.\n\t\t\t\tvar newWidths = clone(lineWidths);\n\t\t\t\tvar newBreaks = clone(lineBreaks);\n\t\t\t\tnewBreaks.push(i-1);\n\t\t\t\tnewWidths.push(lineAccumulator - measureWidth);\n\t\t\t\totherTries.push({\n\t\t\t\t\taccumulator: accumulator,\n\t\t\t\t\tlineAccumulator: measureWidth,\n\t\t\t\t\tlineWidths: newWidths,\n\t\t\t\t\tlastVariance: Math.abs(accumulator - idealWidths[currLine+1]),\n\t\t\t\t\thighestVariance: Math.max(highestVariance, lastVariance),\n\t\t\t\t\tcurrLine: currLine+1,\n\t\t\t\t\tlineBreaks: newBreaks,\n\t\t\t\t\tstartIndex: i+1});\n\t\t\t} else if (thisVariance > lastVariance && i < measureWidths.length-1) {\n\t\t\t\t// Also attempt one extra measure on this line.\n\t\t\t\tnewWidths = clone(lineWidths);\n\t\t\t\tnewBreaks = clone(lineBreaks);\n\t\t\t\t// newBreaks[newBreaks.length-1] = i;\n\t\t\t\t// newWidths[newWidths.length-1] = lineAccumulator;\n\t\t\t\totherTries.push({\n\t\t\t\t\taccumulator: accumulator,\n\t\t\t\t\tlineAccumulator: lineAccumulator,\n\t\t\t\t\tlineWidths: newWidths,\n\t\t\t\t\tlastVariance: thisVariance,\n\t\t\t\t\thighestVariance: Math.max(highestVariance, thisVariance),\n\t\t\t\t\tcurrLine: currLine,\n\t\t\t\t\tlineBreaks: newBreaks,\n\t\t\t\t\tstartIndex: i+1});\n\t\t\t}\n\t\t}\n\t\tif (thisVariance > lastVariance) {\n\t\t\tlineBreaks.push(i - 1);\n\t\t\tcurrLine++;\n\t\t\thighestVariance = Math.max(highestVariance, lastVariance);\n\t\t\tlastVariance = Math.abs(accumulator - idealWidths[currLine]);\n\t\t\tlineWidths.push(lineAccumulator - measureWidth);\n\t\t\tlineAccumulator = measureWidth;\n\t\t} else {\n\t\t\tlastVariance = thisVariance;\n\t\t}\n\t}\n\tlineWidths.push(lineAccumulator);\n}\n\nfunction optimizeLineWidths(widths, lineBreakPoint, lineBreaks, explanation) {\n\t//\tfigure out how many lines - That's one more than was tried before.\n\tvar numLines = Math.ceil(widths.total / lineBreakPoint) + 1;\n\n\t//\tget the ideal width for a line (cumulative width / num lines) - approx the same as lineBreakPoint except for rounding\n\tvar idealWidth = Math.floor(widths.total / numLines);\n\n\t//\tget each ideal line width (1*ideal, 2*ideal, 3*ideal, etc)\n\tvar idealWidths = [];\n\tfor (var i = 0; i < numLines; i++)\n\t\tidealWidths.push(idealWidth*(i+1));\n\n\t//\tfrom first measure, step through accum. Widths until the abs of the ideal is greater than the last one.\n\t// This can sometimes look funny in edge cases, so when the length is within 10%, try one more or one less to see which is better.\n\t// This is better than trying all the possibilities because that would get to be a huge number for even a medium size piece.\n\t// This method seems to never generate more than about 16 tries and it is usually 4 or less.\n\tvar otherTries = [];\n\totherTries.push({\n\t\taccumulator: 0,\n\t\tlineAccumulator: 0,\n\t\tlineWidths: [],\n\t\tlastVariance: 999999,\n\t\thighestVariance: 0,\n\t\tcurrLine: 0,\n\t\tlineBreaks: [], // These are the zero-based last measure on each line\n\t\tstartIndex: 0});\n\tvar index = 0;\n\twhile (index < otherTries.length) {\n\t\toneTry(widths.measureWidths,\n\t\t\tidealWidths,\n\t\t\totherTries[index].accumulator,\n\t\t\totherTries[index].lineAccumulator,\n\t\t\totherTries[index].lineWidths,\n\t\t\totherTries[index].lastVariance,\n\t\t\totherTries[index].highestVariance,\n\t\t\totherTries[index].currLine,\n\t\t\totherTries[index].lineBreaks,\n\t\t\totherTries[index].startIndex,\n\t\t\totherTries);\n\t\tindex++;\n\t}\n\tfor (i = 0; i < otherTries.length; i++) {\n\t\tvar otherTry = otherTries[i];\n\t\totherTry.variances = [];\n\t\totherTry.aveVariance = 0;\n\t\tfor (var j = 0; j < otherTry.lineWidths.length; j++) {\n\t\t\tvar lineWidth = otherTry.lineWidths[j];\n\t\t\totherTry.variances.push(lineWidth - idealWidths[0]);\n\t\t\totherTry.aveVariance += Math.abs(lineWidth - idealWidths[0]);\n\t\t}\n\t\totherTry.aveVariance =  otherTry.aveVariance / otherTry.lineWidths.length;\n\t\texplanation.attempts.push({ type: \"optimizeLineWidths\", lineBreaks: otherTry.lineBreaks, variances: otherTry.variances, aveVariance: otherTry.aveVariance, widths: widths.measureWidths });\n\t}\n\tvar smallest = 9999999;\n\tvar smallestIndex = -1;\n\tfor (i = 0; i < otherTries.length; i++) {\n\t\totherTry = otherTries[i];\n\t\tif (otherTry.aveVariance < smallest) {\n\t\t\tsmallest = otherTry.aveVariance;\n\t\t\tsmallestIndex = i;\n\t\t}\n\t}\n\treturn { failed: false, lineBreaks: otherTries[smallestIndex].lineBreaks, variance: otherTries[smallestIndex].highestVariance };\n}\n// \t// Instead of having to try all the different combinations to find the best, we start with an important piece of knowledge about the lineBreaks we are given:\n// \t// If there is a line too short, it is the last one.\n// \t// So, let's just do a couple of tweaks to see how it works to add one or two measures to the last line.\n// \tvar avg = widths.total / (lineBreaks.length + 1);\n// \tvar variance = getVariance(widths, lineBreaks);\n// \tvar variancePct = variance/lineBreakPoint*100;\n//\n// \tif (lineBreaks.length === 0)\n// \t\treturn { failed: true, reason: \"Only one line.\" };\n//\n// \tvar lastLineStart = lineBreaks[lineBreaks.length-1]+1;\n// \tvar lastLineVariance = lineVariance(widths.measureWidths, lastLineStart, widths.measureWidths.length, avg);\n// \tif (variance > lastLineVariance)\n// \t\treturn { failed: true, reason: \"Last line is not too short.\" };\n//\n// \t// Let's get a list of all combinations that have a possibility of working. That is, all combinations where no line has a variance larger than \"variance\".\n// \tvar lastLines = lastLinePossibilities(widths.measureWidths, lastLineStart, avg - variance, avg + variance);\n// \tvar attempts = getAttempts(widths.measureWidths, 0, lineBreaks.length, avg - variance, avg + variance, lastLines);\n// \t//console.log(attempts, avg - variance, avg + variance);\n//\n// \tvar failed = true;\n// \tfor (var i = 0; i < attempts.length; i++) {\n// \t\tvar newVariance = getVariance(widths, attempts[i]);\n// \t\tif (newVariance < variance) {\n// \t\t\texplanation.attempts.push({\n// \t\t\t\ttype: \"Optimize try\", lineBreaks: attempts[i],\n// \t\t\t\tvariance: Math.round(variance), newVariance: Math.round(newVariance),\n// \t\t\t\ttotalAttempts: attempts.length\n// \t\t\t});\n// \t\t\tvariance = newVariance;\n// \t\t\tlineBreaks = attempts[i];\n// \t\t\tfailed = false;\n// \t\t}\n// \t}\n// \tif (failed) {\n// \t\texplanation.attempts.push({ type: \"Optimize try\", lineBreaks: lineBreaks, variance: variance, reason: \"None of the \" + attempts.length + \" attempts were better.\" });\n// \t\t// TODO-PER: This shouldn't be necessary, but just try to move one measure down and see if it helps.\n// \t\tif (lineBreaks.length > 0) {\n// \t\t\tvar attempt = [].concat(lineBreaks);\n// \t\t\tattempt[attempt.length - 1]--;\n// \t\t\tnewVariance = getVariance(widths, attempt);\n// \t\t\texplanation.attempts.push({\n// \t\t\t\ttype: \"Optimize last try\", lineBreaks: attempts[i],\n// \t\t\t\tvariance: Math.round(variance), newVariance: Math.round(newVariance),\n// \t\t\t\ttotalAttempts: attempts.length\n// \t\t\t});\n// \t\t\tif (newVariance < variance) {\n// \t\t\t\tvariance = newVariance;\n// \t\t\t\tlineBreaks = attempt;\n// \t\t\t\tfailed = false;\n// \t\t\t}\n// \t\t}\n// \t}\n// \t// Let's squeeze the line successively until it spills onto an extra line, then take the option with the lowest variance\n// \t// var targetNumLines = lineBreaks.length;\n// \t// var newNumLines = targetNumLines;\n// \t// var TRY_INCREMENT = 1;\n// \t// var tryBreakPoint = lineBreakPoint - TRY_INCREMENT;\n// \t// var failed = true;\n// \t// while (targetNumLines === newNumLines && tryBreakPoint > 50) {\n// \t// \tvar ff = freeFormLineBreaks(widths.measureWidths, tryBreakPoint);\n// \t// \tnewNumLines = ff.lineBreaks.length;\n// \t// \tif (newNumLines === targetNumLines) {\n// \t// \t\tvar newVariance = getVariance(widths, ff.lineBreaks);\n// \t// \t\tvar newVariancePct = newVariance/tryBreakPoint*100;\n// \t// \t\texplanation.attempts.push({type: \"Optimize try\", tryBreakPoint: Math.round(tryBreakPoint), lineBreaks: ff.lineBreaks, totals: ff.totals,\n// \t// \t\t\tvariance: Math.round(variance), newVariance: Math.round(newVariance), variancePct: Math.round(variancePct), newVariancePct: Math.round(newVariancePct)\n// \t// \t\t});\n// \t// \t\tif (newVariancePct < variancePct) {\n// \t// \t\t\tvariancePct = newVariancePct;\n// \t// \t\t\tlineBreaks = ff.lineBreaks;\n// \t// \t\t\tfailed = false;\n// \t// \t\t}\n// \t// \t} else {\n// \t// \t\texplanation.attempts.push({type: \"Optimize try\", explanation: \"Exceeded number of lines.\" , tryBreakPoint: Math.round(tryBreakPoint), lineBreaks: ff.lineBreaks, totals: ff.totals, variance: variance, avg: avg, variancePct: variancePct});\n// \t// \t}\n// \t// \ttryBreakPoint -= TRY_INCREMENT;\n// \t// }\n//\n// \treturn { failed: failed, lineBreaks: lineBreaks, variance: variance };\n// }\n\n// function fixedNumLinesBreaks(widths, numLines, allowOver, allowableVariance) {\n// \tvar idealLineBreak = widths.total / numLines;\n// \t// If all the measures had the same amount of stuff, then the ave would be correct.\n// \t// We will test all the combinations from one less to one more than the average.\n// \tvar averageMeasuresPerLine = Math.round(widths.measureWidths.length / numLines);\n// \tvar minMeasuresPerLine = Math.max(averageMeasuresPerLine - 1, 1);\n// \tvar maxMeasuresPerLine = averageMeasuresPerLine + 1;\n// \tvar tries = createLineTestArray(numLines, widths.measureWidths.length, maxMeasuresPerLine, minMeasuresPerLine);\n// \tconsole.log(\"fixedNumLinesBreaks tests (\"+minMeasuresPerLine+'-'+maxMeasuresPerLine+\")\", numLines, tries.length)\n//\n// \t// For each possible number of measures per line, see which has the closest spacing to the ideal.\n// \tvar bestCase = -1;\n// \tvar bestCaseVariance = 1000000;\n// \tfor (var i = 0 ; i < tries.length; i++) {\n// \t\tvar attempt = tries[i];\n// \t\tvar variance = getVariance(attempt, idealLineBreak, widths.measureWidths, allowOver ? allowableVariance : 0);\n// \t\tif (variance !== null) {\n// \t\t\tif (variance < bestCaseVariance) {\n// \t\t\t\tbestCaseVariance = variance;\n// \t\t\t\tbestCase = i;\n// \t\t\t}\n// \t\t}\n// \t}\n// \tvar failed = true;\n// \t// For debugging, recreate the line widths\n// \tvar totals = [];\n// \tif (bestCase >= 0) {\n// \t\tfailed = false;\n// \t\tvar index = 0;\n// \t\tfor (i = 0; i < tries[bestCase].length; i++) {\n// \t\t\tvar total = 0;\n// \t\t\tfor (var j = 0; j < tries[bestCase][i]; j++) {\n// \t\t\t\ttotal += widths.measureWidths[index++];\n// \t\t\t}\n// \t\t\ttotals.push(Math.round(total));\n// \t\t}\n// \t\t// We now have an array that contains the number of measures per line, but we want to return the absolute measure number to break on.\n// \t\tif (tries[bestCase].length > 0) {\n// \t\t\ttries[bestCase][0]--; // The results should contain the last measure number on the line, zero-based.\n// \t\t\tfor (i = 1; i < tries[bestCase].length; i++)\n// \t\t\t\ttries[bestCase][i] += tries[bestCase][i - 1]; // This sets the zero-based measure number\n// \t\t\t// The last line is implied and we don't need to return it\n// \t\t\ttries[bestCase].pop();\n// \t\t}\n// \t}\n// \treturn { failed: failed, lineBreaks: tries[bestCase], bestCaseVariance: Math.round(bestCaseVariance), totals: totals };\n// }\n\nfunction fixedMeasureLineBreaks(widths, lineBreakPoint, preferredMeasuresPerLine) {\n\tvar lineBreaks = [];\n\tvar totals = [];\n\tvar thisWidth = 0;\n\tvar failed = false;\n\tfor (var i = 0; i < widths.length; i++) {\n\t\tthisWidth += widths[i];\n\t\tif (thisWidth > lineBreakPoint) {\n\t\t\tfailed = true;\n\t\t}\n\t\tif (i % preferredMeasuresPerLine === (preferredMeasuresPerLine-1)) {\n\t\t\tif (i !== widths.length-1) // Don't bother putting a line break for the last line - it's already a break.\n\t\t\t\tlineBreaks.push(i);\n\t\t\ttotals.push(Math.round(thisWidth));\n\t\t\tthisWidth = 0;\n\t\t}\n\t}\n\treturn { failed: failed, totals: totals, lineBreaks: lineBreaks };\n}\n\nfunction getRevisedTune(lineBreaks, staffWidth, abcString, params, Parse) {\n\tvar abcParser = new Parse();\n\tvar revisedParams = {\n\t\tlineBreaks: lineBreaks,\n\t\tstaffwidth: staffWidth\n\t};\n\tfor (var key in params) {\n\t\tif (params.hasOwnProperty(key) && key !== 'wrap' && key !== 'staffwidth') {\n\t\t\trevisedParams[key] = params[key];\n\t\t}\n\t}\n\n\tabcParser.parse(abcString, revisedParams);\n\treturn { tune: abcParser.getTune(), revisedParams: revisedParams };\n}\n\nfunction calcLineWraps(tune, widths, abcString, params, Parse, engraver_controller) {\n\t// For calculating how much can go on the line, it depends on the width of the line. It is a convenience to just divide it here\n\t// by the minimum spacing instead of multiplying the min spacing later.\n\t// The scaling works differently: this is done by changing the scaling of the outer SVG, so the scaling needs to be compensated\n\t// for here, because the actual width will be different from the calculated numbers.\n\n\t// If the desired width is less than the margin, just punt and return the original tune\n\tif (params.staffwidth < widths.left) {\n\t\treturn {\n\t\t\texplanation: \"Staffwidth is narrower than the margin\",\n\t\t\ttune: tune,\n\t\t\trevisedParams: params\n\t\t};\n\t}\n\tvar scale = params.scale ? Math.max(params.scale, 0.1) : 1;\n\tvar minSpacing = params.wrap.minSpacing ? Math.max(parseFloat(params.wrap.minSpacing), 1) : 1;\n\tvar minSpacingLimit = params.wrap.minSpacingLimit ? Math.max(parseFloat(params.wrap.minSpacingLimit), 1) : minSpacing - 0.1;\n\tvar maxSpacing = params.wrap.maxSpacing ? Math.max(parseFloat(params.wrap.maxSpacing), 1) : undefined;\n\tif (params.wrap.lastLineLimit && !maxSpacing)\n\t\tmaxSpacing = Math.max(parseFloat(params.wrap.lastLineLimit), 1);\n\tvar targetHeight = params.wrap.targetHeight ? Math.max(parseInt(params.wrap.targetHeight, 10), 100) : undefined;\n\tvar preferredMeasuresPerLine = params.wrap.preferredMeasuresPerLine ? Math.max(parseInt(params.wrap.preferredMeasuresPerLine, 10), 1) : undefined;\n\n\tvar lineBreakPoint = (params.staffwidth - widths.left) / minSpacing / scale;\n\tvar minLineSize = (params.staffwidth - widths.left) / maxSpacing / scale;\n\tvar allowableVariance = (params.staffwidth - widths.left) / minSpacingLimit / scale;\n\tvar explanation = { widths: widths, lineBreakPoint: lineBreakPoint, minLineSize: minLineSize, attempts: [], staffWidth: params.staffwidth, minWidth: Math.round(allowableVariance) };\n\n\t// If there is a preferred number of measures per line, test that first. If none of the lines is too long, then we're finished.\n\tvar lineBreaks = null;\n\tif (preferredMeasuresPerLine) {\n\t\tvar f = fixedMeasureLineBreaks(widths.measureWidths, lineBreakPoint, preferredMeasuresPerLine);\n\t\texplanation.attempts.push({ type: \"Fixed Measures Per Line\", preferredMeasuresPerLine: preferredMeasuresPerLine, lineBreaks: f.lineBreaks, failed: f.failed, totals: f.totals });\n\t\tif (!f.failed)\n\t\t\tlineBreaks = f.lineBreaks;\n\t}\n\n\t// If we don't have lineBreaks yet, use the free form method of line breaks.\n\t// This will be called either if Preferred Measures is not used, or if the music is just weird - like a single measure is way too crowded.\n\tif (!lineBreaks) {\n\t\tvar ff = freeFormLineBreaks(widths.measureWidths, lineBreakPoint);\n\t\texplanation.attempts.push({ type: \"Free Form\", lineBreaks: ff.lineBreaks, totals: ff.totals });\n\t\tlineBreaks = ff.lineBreaks;\n\n\t\t// We now have an acceptable number of lines, but the measures may not be optimally distributed. See if there is a better distribution.\n\t\tff = optimizeLineWidths(widths, lineBreakPoint, lineBreaks, explanation);\n\t\texplanation.attempts.push({ type: \"Optimize\", failed: ff.failed, reason: ff.reason, lineBreaks: ff.lineBreaks, totals: ff.totals });\n\t\tif (!ff.failed)\n\t\t\tlineBreaks = ff.lineBreaks;\n\t}\n\n\t// If the vertical space exceeds targetHeight, remove a line and try again. If that is too crowded, then don't use it.\n\tvar staffWidth = params.staffwidth;\n\tvar ret = getRevisedTune(lineBreaks, staffWidth, abcString, params, Parse);\n\tvar newWidths = engraver_controller.getMeasureWidths(ret.tune);\n\tvar gotTune = true; // If we adjust the num lines, set this to false\n\texplanation.attempts.push({type: \"heightCheck\", height: newWidths.height });\n\n\t// \tif all of the lines are too sparse, make the width narrower.\n\t// TODO-PER: implement this case.\n\n\t// If one line and the spacing is > maxSpacing, make the width narrower.\n\tif (lineBreaks.length === 0 && minLineSize > widths.total) {\n\t\tstaffWidth = (widths.total * maxSpacing * scale) + widths.left;\n\t\texplanation.attempts.push({type: \"too sparse\", newWidth: Math.round(staffWidth)})\n\t\tgotTune = false;\n\t}\n\n\t// if (ret.lineBreaks.length === 0) {\n\t// \t// Everything fits on one line, so see if there is TOO much space and the staff width needs to be shortened.\n\t// \tif (minLineSize > 0 && ret.totalThisLine > 0 && ret.totalThisLine < minLineSize)\n\t// \t\tstaffWidth = staffWidth / (minLineSize / ret.totalThisLine);\n\t// } else if (ret.totalThisLine < minLineSize) {\n\t// \t// the last line is too short, so attempt to redistribute by changing the min.\n\t// \t// We will try more and less space alternatively. The space can't be less than 1.0, and we'll try in 0.1 increments.\n\t// \tvar minTrys = [];\n\t// \tif (minSpacing > 1.1)\n\t// \t\tminTrys.push(minSpacing - 0.1);\n\t// \tminTrys.push(minSpacing + 0.1);\n\t// \tif (minSpacing > 1.2)\n\t// \t\tminTrys.push(minSpacing - 0.2);\n\t// \tminTrys.push(minSpacing + 0.2);\n\t// \tif (minSpacing > 1.3)\n\t// \t\tminTrys.push(minSpacing - 0.3);\n\t// \tminTrys.push(minSpacing + 0.3);\n\t// \tfor (var i = 0; i < minTrys.length && ret.totalThisLine < minLineSize; i++) {\n\t// \t\tlineBreakPoint = (params.staffwidth - widths.left) / minTrys[i] / scale;\n\t// \t\tret = calcLineBreaks(widths.measureWidths, lineBreakPoint);\n\t// \t}\n\t// }\n\n\tif (!gotTune)\n\t\tret = getRevisedTune(lineBreaks, staffWidth, abcString, params, Parse);\n\tret.explanation = explanation;\n\treturn ret;\n}\n\nmodule.exports = { wrapLines: wrapLines, calcLineWraps: calcLineWraps };\n"]},"metadata":{},"sourceType":"script"}