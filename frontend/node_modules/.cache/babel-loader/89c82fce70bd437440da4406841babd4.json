{"ast":null,"code":"//    abc_tune.js: a computer usable internal structure representing one tune.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar parseCommon = require('../parse/abc_common');\n\nvar parseKeyVoice = require('../parse/abc_parse_key_voice');\n\nvar spacing = require('../write/abc_spacing');\n/**\n * This is the data for a single ABC tune. It is created and populated by the window.ABCJS.parse.Parse class.\n * Also known as the ABCJS Abstract Syntax Tree\n * @alternateClassName ABCJS.Tune\n */\n\n\nvar Tune = function () {\n  // The structure consists of a hash with the following two items:\n  // metaText: a hash of {key, value}, where key is one of: title, author, rhythm, source, transcription, unalignedWords, etc...\n  // tempo: { noteLength: number (e.g. .125), bpm: number }\n  // lines: an array of elements, or one of the following:\n  //\n  // STAFF: array of elements\n  // SUBTITLE: string\n  //\n  // TODO: actually, the start and end char should modify each part of the note type\n  // The elements all have a type field and a start and end char\n  // field. The rest of the fields depend on the type and are listed below:\n  // REST: duration=1,2,4,8; chord: string\n  // NOTE: accidental=none,dbl_flat,flat,natural,sharp,dbl_sharp\n  //\t\tpitch: \"C\" is 0. The numbers refer to the pitch letter.\n  //\t\tduration: .5 (sixteenth), .75 (dotted sixteenth), 1 (eighth), 1.5 (dotted eighth)\n  //\t\t\t2 (quarter), 3 (dotted quarter), 4 (half), 6 (dotted half) 8 (whole)\n  //\t\tchord: { name:chord, position: one of 'default', 'above', 'below' }\n  //\t\tend_beam = true or undefined if this is the last note in a beam.\n  //\t\tlyric: array of { syllable: xxx, divider: one of \" -_\" }\n  //\t\tstartTie = true|undefined\n  //\t\tendTie = true|undefined\n  //\t\tstartTriplet = num <- that is the number to print\n  //\t\tendTriplet = true|undefined (the last note of the triplet)\n  // TODO: actually, decoration should be an array.\n  //\t\tdecoration: upbow, downbow, accent\n  // BAR: type=bar_thin, bar_thin_thick, bar_thin_thin, bar_thick_thin, bar_right_repeat, bar_left_repeat, bar_double_repeat\n  //\tnumber: 1 or 2: if it is the start of a first or second ending\n  // CLEF: type=treble,bass\n  // KEY-SIG:\n  //\t\taccidentals[]: { acc:sharp|dblsharp|natural|flat|dblflat,  note:a|b|c|d|e|f|g }\n  // METER: type: common_time,cut_time,specified\n  //\t\tif specified, { num: 99, den: 99 }\n  this.getBeatLength = function () {\n    for (var i = 0; i < this.lines.length; i++) {\n      if (this.lines[i].staff) {\n        for (var j = 0; j < this.lines[i].staff.length; j++) {\n          if (this.lines[i].staff[j].meter) {\n            var meter = this.lines[i].staff[j].meter;\n\n            if (meter.type === \"specified\") {\n              if (meter.value.length > 0) {\n                var num = parseInt(meter.value[0].num, 10);\n                var den = parseInt(meter.value[0].den, 10);\n                if (num === 3 && den === 8) return 3 / 8;\n                if (num === 6 && den === 8) return 3 / 8;\n                if (num === 6 && den === 4) return 3 / 4;\n                if (num === 9 && den === 8) return 3 / 8;\n                if (num === 12 && den === 8) return 3 / 8;\n                return 1 / den;\n              } else return 1 / 4; // No meter was specified, so use this default\n\n            } else if (meter.type === 'cut_time') {\n              return 1 / 2;\n            } else {\n              return 1 / 4; // TODO-PER: this works for common time, but not for the ancient meters.\n            }\n          }\n        }\n      }\n    }\n\n    return 1 / 4; // No meter was specified, so use this default\n  };\n\n  this.getPickupLength = function () {\n    var pickupLength = 0;\n    var barLength = this.getBarLength();\n\n    for (var i = 0; i < this.lines.length; i++) {\n      if (this.lines[i].staff) {\n        for (var j = 0; j < this.lines[i].staff.length; j++) {\n          for (var v = 0; v < this.lines[i].staff[j].voices.length; v++) {\n            var voice = this.lines[i].staff[j].voices[v];\n            var hasNote = false;\n            var tripletMultiplier = 1;\n\n            for (var el = 0; el < voice.length; el++) {\n              var isSpacer = voice[el].rest && voice[el].rest.type === \"spacer\";\n              if (voice[el].startTriplet) tripletMultiplier = voice[el].tripletMultiplier;\n              if (voice[el].duration && !isSpacer) pickupLength += voice[el].duration * tripletMultiplier;\n              if (voice[el].endTriplet) tripletMultiplier = 1;\n              if (pickupLength >= barLength) pickupLength -= barLength;\n              if (voice[el].el_type === 'bar') return pickupLength;\n            }\n          }\n        }\n      }\n    }\n\n    return pickupLength;\n  };\n\n  this.getBarLength = function () {\n    var meter = this.getMeterFraction();\n    return meter.num / meter.den;\n  };\n\n  this.millisecondsPerMeasure = function (bpmOverride) {\n    var bpm;\n\n    if (bpmOverride) {\n      bpm = bpmOverride;\n    } else {\n      var tempo = this.metaText ? this.metaText.tempo : null;\n      bpm = this.getBpm(tempo);\n    }\n\n    if (bpm <= 0) bpm = 1; // I don't think this can happen, but we don't want a possibility of dividing by zero.\n\n    var beatsPerMeasure = this.getBeatsPerMeasure();\n    var minutesPerMeasure = beatsPerMeasure / bpm;\n    return minutesPerMeasure * 60000;\n  };\n\n  this.getBeatsPerMeasure = function () {\n    var beatsPerMeasure;\n    var meter = this.getMeterFraction();\n\n    if (meter.den === 8) {\n      beatsPerMeasure = meter.num / 3;\n    } else {\n      beatsPerMeasure = meter.num;\n    }\n\n    if (beatsPerMeasure <= 0) // This probably won't happen in any normal case - but it is possible that the meter could be set to something nonsensical.\n      beatsPerMeasure = 1;\n    return beatsPerMeasure;\n  };\n\n  this.reset = function () {\n    this.version = \"1.0.1\";\n    this.media = \"screen\";\n    this.metaText = {};\n    this.formatting = {};\n    this.lines = [];\n    this.staffNum = 0;\n    this.voiceNum = 0;\n    this.lineNum = 0;\n  };\n\n  this.resolveOverlays = function () {\n    var madeChanges = false;\n\n    for (var i = 0; i < this.lines.length; i++) {\n      var line = this.lines[i];\n\n      if (line.staff) {\n        for (var j = 0; j < line.staff.length; j++) {\n          var staff = line.staff[j];\n          var overlayVoice = [];\n\n          for (var k = 0; k < staff.voices.length; k++) {\n            var voice = staff.voices[k];\n            overlayVoice.push({\n              hasOverlay: false,\n              voice: [],\n              snip: []\n            });\n            var durationThisBar = 0;\n            var inOverlay = false;\n            var snipStart = -1;\n\n            for (var kk = 0; kk < voice.length; kk++) {\n              var event = voice[kk];\n\n              if (event.el_type === \"overlay\" && !inOverlay) {\n                madeChanges = true;\n                inOverlay = true;\n                snipStart = kk;\n                overlayVoice[k].hasOverlay = true;\n              } else if (event.el_type === \"bar\") {\n                if (inOverlay) {\n                  // delete the overlay events from this array without messing up this loop.\n                  inOverlay = false;\n                  overlayVoice[k].snip.push({\n                    start: snipStart,\n                    len: kk - snipStart\n                  });\n                  overlayVoice[k].voice.push(event); // Also end the overlay with the barline.\n                } else {\n                  // This keeps the voices lined up: if the overlay isn't in the first measure then we need a bunch of invisible rests.\n                  if (durationThisBar > 0) overlayVoice[k].voice.push({\n                    el_type: \"note\",\n                    duration: durationThisBar,\n                    rest: {\n                      type: \"invisible\"\n                    },\n                    startChar: event.startChar,\n                    endChar: event.endChar\n                  });\n                  overlayVoice[k].voice.push(event);\n                }\n\n                durationThisBar = 0;\n              } else if (event.el_type === \"note\") {\n                if (inOverlay) {\n                  overlayVoice[k].voice.push(event);\n                } else {\n                  durationThisBar += event.duration;\n                }\n              } else if (event.el_type === \"scale\" || event.el_type === \"stem\" || event.el_type === \"overlay\" || event.el_type === \"style\" || event.el_type === \"transpose\") {\n                // These types of events are duplicated on the overlay layer.\n                overlayVoice[k].voice.push(event);\n              }\n            }\n\n            if (overlayVoice[k].hasOverlay && overlayVoice[k].snip.length === 0) {\n              // there was no closing bar, so we didn't set the snip amount.\n              overlayVoice[k].snip.push({\n                start: snipStart,\n                len: voice.length - snipStart\n              });\n            }\n          }\n\n          for (k = 0; k < overlayVoice.length; k++) {\n            var ov = overlayVoice[k];\n\n            if (ov.hasOverlay) {\n              staff.voices.push(ov.voice);\n\n              for (var kkk = ov.snip.length - 1; kkk >= 0; kkk--) {\n                var snip = ov.snip[kkk];\n                staff.voices[k].splice(snip.start, snip.len);\n              } // remove ending marks from the overlay voice so they are not repeated\n\n\n              for (kkk = 0; kkk < staff.voices[staff.voices.length - 1].length; kkk++) {\n                staff.voices[staff.voices.length - 1][kkk] = parseCommon.clone(staff.voices[staff.voices.length - 1][kkk]);\n                var el = staff.voices[staff.voices.length - 1][kkk];\n\n                if (el.el_type === 'bar' && el.startEnding) {\n                  delete el.startEnding;\n                }\n\n                if (el.el_type === 'bar' && el.endEnding) delete el.endEnding;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return madeChanges;\n  };\n\n  function fixTitles(lines) {\n    // We might have name and subname defined. We now know what line everything is on, so we can determine which to use.\n    var firstMusicLine = true;\n\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i];\n\n      if (line.staff) {\n        for (var j = 0; j < line.staff.length; j++) {\n          var staff = line.staff[j];\n\n          if (staff.title) {\n            var hasATitle = false;\n\n            for (var k = 0; k < staff.title.length; k++) {\n              if (staff.title[k]) {\n                staff.title[k] = firstMusicLine ? staff.title[k].name : staff.title[k].subname;\n                if (staff.title[k]) hasATitle = true;else staff.title[k] = '';\n              } else staff.title[k] = '';\n            }\n\n            if (!hasATitle) delete staff.title;\n          }\n        }\n\n        firstMusicLine = false;\n      }\n    }\n  }\n\n  this.cleanUp = function (defWidth, defLength, barsperstaff, staffnonote, currSlur) {\n    this.closeLine(); // Close the last line.\n    // If the tempo was created with a string like \"Allegro\", then the duration of a beat needs to be set at the last moment, when it is most likely known.\n\n    if (this.metaText.tempo && this.metaText.tempo.bpm && !this.metaText.tempo.duration) this.metaText.tempo.duration = [this.getBeatLength()]; // Remove any blank lines\n\n    var anyDeleted = false;\n    var i, s, v;\n\n    for (i = 0; i < this.lines.length; i++) {\n      if (this.lines[i].staff !== undefined) {\n        var hasAny = false;\n\n        for (s = 0; s < this.lines[i].staff.length; s++) {\n          if (this.lines[i].staff[s] === undefined) {\n            anyDeleted = true;\n            this.lines[i].staff[s] = null; //this.lines[i].staff[s] = { voices: []};\t// TODO-PER: There was a part missing in the abc music. How should we recover?\n          } else {\n            for (v = 0; v < this.lines[i].staff[s].voices.length; v++) {\n              if (this.lines[i].staff[s].voices[v] === undefined) this.lines[i].staff[s].voices[v] = []; // TODO-PER: There was a part missing in the abc music. How should we recover?\n              else if (this.containsNotes(this.lines[i].staff[s].voices[v])) hasAny = true;\n            }\n          }\n        }\n\n        if (!hasAny) {\n          this.lines[i] = null;\n          anyDeleted = true;\n        }\n      }\n    }\n\n    if (anyDeleted) {\n      this.lines = parseCommon.compact(this.lines);\n      parseCommon.each(this.lines, function (line) {\n        if (line.staff) line.staff = parseCommon.compact(line.staff);\n      });\n    } // if we exceeded the number of bars allowed on a line, then force a new line\n\n\n    if (barsperstaff) {\n      while (wrapMusicLines(this.lines, barsperstaff)) {// This will keep wrapping until the end of the piece.\n      }\n    } // If we were passed staffnonote, then we want to get rid of all staffs that contain only rests.\n\n\n    if (staffnonote) {\n      anyDeleted = false;\n\n      for (i = 0; i < this.lines.length; i++) {\n        if (this.lines[i].staff !== undefined) {\n          for (s = 0; s < this.lines[i].staff.length; s++) {\n            var keepThis = false;\n\n            for (v = 0; v < this.lines[i].staff[s].voices.length; v++) {\n              if (this.containsNotesStrict(this.lines[i].staff[s].voices[v])) {\n                keepThis = true;\n              }\n            }\n\n            if (!keepThis) {\n              anyDeleted = true;\n              this.lines[i].staff[s] = null;\n            }\n          }\n        }\n      }\n\n      if (anyDeleted) {\n        parseCommon.each(this.lines, function (line) {\n          if (line.staff) line.staff = parseCommon.compact(line.staff);\n        });\n      }\n    }\n\n    fixTitles(this.lines); // Remove the temporary working variables\n\n    for (i = 0; i < this.lines.length; i++) {\n      if (this.lines[i].staff) {\n        for (s = 0; s < this.lines[i].staff.length; s++) delete this.lines[i].staff[s].workingClef;\n      }\n    } // If there are overlays, create new voices for them.\n\n\n    while (this.resolveOverlays()) {// keep resolving overlays as long as any are found.\n    }\n\n    function cleanUpSlursInLine(line) {\n      var x; //\t\t\tvar lyr = null;\t// TODO-PER: debugging.\n\n      var addEndSlur = function (obj, num, chordPos) {\n        if (currSlur[chordPos] === undefined) {\n          // There isn't an exact match for note position, but we'll take any other open slur.\n          for (x = 0; x < currSlur.length; x++) {\n            if (currSlur[x] !== undefined) {\n              chordPos = x;\n              break;\n            }\n          }\n\n          if (currSlur[chordPos] === undefined) {\n            var offNum = chordPos * 100 + 1;\n            parseCommon.each(obj.endSlur, function (x) {\n              if (offNum === x) --offNum;\n            });\n            currSlur[chordPos] = [offNum];\n          }\n        }\n\n        var slurNum;\n\n        for (var i = 0; i < num; i++) {\n          slurNum = currSlur[chordPos].pop();\n          obj.endSlur.push(slurNum); //\t\t\t\t\tlyr.syllable += '<' + slurNum;\t// TODO-PER: debugging\n        }\n\n        if (currSlur[chordPos].length === 0) delete currSlur[chordPos];\n        return slurNum;\n      };\n\n      var addStartSlur = function (obj, num, chordPos, usedNums) {\n        obj.startSlur = [];\n\n        if (currSlur[chordPos] === undefined) {\n          currSlur[chordPos] = [];\n        }\n\n        var nextNum = chordPos * 100 + 1;\n\n        for (var i = 0; i < num; i++) {\n          if (usedNums) {\n            parseCommon.each(usedNums, function (x) {\n              if (nextNum === x) ++nextNum;\n            });\n            parseCommon.each(usedNums, function (x) {\n              if (nextNum === x) ++nextNum;\n            });\n            parseCommon.each(usedNums, function (x) {\n              if (nextNum === x) ++nextNum;\n            });\n          }\n\n          parseCommon.each(currSlur[chordPos], function (x) {\n            if (nextNum === x) ++nextNum;\n          });\n          parseCommon.each(currSlur[chordPos], function (x) {\n            if (nextNum === x) ++nextNum;\n          });\n          currSlur[chordPos].push(nextNum);\n          obj.startSlur.push({\n            label: nextNum\n          }); //\t\t\t\t\tlyr.syllable += ' ' + nextNum + '>';\t// TODO-PER:debugging\n\n          nextNum++;\n        }\n      };\n\n      for (var i = 0; i < line.length; i++) {\n        var el = line[i]; //\t\t\t\tif (el.lyric === undefined)\t// TODO-PER: debugging\n        //\t\t\t\t\tel.lyric = [{ divider: '-' }];\t// TODO-PER: debugging\n        //\t\t\t\tlyr = el.lyric[0];\t// TODO-PER: debugging\n        //\t\t\t\tlyr.syllable = '';\t// TODO-PER: debugging\n\n        if (el.el_type === 'note') {\n          if (el.gracenotes) {\n            for (var g = 0; g < el.gracenotes.length; g++) {\n              if (el.gracenotes[g].endSlur) {\n                var gg = el.gracenotes[g].endSlur;\n                el.gracenotes[g].endSlur = [];\n\n                for (var ggg = 0; ggg < gg; ggg++) addEndSlur(el.gracenotes[g], 1, 20);\n              }\n\n              if (el.gracenotes[g].startSlur) {\n                x = el.gracenotes[g].startSlur;\n                addStartSlur(el.gracenotes[g], x, 20);\n              }\n            }\n          }\n\n          if (el.endSlur) {\n            x = el.endSlur;\n            el.endSlur = [];\n            addEndSlur(el, x, 0);\n          }\n\n          if (el.startSlur) {\n            x = el.startSlur;\n            addStartSlur(el, x, 0);\n          }\n\n          if (el.pitches) {\n            var usedNums = [];\n\n            for (var p = 0; p < el.pitches.length; p++) {\n              if (el.pitches[p].endSlur) {\n                var k = el.pitches[p].endSlur;\n                el.pitches[p].endSlur = [];\n\n                for (var j = 0; j < k; j++) {\n                  var slurNum = addEndSlur(el.pitches[p], 1, p + 1);\n                  usedNums.push(slurNum);\n                }\n              }\n            }\n\n            for (p = 0; p < el.pitches.length; p++) {\n              if (el.pitches[p].startSlur) {\n                x = el.pitches[p].startSlur;\n                addStartSlur(el.pitches[p], x, p + 1, usedNums);\n              }\n            } // Correct for the weird gracenote case where ({g}a) should match.\n            // The end slur was already assigned to the note, and needs to be moved to the first note of the graces.\n\n\n            if (el.gracenotes && el.pitches[0].endSlur && el.pitches[0].endSlur[0] === 100 && el.pitches[0].startSlur) {\n              if (el.gracenotes[0].endSlur) el.gracenotes[0].endSlur.push(el.pitches[0].startSlur[0].label);else el.gracenotes[0].endSlur = [el.pitches[0].startSlur[0].label];\n              if (el.pitches[0].endSlur.length === 1) delete el.pitches[0].endSlur;else if (el.pitches[0].endSlur[0] === 100) el.pitches[0].endSlur.shift();else if (el.pitches[0].endSlur[el.pitches[0].endSlur.length - 1] === 100) el.pitches[0].endSlur.pop();\n              if (currSlur[1].length === 1) delete currSlur[1];else currSlur[1].pop();\n            }\n          }\n        }\n      }\n    } // TODO-PER: This could be done faster as we go instead of as the last step.\n\n\n    function fixClefPlacement(el) {\n      parseKeyVoice.fixClef(el); //if (el.el_type === 'clef') {\n      //\t\t\t\tvar min = -2;\n      //\t\t\t\tvar max = 5;\n      //\t\t\t\tswitch(el.type) {\n      //\t\t\t\t\tcase 'treble+8':\n      //\t\t\t\t\tcase 'treble-8':\n      //\t\t\t\t\t\tbreak;\n      //\t\t\t\t\tcase 'bass':\n      //\t\t\t\t\tcase 'bass+8':\n      //\t\t\t\t\tcase 'bass-8':\n      //\t\t\t\t\t\tel.verticalPos = 20 + el.verticalPos; min += 6; max += 6;\n      //\t\t\t\t\t\tbreak;\n      //\t\t\t\t\tcase 'tenor':\n      //\t\t\t\t\tcase 'tenor+8':\n      //\t\t\t\t\tcase 'tenor-8':\n      //\t\t\t\t\t\tel.verticalPos = - el.verticalPos; min = -40; max = 40;\n      ////\t\t\t\t\t\tel.verticalPos+=2; min += 6; max += 6;\n      //\t\t\t\t\t\tbreak;\n      //\t\t\t\t\tcase 'alto':\n      //\t\t\t\t\tcase 'alto+8':\n      //\t\t\t\t\tcase 'alto-8':\n      //\t\t\t\t\t\tel.verticalPos = - el.verticalPos; min = -40; max = 40;\n      ////\t\t\t\t\t\tel.verticalPos-=2; min += 4; max += 4;\n      //\t\t\t\t\t\tbreak;\n      //\t\t\t\t}\n      //\t\t\t\tif (el.verticalPos < min) {\n      //\t\t\t\t\twhile (el.verticalPos < min)\n      //\t\t\t\t\t\tel.verticalPos += 7;\n      //\t\t\t\t} else if (el.verticalPos > max) {\n      //\t\t\t\t\twhile (el.verticalPos > max)\n      //\t\t\t\t\t\tel.verticalPos -= 7;\n      //\t\t\t\t}\n      //}\n    }\n\n    function wrapMusicLines(lines, barsperstaff) {\n      for (i = 0; i < lines.length; i++) {\n        if (lines[i].staff !== undefined) {\n          for (s = 0; s < lines[i].staff.length; s++) {\n            var permanentItems = [];\n\n            for (v = 0; v < lines[i].staff[s].voices.length; v++) {\n              var voice = lines[i].staff[s].voices[v];\n              var barNumThisLine = 0;\n\n              for (var n = 0; n < voice.length; n++) {\n                if (voice[n].el_type === 'bar') {\n                  barNumThisLine++;\n\n                  if (barNumThisLine >= barsperstaff) {\n                    // push everything else to the next line, if there is anything else,\n                    // and there is a next line. If there isn't a next line, create one.\n                    if (n < voice.length - 1) {\n                      var nextLine = getNextMusicLine(lines, i);\n\n                      if (!nextLine) {\n                        var cp = JSON.parse(JSON.stringify(lines[i]));\n                        lines.push(parseCommon.clone(cp));\n                        nextLine = lines[lines.length - 1];\n\n                        for (var ss = 0; ss < nextLine.staff.length; ss++) {\n                          for (var vv = 0; vv < nextLine.staff[ss].voices.length; vv++) nextLine.staff[ss].voices[vv] = [];\n                        }\n                      }\n\n                      var startElement = n + 1;\n                      var section = lines[i].staff[s].voices[v].slice(startElement);\n                      lines[i].staff[s].voices[v] = lines[i].staff[s].voices[v].slice(0, startElement);\n                      nextLine.staff[s].voices[v] = permanentItems.concat(section.concat(nextLine.staff[s].voices[v]));\n                      return true;\n                    }\n                  }\n                } else if (!voice[n].duration) {\n                  permanentItems.push(voice[n]);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n\n    function getNextMusicLine(lines, currentLine) {\n      currentLine++;\n\n      while (lines.length > currentLine) {\n        if (lines[currentLine].staff) return lines[currentLine];\n        currentLine++;\n      }\n\n      return null;\n    }\n\n    for (this.lineNum = 0; this.lineNum < this.lines.length; this.lineNum++) {\n      var staff = this.lines[this.lineNum].staff;\n\n      if (staff) {\n        for (this.staffNum = 0; this.staffNum < staff.length; this.staffNum++) {\n          if (staff[this.staffNum].clef) fixClefPlacement(staff[this.staffNum].clef);\n\n          for (this.voiceNum = 0; this.voiceNum < staff[this.staffNum].voices.length; this.voiceNum++) {\n            var voice = staff[this.staffNum].voices[this.voiceNum];\n            cleanUpSlursInLine(voice);\n\n            for (var j = 0; j < voice.length; j++) {\n              if (voice[j].el_type === 'clef') fixClefPlacement(voice[j]);\n            }\n\n            if (voice.length > 0 && voice[voice.length - 1].barNumber) {\n              // Don't hang a bar number on the last bar line: it should go on the next line.\n              var nextLine = getNextMusicLine(this.lines, this.lineNum);\n              if (nextLine) nextLine.staff[0].barNumber = voice[voice.length - 1].barNumber;\n              delete voice[voice.length - 1].barNumber;\n            }\n          }\n        }\n      }\n    }\n\n    if (!this.formatting.pagewidth) this.formatting.pagewidth = defWidth;\n    if (!this.formatting.pageheight) this.formatting.pageheight = defLength; // Remove temporary variables that the outside doesn't need to know about\n\n    delete this.staffNum;\n    delete this.voiceNum;\n    delete this.lineNum;\n    delete this.potentialStartBeam;\n    delete this.potentialEndBeam;\n    delete this.vskipPending;\n    return currSlur;\n  };\n\n  this.reset();\n\n  this.getLastNote = function () {\n    if (this.lines[this.lineNum] && this.lines[this.lineNum].staff && this.lines[this.lineNum].staff[this.staffNum] && this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum]) {\n      for (var i = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum].length - 1; i >= 0; i--) {\n        var el = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum][i];\n\n        if (el.el_type === 'note') {\n          return el;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  this.addTieToLastNote = function () {\n    // TODO-PER: if this is a chord, which note?\n    var el = this.getLastNote();\n\n    if (el && el.pitches && el.pitches.length > 0) {\n      el.pitches[0].startTie = {};\n      return true;\n    }\n\n    return false;\n  };\n\n  this.getDuration = function (el) {\n    if (el.duration) return el.duration; //if (el.pitches && el.pitches.length > 0) return el.pitches[0].duration;\n\n    return 0;\n  };\n\n  this.closeLine = function () {\n    if (this.potentialStartBeam && this.potentialEndBeam) {\n      this.potentialStartBeam.startBeam = true;\n      this.potentialEndBeam.endBeam = true;\n    }\n\n    delete this.potentialStartBeam;\n    delete this.potentialEndBeam;\n  };\n\n  this.appendElement = function (type, startChar, endChar, hashParams) {\n    var This = this;\n\n    var pushNote = function (hp) {\n      var currStaff = This.lines[This.lineNum].staff[This.staffNum];\n\n      if (!currStaff) {\n        // TODO-PER: This prevents a crash, but it drops the element. Need to figure out how to start a new line, or delay adding this.\n        return;\n      }\n\n      if (hp.pitches !== undefined) {\n        var mid = currStaff.workingClef.verticalPos;\n        parseCommon.each(hp.pitches, function (p) {\n          p.verticalPos = p.pitch - mid;\n        });\n      }\n\n      if (hp.gracenotes !== undefined) {\n        var mid2 = currStaff.workingClef.verticalPos;\n        parseCommon.each(hp.gracenotes, function (p) {\n          p.verticalPos = p.pitch - mid2;\n        });\n      }\n\n      currStaff.voices[This.voiceNum].push(hp);\n    };\n\n    hashParams.el_type = type;\n    if (startChar !== null) hashParams.startChar = startChar;\n    if (endChar !== null) hashParams.endChar = endChar;\n\n    var endBeamHere = function () {\n      This.potentialStartBeam.startBeam = true;\n      hashParams.endBeam = true;\n      delete This.potentialStartBeam;\n      delete This.potentialEndBeam;\n    };\n\n    var endBeamLast = function () {\n      if (This.potentialStartBeam !== undefined && This.potentialEndBeam !== undefined) {\n        // Do we have a set of notes to beam?\n        This.potentialStartBeam.startBeam = true;\n        This.potentialEndBeam.endBeam = true;\n      }\n\n      delete This.potentialStartBeam;\n      delete This.potentialEndBeam;\n    };\n\n    if (type === 'note') {\n      // && (hashParams.rest !== undefined || hashParams.end_beam === undefined)) {\n      // Now, add the startBeam and endBeam where it is needed.\n      // end_beam is already set on the places where there is a forced end_beam. We'll remove that here after using that info.\n      // this.potentialStartBeam either points to null or the start beam.\n      // this.potentialEndBeam either points to null or the start beam.\n      // If we have a beam break (note is longer than a quarter, or an end_beam is on this element), then set the beam if we have one.\n      // reset the variables for the next notes.\n      var dur = This.getDuration(hashParams);\n\n      if (dur >= 0.25) {\n        // The beam ends on the note before this.\n        endBeamLast();\n      } else if (hashParams.force_end_beam_last && This.potentialStartBeam !== undefined) {\n        endBeamLast();\n      } else if (hashParams.end_beam && This.potentialStartBeam !== undefined) {\n        // the beam is forced to end on this note, probably because of a space in the ABC\n        if (hashParams.rest === undefined) endBeamHere();else endBeamLast();\n      } else if (hashParams.rest === undefined) {\n        // this a short note and we aren't about to end the beam\n        if (This.potentialStartBeam === undefined) {\n          // We aren't collecting notes for a beam, so start here.\n          if (!hashParams.end_beam) {\n            This.potentialStartBeam = hashParams;\n            delete This.potentialEndBeam;\n          }\n        } else {\n          This.potentialEndBeam = hashParams; // Continue the beaming, look for the end next note.\n        }\n      } //  end_beam goes on rests and notes which precede rests _except_ when a rest (or set of adjacent rests) has normal notes on both sides (no spaces)\n      //\t\t\tif (hashParams.rest !== undefined)\n      //\t\t\t{\n      //\t\t\t\thashParams.end_beam = true;\n      //\t\t\t\tvar el2 = this.getLastNote();\n      //\t\t\t\tif (el2) el2.end_beam = true;\n      //\t\t\t\t// TODO-PER: implement exception mentioned in the comment.\n      //\t\t\t}\n\n    } else {\n      // It's not a note, so there definitely isn't beaming after it.\n      endBeamLast();\n    }\n\n    delete hashParams.end_beam; // We don't want this temporary variable hanging around.\n\n    delete hashParams.force_end_beam_last; // We don't want this temporary variable hanging around.\n\n    pushNote(hashParams);\n  };\n\n  this.appendStartingElement = function (type, startChar, endChar, hashParams2) {\n    // If we're in the middle of beaming, then end the beam.\n    this.closeLine(); // We only ever want implied naturals the first time.\n\n    var impliedNaturals;\n\n    if (type === 'key') {\n      impliedNaturals = hashParams2.impliedNaturals;\n      delete hashParams2.impliedNaturals;\n      delete hashParams2.explicitAccidentals;\n    } // Clone the object because it will be sticking around for the next line and we don't want the extra fields in it.\n\n\n    var hashParams = parseCommon.clone(hashParams2);\n\n    if (this.lines[this.lineNum].staff) {\n      // be sure that we are on a music type line before doing the following.\n      // If this is the first item in this staff, then we might have to initialize the staff, first.\n      if (this.lines[this.lineNum].staff.length <= this.staffNum) {\n        this.lines[this.lineNum].staff[this.staffNum] = {};\n        this.lines[this.lineNum].staff[this.staffNum].clef = parseCommon.clone(this.lines[this.lineNum].staff[0].clef);\n        this.lines[this.lineNum].staff[this.staffNum].key = parseCommon.clone(this.lines[this.lineNum].staff[0].key);\n        if (this.lines[this.lineNum].staff[0].meter) this.lines[this.lineNum].staff[this.staffNum].meter = parseCommon.clone(this.lines[this.lineNum].staff[0].meter);\n        this.lines[this.lineNum].staff[this.staffNum].workingClef = parseCommon.clone(this.lines[this.lineNum].staff[0].workingClef);\n        this.lines[this.lineNum].staff[this.staffNum].voices = [[]];\n      } // If this is a clef type, then we replace the working clef on the line. This is kept separate from\n      // the clef in case there is an inline clef field. We need to know what the current position for\n      // the note is.\n\n\n      if (type === 'clef') {\n        this.lines[this.lineNum].staff[this.staffNum].workingClef = hashParams;\n      } // These elements should not be added twice, so if the element exists on this line without a note or bar before it, just replace the staff version.\n\n\n      var voice = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];\n\n      for (var i = 0; i < voice.length; i++) {\n        if (voice[i].el_type === 'note' || voice[i].el_type === 'bar') {\n          hashParams.el_type = type;\n          hashParams.startChar = startChar;\n          hashParams.endChar = endChar;\n          if (impliedNaturals) hashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);\n          voice.push(hashParams);\n          return;\n        }\n\n        if (voice[i].el_type === type) {\n          hashParams.el_type = type;\n          hashParams.startChar = startChar;\n          hashParams.endChar = endChar;\n          if (impliedNaturals) hashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);\n          voice[i] = hashParams;\n          return;\n        }\n      } // We didn't see either that type or a note, so replace the element to the staff.\n\n\n      this.lines[this.lineNum].staff[this.staffNum][type] = hashParams2;\n    }\n  };\n\n  this.getNumLines = function () {\n    return this.lines.length;\n  };\n\n  this.pushLine = function (hash) {\n    if (this.vskipPending) {\n      hash.vskip = this.vskipPending;\n      delete this.vskipPending;\n    }\n\n    this.lines.push(hash);\n  };\n\n  this.addSubtitle = function (str) {\n    this.pushLine({\n      subtitle: str\n    });\n  };\n\n  this.addSpacing = function (num) {\n    this.vskipPending = num;\n  };\n\n  this.addNewPage = function (num) {\n    this.pushLine({\n      newpage: num\n    });\n  };\n\n  this.addSeparator = function (spaceAbove, spaceBelow, lineLength) {\n    this.pushLine({\n      separator: {\n        spaceAbove: spaceAbove,\n        spaceBelow: spaceBelow,\n        lineLength: lineLength\n      }\n    });\n  };\n\n  this.addText = function (str) {\n    this.pushLine({\n      text: str\n    });\n  };\n\n  this.addCentered = function (str) {\n    this.pushLine({\n      text: [{\n        text: str,\n        center: true\n      }]\n    });\n  };\n\n  this.containsNotes = function (voice) {\n    for (var i = 0; i < voice.length; i++) {\n      if (voice[i].el_type === 'note' || voice[i].el_type === 'bar') return true;\n    }\n\n    return false;\n  };\n\n  this.containsNotesStrict = function (voice) {\n    for (var i = 0; i < voice.length; i++) {\n      if (voice[i].el_type === 'note' && voice[i].rest === undefined) return true;\n    }\n\n    return false;\n  }; //\tanyVoiceContainsNotes: function(line) {\n  //\t\tfor (var i = 0; i < line.staff.voices.length; i++) {\n  //\t\t\tif (this.containsNotes(line.staff.voices[i]))\n  //\t\t\t\treturn true;\n  //\t\t}\n  //\t\treturn false;\n  //\t},\n\n\n  this.changeVoiceScale = function (scale) {\n    var This = this;\n    This.appendElement('scale', null, null, {\n      size: scale\n    });\n  };\n\n  this.startNewLine = function (params) {\n    // If the pointed to line doesn't exist, just create that. If the line does exist, but doesn't have any music on it, just use it.\n    // If it does exist and has music, then increment the line number. If the new element doesn't exist, create it.\n    var This = this;\n    this.closeLine(); // Close the previous line.\n\n    var createVoice = function (params) {\n      var thisStaff = This.lines[This.lineNum].staff[This.staffNum];\n      thisStaff.voices[This.voiceNum] = [];\n      if (!thisStaff.title) thisStaff.title = [];\n      thisStaff.title[This.voiceNum] = {\n        name: params.name,\n        subname: params.subname\n      };\n      if (params.style) This.appendElement('style', null, null, {\n        head: params.style\n      });\n      if (params.stem) This.appendElement('stem', null, null, {\n        direction: params.stem\n      });else if (This.voiceNum > 0) {\n        if (thisStaff.voices[0] !== undefined) {\n          var found = false;\n\n          for (var i = 0; i < thisStaff.voices[0].length; i++) {\n            if (thisStaff.voices[0].el_type === 'stem') found = true;\n          }\n\n          if (!found) {\n            var stem = {\n              el_type: 'stem',\n              direction: 'up'\n            };\n            thisStaff.voices[0].splice(0, 0, stem);\n          }\n        }\n\n        This.appendElement('stem', null, null, {\n          direction: 'down'\n        });\n      }\n      if (params.scale) This.appendElement('scale', null, null, {\n        size: params.scale\n      });\n    };\n\n    var createStaff = function (params) {\n      if (params.key && params.key.impliedNaturals) {\n        params.key.accidentals = params.key.accidentals.concat(params.key.impliedNaturals);\n        delete params.key.impliedNaturals;\n      }\n\n      This.lines[This.lineNum].staff[This.staffNum] = {\n        voices: [],\n        clef: params.clef,\n        key: params.key,\n        workingClef: params.clef\n      };\n\n      if (params.stafflines !== undefined) {\n        This.lines[This.lineNum].staff[This.staffNum].clef.stafflines = params.stafflines;\n        This.lines[This.lineNum].staff[This.staffNum].workingClef.stafflines = params.stafflines;\n      }\n\n      if (params.staffscale) {\n        This.lines[This.lineNum].staff[This.staffNum].staffscale = params.staffscale;\n      }\n\n      if (params.tripletfont) This.lines[This.lineNum].staff[This.staffNum].tripletfont = params.tripletfont;\n      if (params.vocalfont) This.lines[This.lineNum].staff[This.staffNum].vocalfont = params.vocalfont;\n      if (params.bracket) This.lines[This.lineNum].staff[This.staffNum].bracket = params.bracket;\n      if (params.brace) This.lines[This.lineNum].staff[This.staffNum].brace = params.brace;\n      if (params.connectBarLines) This.lines[This.lineNum].staff[This.staffNum].connectBarLines = params.connectBarLines;\n      if (params.barNumber) This.lines[This.lineNum].staff[This.staffNum].barNumber = params.barNumber;\n      createVoice(params); // Some stuff just happens for the first voice\n\n      if (params.part) This.appendElement('part', params.part.startChar, params.part.endChar, {\n        title: params.part.title\n      });\n      if (params.meter !== undefined) This.lines[This.lineNum].staff[This.staffNum].meter = params.meter;\n    };\n\n    var createLine = function (params) {\n      This.lines[This.lineNum] = {\n        staff: []\n      };\n      createStaff(params);\n    };\n\n    if (this.lines[this.lineNum] === undefined) createLine(params);else if (this.lines[this.lineNum].staff === undefined) {\n      this.lineNum++;\n      this.startNewLine(params);\n    } else if (this.lines[this.lineNum].staff[this.staffNum] === undefined) createStaff(params);else if (this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum] === undefined) createVoice(params);else if (!this.containsNotes(this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum])) return;else {\n      this.lineNum++;\n      this.startNewLine(params);\n    }\n  };\n\n  this.setBarNumberImmediate = function (barNumber) {\n    // If this is called right at the beginning of a line, then correct the measure number that is already written.\n    // If this is called at the beginning of a measure, then correct the measure number that was just created.\n    // If this is called in the middle of a measure, then subtract one from it, because it will be incremented before applied.\n    var currentVoice = this.getCurrentVoice();\n\n    if (currentVoice && currentVoice.length > 0) {\n      var lastElement = currentVoice[currentVoice.length - 1];\n\n      if (lastElement.el_type === 'bar') {\n        if (lastElement.barNumber !== undefined) // the measure number might not be written for this bar, don't override that.\n          lastElement.barNumber = barNumber;\n      } else return barNumber - 1;\n    }\n\n    return barNumber;\n  };\n\n  this.hasBeginMusic = function () {\n    // return true if there exists at least one line that contains \"staff\"\n    for (var i = 0; i < this.lines.length; i++) {\n      if (this.lines[i].staff) return true;\n    }\n\n    return false;\n  };\n\n  this.isFirstLine = function (index) {\n    for (var i = index - 1; i >= 0; i--) {\n      if (this.lines[i].staff !== undefined) return false;\n    }\n\n    return true;\n  };\n\n  this.getMeter = function () {\n    for (var i = 0; i < this.lines.length; i++) {\n      var line = this.lines[i];\n\n      if (line.staff) {\n        for (var j = 0; j < line.staff.length; j++) {\n          var meter = line.staff[j].meter;\n\n          if (meter) {\n            return meter;\n          }\n        }\n      }\n    }\n\n    return {\n      type: \"common_time\"\n    };\n  };\n\n  this.getMeterFraction = function () {\n    var meter = this.getMeter();\n    var num = 4;\n    var den = 4;\n\n    if (meter) {\n      if (meter.type === 'specified') {\n        num = parseInt(meter.value[0].num, 10);\n        den = parseInt(meter.value[0].den, 10);\n      } else if (meter.type === 'cut_time') {\n        num = 2;\n        den = 2;\n      } else if (meter.type === 'common_time') {\n        num = 4;\n        den = 4;\n      }\n    }\n\n    this.meter = {\n      num: num,\n      den: den\n    };\n    return this.meter; // TODO-PER: is this saved value used anywhere? A get function shouldn't change state.\n  };\n\n  this.getKeySignature = function () {\n    for (var i = 0; i < this.lines.length; i++) {\n      var line = this.lines[i];\n\n      if (line.staff) {\n        for (var j = 0; j < line.staff.length; j++) {\n          if (line.staff[j].key) return line.staff[j].key;\n        }\n      }\n    }\n\n    return {};\n  };\n\n  this.getCurrentVoice = function () {\n    if (this.lines[this.lineNum] !== undefined && this.lines[this.lineNum].staff[this.staffNum] !== undefined && this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum] !== undefined) return this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];else return null;\n  };\n\n  this.setCurrentVoice = function (staffNum, voiceNum) {\n    this.staffNum = staffNum;\n    this.voiceNum = voiceNum;\n\n    for (var i = 0; i < this.lines.length; i++) {\n      if (this.lines[i].staff) {\n        if (this.lines[i].staff[staffNum] === undefined || this.lines[i].staff[staffNum].voices[voiceNum] === undefined || !this.containsNotes(this.lines[i].staff[staffNum].voices[voiceNum])) {\n          this.lineNum = i;\n          return;\n        }\n      }\n    }\n\n    this.lineNum = i;\n  };\n\n  this.addMetaText = function (key, value) {\n    if (this.metaText[key] === undefined) this.metaText[key] = value;else this.metaText[key] += \"\\n\" + value;\n  };\n\n  this.addMetaTextArray = function (key, value) {\n    if (this.metaText[key] === undefined) this.metaText[key] = [value];else this.metaText[key].push(value);\n  };\n\n  this.addMetaTextObj = function (key, value) {\n    this.metaText[key] = value;\n  };\n\n  function addVerticalInfo(timingEvents) {\n    // Add vertical info to the bar events: put the next event's top, and the event after the next measure's top.\n    var lastBarTop;\n    var lastBarBottom;\n    var lastEventTop;\n    var lastEventBottom;\n\n    for (var e = timingEvents.length - 1; e >= 0; e--) {\n      var ev = timingEvents[e];\n\n      if (ev.type === 'bar') {\n        ev.top = lastEventTop;\n        ev.nextTop = lastBarTop;\n        lastBarTop = lastEventTop;\n        ev.bottom = lastEventBottom;\n        ev.nextBottom = lastBarBottom;\n        lastBarBottom = lastEventBottom;\n      } else if (ev.type === 'event') {\n        lastEventTop = ev.top;\n        lastEventBottom = ev.top + ev.height;\n      }\n    }\n  }\n\n  function makeSortedArray(hash) {\n    var arr = [];\n\n    for (var k in hash) {\n      if (hash.hasOwnProperty(k)) arr.push(hash[k]);\n    }\n\n    arr = arr.sort(function (a, b) {\n      var diff = a.milliseconds - b.milliseconds; // if the events have the same time, make sure a bar comes before a note\n\n      if (diff !== 0) {\n        return diff;\n      } else {\n        return a.type === \"bar\" ? -1 : 1;\n      }\n    });\n    return arr;\n  }\n\n  this.addElementToEvents = function (eventHash, element, voiceTimeMilliseconds, top, height, line, measureNumber, timeDivider, isTiedState, nextIsBar) {\n    if (element.hint) return {\n      isTiedState: undefined,\n      duration: 0\n    };\n    var realDuration = element.durationClass ? element.durationClass : element.duration;\n    if (element.abcelem.rest && element.abcelem.rest.type === \"spacer\") realDuration = 0;\n\n    if (realDuration > 0) {\n      var es = []; // If there is an invisible rest, then there are not elements, so don't push a null one.\n\n      for (var i = 0; i < element.elemset.length; i++) {\n        if (element.elemset[i] !== null) es.push(element.elemset[i]);\n      }\n\n      var isTiedToNext = element.startTie;\n\n      if (isTiedState !== undefined) {\n        eventHash[\"event\" + isTiedState].elements.push(es); // Add the tied note to the first note that it is tied to\n\n        if (nextIsBar) {\n          if (!eventHash[\"event\" + voiceTimeMilliseconds]) {\n            eventHash[\"event\" + voiceTimeMilliseconds] = {\n              type: \"event\",\n              milliseconds: voiceTimeMilliseconds,\n              line: line,\n              measureNumber: measureNumber,\n              top: top,\n              height: height,\n              left: null,\n              width: 0,\n              elements: [],\n              startChar: null,\n              endChar: null,\n              startCharArray: [],\n              endCharArray: []\n            };\n          }\n\n          eventHash[\"event\" + voiceTimeMilliseconds].measureStart = true;\n          nextIsBar = false;\n        }\n\n        if (!isTiedToNext) isTiedState = undefined;\n      } else {\n        // the last note wasn't tied.\n        if (!eventHash[\"event\" + voiceTimeMilliseconds]) {\n          eventHash[\"event\" + voiceTimeMilliseconds] = {\n            type: \"event\",\n            milliseconds: voiceTimeMilliseconds,\n            line: line,\n            measureNumber: measureNumber,\n            top: top,\n            height: height,\n            left: element.x,\n            width: element.w,\n            elements: [es],\n            startChar: element.abcelem.startChar,\n            endChar: element.abcelem.endChar,\n            startCharArray: [element.abcelem.startChar],\n            endCharArray: [element.abcelem.endChar],\n            midiPitches: element.abcelem.midiPitches ? parseCommon.cloneArray(element.abcelem.midiPitches) : []\n          };\n          if (element.abcelem.midiGraceNotePitches) eventHash[\"event\" + voiceTimeMilliseconds].midiGraceNotePitches = parseCommon.cloneArray(element.abcelem.midiGraceNotePitches);\n        } else {\n          // If there is more than one voice then two notes can fall at the same time. Usually they would be lined up in the same place, but if it is a whole rest, then it is placed funny. In any case, the left most element wins.\n          if (eventHash[\"event\" + voiceTimeMilliseconds].left) eventHash[\"event\" + voiceTimeMilliseconds].left = Math.min(eventHash[\"event\" + voiceTimeMilliseconds].left, element.x);else eventHash[\"event\" + voiceTimeMilliseconds].left = element.x;\n          eventHash[\"event\" + voiceTimeMilliseconds].elements.push(es);\n          eventHash[\"event\" + voiceTimeMilliseconds].startCharArray.push(element.abcelem.startChar);\n          eventHash[\"event\" + voiceTimeMilliseconds].endCharArray.push(element.abcelem.endChar);\n          if (eventHash[\"event\" + voiceTimeMilliseconds].startChar === null) eventHash[\"event\" + voiceTimeMilliseconds].startChar = element.abcelem.startChar;\n          if (eventHash[\"event\" + voiceTimeMilliseconds].endChar === null) eventHash[\"event\" + voiceTimeMilliseconds].endChar = element.abcelem.endChar;\n\n          if (element.abcelem.midiPitches && element.abcelem.midiPitches.length) {\n            if (!eventHash[\"event\" + voiceTimeMilliseconds].midiPitches) eventHash[\"event\" + voiceTimeMilliseconds].midiPitches = [];\n\n            for (var i = 0; i < element.abcelem.midiPitches.length; i++) eventHash[\"event\" + voiceTimeMilliseconds].midiPitches.push(element.abcelem.midiPitches[i]);\n          }\n\n          if (element.abcelem.midiGraceNotePitches && element.abcelem.midiGraceNotePitches.length) {\n            if (!eventHash[\"event\" + voiceTimeMilliseconds].midiGraceNotePitches) eventHash[\"event\" + voiceTimeMilliseconds].midiGraceNotePitches = [];\n\n            for (var j = 0; j < element.abcelem.midiGraceNotePitches.length; j++) eventHash[\"event\" + voiceTimeMilliseconds].midiGraceNotePitches.push(element.abcelem.midiGraceNotePitches[j]);\n          }\n        }\n\n        if (nextIsBar) {\n          eventHash[\"event\" + voiceTimeMilliseconds].measureStart = true;\n          nextIsBar = false;\n        }\n\n        if (isTiedToNext) isTiedState = voiceTimeMilliseconds;\n      }\n    }\n\n    return {\n      isTiedState: isTiedState,\n      duration: realDuration / timeDivider,\n      nextIsBar: nextIsBar || element.type === 'bar'\n    };\n  };\n\n  this.makeVoicesArray = function () {\n    // First make a new array that is arranged by voice so that the repeats that span different lines are handled correctly.\n    var voicesArr = [];\n\n    for (var line = 0; line < this.engraver.staffgroups.length; line++) {\n      var group = this.engraver.staffgroups[line];\n      var firstStaff = group.staffs[0];\n      var middleC = firstStaff.absoluteY;\n      var top = middleC - firstStaff.top * spacing.STEP;\n      var lastStaff = group.staffs[group.staffs.length - 1];\n      middleC = lastStaff.absoluteY;\n      var bottom = middleC - lastStaff.bottom * spacing.STEP;\n      var height = bottom - top;\n      var voices = group.voices;\n\n      for (var v = 0; v < voices.length; v++) {\n        var measureNumber = 0;\n        var noteFound = false;\n        if (!voicesArr[v]) voicesArr[v] = [];\n        var elements = voices[v].children;\n\n        for (var elem = 0; elem < elements.length; elem++) {\n          voicesArr[v].push({\n            top: top,\n            height: height,\n            line: line,\n            measureNumber: measureNumber,\n            elem: elements[elem]\n          });\n          if (elements[elem].type === 'bar' && noteFound) // Count the measures by counting the bar lines, but skip a bar line that appears at the left of the music, before any notes.\n            measureNumber++;\n          if (elements[elem].type === 'note' || elements[elem].type === 'rest') noteFound = true;\n        }\n      }\n    }\n\n    return voicesArr;\n  };\n\n  this.setupEvents = function (startingDelay, timeDivider, bpm) {\n    var timingEvents = [];\n    var eventHash = {}; // The time is the number of seconds from the beginning of the piece.\n    // The units we are scanning are in notation units (i.e. 0.25 is a quarter note)\n\n    var time = startingDelay;\n    var isTiedState;\n    var nextIsBar = true;\n    var voices = this.makeVoicesArray();\n\n    for (var v = 0; v < voices.length; v++) {\n      var voiceTime = time;\n      var voiceTimeMilliseconds = Math.round(voiceTime * 1000);\n      var startingRepeatElem = 0;\n      var endingRepeatElem = -1;\n      var elements = voices[v];\n\n      for (var elem = 0; elem < elements.length; elem++) {\n        var element = elements[elem].elem;\n\n        if (element.abcelem.el_type === \"tempo\") {\n          var bpm = this.getBpm(element.abcelem);\n          var beatLength = this.getBeatLength();\n          var beatsPerSecond = bpm / 60;\n          timeDivider = beatLength * beatsPerSecond;\n        }\n\n        var ret = this.addElementToEvents(eventHash, element, voiceTimeMilliseconds, elements[elem].top, elements[elem].height, elements[elem].line, elements[elem].measureNumber, timeDivider, isTiedState, nextIsBar);\n        isTiedState = ret.isTiedState;\n        nextIsBar = ret.nextIsBar;\n        voiceTime += ret.duration;\n        voiceTimeMilliseconds = Math.round(voiceTime * 1000);\n\n        if (element.type === 'bar') {\n          var barType = element.abcelem.type;\n          var endRepeat = barType === \"bar_right_repeat\" || barType === \"bar_dbl_repeat\";\n          var startEnding = element.abcelem.startEnding === '1';\n          var startRepeat = barType === \"bar_left_repeat\" || barType === \"bar_dbl_repeat\" || barType === \"bar_right_repeat\";\n\n          if (endRepeat) {\n            if (endingRepeatElem === -1) endingRepeatElem = elem;\n\n            for (var el2 = startingRepeatElem; el2 < endingRepeatElem; el2++) {\n              var element2 = elements[el2].elem;\n              ret = this.addElementToEvents(eventHash, element2, voiceTimeMilliseconds, elements[el2].top, elements[el2].height, elements[el2].line, elements[el2].measureNumber, timeDivider, isTiedState, nextIsBar);\n              isTiedState = ret.isTiedState;\n              nextIsBar = ret.nextIsBar;\n              voiceTime += ret.duration;\n              voiceTimeMilliseconds = Math.round(voiceTime * 1000);\n            }\n\n            nextIsBar = true;\n            endingRepeatElem = -1;\n          }\n\n          if (startEnding) endingRepeatElem = elem;\n          if (startRepeat) startingRepeatElem = elem;\n        }\n      }\n    } // now we have all the events, but if there are multiple voices then there may be events out of order or duplicated, so normalize it.\n\n\n    timingEvents = makeSortedArray(eventHash);\n    addVerticalInfo(timingEvents);\n    timingEvents.push({\n      type: \"end\",\n      milliseconds: voiceTimeMilliseconds\n    });\n    this.addUsefulCallbackInfo(timingEvents, bpm);\n    return timingEvents;\n  };\n\n  this.addUsefulCallbackInfo = function (timingEvents, bpm) {\n    var millisecondsPerMeasure = this.millisecondsPerMeasure(bpm);\n\n    for (var i = 0; i < timingEvents.length; i++) {\n      var ev = timingEvents[i];\n      ev.millisecondsPerMeasure = millisecondsPerMeasure;\n    }\n  };\n\n  function getVertical(group) {\n    var voices = group.voices;\n    var firstStaff = group.staffs[0];\n    var middleC = firstStaff.absoluteY;\n    var top = middleC - firstStaff.top * spacing.STEP;\n    var lastStaff = group.staffs[group.staffs.length - 1];\n    middleC = lastStaff.absoluteY;\n    var bottom = middleC - lastStaff.bottom * spacing.STEP;\n    var height = bottom - top;\n    return {\n      top: top,\n      height: height\n    };\n  }\n\n  this.getBpm = function (tempo) {\n    var bpm;\n\n    if (tempo) {\n      bpm = tempo.bpm;\n      var beatLength = this.getBeatLength();\n      var statedBeatLength = tempo.duration && tempo.duration.length > 0 ? tempo.duration[0] : beatLength;\n      bpm = bpm * statedBeatLength / beatLength;\n    }\n\n    if (!bpm) {\n      bpm = 180; // Compensate for compound meter, where the beat isn't a beat.\n\n      var meter = this.getMeterFraction();\n\n      if (meter && meter.den === 8) {\n        bpm = 120;\n      }\n    }\n\n    return bpm;\n  };\n\n  this.setTiming = function (bpm, measuresOfDelay) {\n    if (!bpm) {\n      var tempo = this.metaText ? this.metaText.tempo : null;\n      bpm = this.getBpm(tempo);\n    }\n\n    var beatLength = this.getBeatLength();\n    var beatsPerSecond = bpm / 60;\n    var measureLength = this.getBarLength();\n    var startingDelay = measureLength / beatLength * measuresOfDelay / beatsPerSecond;\n    if (startingDelay) startingDelay -= this.getPickupLength() / beatLength / beatsPerSecond;\n    var timeDivider = beatLength * beatsPerSecond;\n    this.noteTimings = this.setupEvents(startingDelay, timeDivider, bpm);\n  };\n};\n\nmodule.exports = Tune;","map":{"version":3,"sources":["/home/elad/Desktop/Repos/drums-trainer/frontend/node_modules/react-sheet-music/node_modules/abcjs/src/data/abc_tune.js"],"names":["parseCommon","require","parseKeyVoice","spacing","Tune","getBeatLength","i","lines","length","staff","j","meter","type","value","num","parseInt","den","getPickupLength","pickupLength","barLength","getBarLength","v","voices","voice","hasNote","tripletMultiplier","el","isSpacer","rest","startTriplet","duration","endTriplet","el_type","getMeterFraction","millisecondsPerMeasure","bpmOverride","bpm","tempo","metaText","getBpm","beatsPerMeasure","getBeatsPerMeasure","minutesPerMeasure","reset","version","media","formatting","staffNum","voiceNum","lineNum","resolveOverlays","madeChanges","line","overlayVoice","k","push","hasOverlay","snip","durationThisBar","inOverlay","snipStart","kk","event","start","len","startChar","endChar","ov","kkk","splice","clone","startEnding","endEnding","fixTitles","firstMusicLine","title","hasATitle","name","subname","cleanUp","defWidth","defLength","barsperstaff","staffnonote","currSlur","closeLine","anyDeleted","s","undefined","hasAny","containsNotes","compact","each","wrapMusicLines","keepThis","containsNotesStrict","workingClef","cleanUpSlursInLine","x","addEndSlur","obj","chordPos","offNum","endSlur","slurNum","pop","addStartSlur","usedNums","startSlur","nextNum","label","gracenotes","g","gg","ggg","pitches","p","shift","fixClefPlacement","fixClef","permanentItems","barNumThisLine","n","nextLine","getNextMusicLine","cp","JSON","parse","stringify","ss","vv","startElement","section","slice","concat","currentLine","clef","barNumber","pagewidth","pageheight","potentialStartBeam","potentialEndBeam","vskipPending","getLastNote","addTieToLastNote","startTie","getDuration","startBeam","endBeam","appendElement","hashParams","This","pushNote","hp","currStaff","mid","verticalPos","pitch","mid2","endBeamHere","endBeamLast","dur","force_end_beam_last","end_beam","appendStartingElement","hashParams2","impliedNaturals","explicitAccidentals","key","accidentals","getNumLines","pushLine","hash","vskip","addSubtitle","str","subtitle","addSpacing","addNewPage","newpage","addSeparator","spaceAbove","spaceBelow","lineLength","separator","addText","text","addCentered","center","changeVoiceScale","scale","size","startNewLine","params","createVoice","thisStaff","style","head","stem","direction","found","createStaff","stafflines","staffscale","tripletfont","vocalfont","bracket","brace","connectBarLines","part","createLine","setBarNumberImmediate","currentVoice","getCurrentVoice","lastElement","hasBeginMusic","isFirstLine","index","getMeter","getKeySignature","setCurrentVoice","addMetaText","addMetaTextArray","addMetaTextObj","addVerticalInfo","timingEvents","lastBarTop","lastBarBottom","lastEventTop","lastEventBottom","e","ev","top","nextTop","bottom","nextBottom","height","makeSortedArray","arr","hasOwnProperty","sort","a","b","diff","milliseconds","addElementToEvents","eventHash","element","voiceTimeMilliseconds","measureNumber","timeDivider","isTiedState","nextIsBar","hint","realDuration","durationClass","abcelem","es","elemset","isTiedToNext","elements","left","width","startCharArray","endCharArray","measureStart","w","midiPitches","cloneArray","midiGraceNotePitches","Math","min","makeVoicesArray","voicesArr","engraver","staffgroups","group","firstStaff","staffs","middleC","absoluteY","STEP","lastStaff","noteFound","children","elem","setupEvents","startingDelay","time","voiceTime","round","startingRepeatElem","endingRepeatElem","beatLength","beatsPerSecond","ret","barType","endRepeat","startRepeat","el2","element2","addUsefulCallbackInfo","getVertical","statedBeatLength","setTiming","measuresOfDelay","measureLength","noteTimings","module","exports"],"mappings":"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","sourcesContent":["//    abc_tune.js: a computer usable internal structure representing one tune.\n//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)\n//\n//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n//    documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\n//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n//    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar parseCommon = require('../parse/abc_common');\nvar parseKeyVoice = require('../parse/abc_parse_key_voice');\nvar spacing = require('../write/abc_spacing');\n\n/**\n * This is the data for a single ABC tune. It is created and populated by the window.ABCJS.parse.Parse class.\n * Also known as the ABCJS Abstract Syntax Tree\n * @alternateClassName ABCJS.Tune\n */\nvar Tune = function() {\n\t// The structure consists of a hash with the following two items:\n\t// metaText: a hash of {key, value}, where key is one of: title, author, rhythm, source, transcription, unalignedWords, etc...\n\t// tempo: { noteLength: number (e.g. .125), bpm: number }\n\t// lines: an array of elements, or one of the following:\n\t//\n\t// STAFF: array of elements\n\t// SUBTITLE: string\n\t//\n\t// TODO: actually, the start and end char should modify each part of the note type\n\t// The elements all have a type field and a start and end char\n\t// field. The rest of the fields depend on the type and are listed below:\n\t// REST: duration=1,2,4,8; chord: string\n\t// NOTE: accidental=none,dbl_flat,flat,natural,sharp,dbl_sharp\n\t//\t\tpitch: \"C\" is 0. The numbers refer to the pitch letter.\n\t//\t\tduration: .5 (sixteenth), .75 (dotted sixteenth), 1 (eighth), 1.5 (dotted eighth)\n\t//\t\t\t2 (quarter), 3 (dotted quarter), 4 (half), 6 (dotted half) 8 (whole)\n\t//\t\tchord: { name:chord, position: one of 'default', 'above', 'below' }\n\t//\t\tend_beam = true or undefined if this is the last note in a beam.\n\t//\t\tlyric: array of { syllable: xxx, divider: one of \" -_\" }\n\t//\t\tstartTie = true|undefined\n\t//\t\tendTie = true|undefined\n\t//\t\tstartTriplet = num <- that is the number to print\n\t//\t\tendTriplet = true|undefined (the last note of the triplet)\n\t// TODO: actually, decoration should be an array.\n\t//\t\tdecoration: upbow, downbow, accent\n\t// BAR: type=bar_thin, bar_thin_thick, bar_thin_thin, bar_thick_thin, bar_right_repeat, bar_left_repeat, bar_double_repeat\n\t//\tnumber: 1 or 2: if it is the start of a first or second ending\n\t// CLEF: type=treble,bass\n\t// KEY-SIG:\n\t//\t\taccidentals[]: { acc:sharp|dblsharp|natural|flat|dblflat,  note:a|b|c|d|e|f|g }\n\t// METER: type: common_time,cut_time,specified\n\t//\t\tif specified, { num: 99, den: 99 }\n\n\tthis.getBeatLength = function() {\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tif (this.lines[i].staff) {\n\t\t\t\tfor (var j = 0; j < this.lines[i].staff.length; j++) {\n\t\t\t\t\tif (this.lines[i].staff[j].meter) {\n\t\t\t\t\t\tvar meter = this.lines[i].staff[j].meter;\n\t\t\t\t\t\tif (meter.type === \"specified\") {\n\t\t\t\t\t\t\tif (meter.value.length > 0) {\n\t\t\t\t\t\t\t\tvar num = parseInt(meter.value[0].num, 10);\n\t\t\t\t\t\t\t\tvar den = parseInt(meter.value[0].den, 10);\n\t\t\t\t\t\t\t\tif (num === 3 && den === 8) return 3/8;\n\t\t\t\t\t\t\t\tif (num === 6 && den === 8) return 3/8;\n\t\t\t\t\t\t\t\tif (num === 6 && den === 4) return 3/4;\n\t\t\t\t\t\t\t\tif (num === 9 && den === 8) return 3/8;\n\t\t\t\t\t\t\t\tif (num === 12 && den === 8) return 3/8;\n\t\t\t\t\t\t\t\treturn 1/den;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn 1/4; // No meter was specified, so use this default\n\t\t\t\t\t\t} else if (meter.type === 'cut_time') {\n\t\t\t\t\t\t\treturn 1/2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn 1/4; // TODO-PER: this works for common time, but not for the ancient meters.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 1/4; // No meter was specified, so use this default\n\t};\n\n\tthis.getPickupLength = function() {\n\t\tvar pickupLength = 0;\n\t\tvar barLength = this.getBarLength();\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tif (this.lines[i].staff) {\n\t\t\t\tfor (var j = 0; j < this.lines[i].staff.length; j++) {\n\t\t\t\t\tfor (var v = 0; v < this.lines[i].staff[j].voices.length; v++) {\n\t\t\t\t\t\tvar voice = this.lines[i].staff[j].voices[v];\n\t\t\t\t\t\tvar hasNote = false;\n\t\t\t\t\t\tvar tripletMultiplier = 1;\n\t\t\t\t\t\tfor (var el = 0; el < voice.length; el++) {\n\t\t\t\t\t\t\tvar isSpacer = voice[el].rest && voice[el].rest.type === \"spacer\";\n\t\t\t\t\t\t\tif (voice[el].startTriplet)\n\t\t\t\t\t\t\t\ttripletMultiplier = voice[el].tripletMultiplier;\n\t\t\t\t\t\t\tif (voice[el].duration && !isSpacer)\n\t\t\t\t\t\t\t\tpickupLength += voice[el].duration * tripletMultiplier;\n\t\t\t\t\t\t\tif (voice[el].endTriplet)\n\t\t\t\t\t\t\t\ttripletMultiplier = 1;\n\t\t\t\t\t\t\tif (pickupLength >= barLength)\n\t\t\t\t\t\t\t\tpickupLength -= barLength;\n\t\t\t\t\t\t\tif (voice[el].el_type === 'bar')\n\t\t\t\t\t\t\t\treturn pickupLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn pickupLength;\n\t};\n\n\tthis.getBarLength = function() {\n\t\tvar meter = this.getMeterFraction();\n\t\treturn meter.num / meter.den;\n\t};\n\n\tthis.millisecondsPerMeasure = function(bpmOverride) {\n\t\tvar bpm;\n\t\tif (bpmOverride) {\n\t\t\tbpm = bpmOverride;\n\t\t} else {\n\t\t\tvar tempo = this.metaText ? this.metaText.tempo : null;\n\t\t\tbpm = this.getBpm(tempo);\n\t\t}\n\t\tif (bpm <= 0)\n\t\t\tbpm = 1; // I don't think this can happen, but we don't want a possibility of dividing by zero.\n\n\t\tvar beatsPerMeasure = this.getBeatsPerMeasure();\n\n\t\tvar minutesPerMeasure = beatsPerMeasure / bpm;\n\t\treturn minutesPerMeasure * 60000;\n\t};\n\n\tthis.getBeatsPerMeasure = function() {\n\t\tvar beatsPerMeasure;\n\t\tvar meter = this.getMeterFraction();\n\t\tif (meter.den === 8) {\n\t\t\tbeatsPerMeasure = meter.num / 3;\n\t\t} else {\n\t\t\tbeatsPerMeasure = meter.num;\n\t\t}\n\t\tif (beatsPerMeasure <= 0) // This probably won't happen in any normal case - but it is possible that the meter could be set to something nonsensical.\n\t\t\tbeatsPerMeasure = 1;\n\t\treturn beatsPerMeasure;\n\t};\n\n\tthis.reset = function () {\n\t\tthis.version = \"1.0.1\";\n\t\tthis.media = \"screen\";\n\t\tthis.metaText = {};\n\t\tthis.formatting = {};\n\t\tthis.lines = [];\n\t\tthis.staffNum = 0;\n\t\tthis.voiceNum = 0;\n\t\tthis.lineNum = 0;\n\t};\n\n\tthis.resolveOverlays = function() {\n\t\tvar madeChanges = false;\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tvar line = this.lines[i];\n\t\t\tif (line.staff) {\n\t\t\t\tfor (var j = 0; j < line.staff.length; j++) {\n\t\t\t\t\tvar staff = line.staff[j];\n\t\t\t\t\tvar overlayVoice = [];\n\t\t\t\t\tfor (var k = 0; k < staff.voices.length; k++) {\n\t\t\t\t\t\tvar voice = staff.voices[k];\n\t\t\t\t\t\toverlayVoice.push({ hasOverlay: false, voice: [], snip: []});\n\t\t\t\t\t\tvar durationThisBar = 0;\n\t\t\t\t\t\tvar inOverlay = false;\n\t\t\t\t\t\tvar snipStart = -1;\n\t\t\t\t\t\tfor (var kk = 0; kk < voice.length; kk++) {\n\t\t\t\t\t\t\tvar event = voice[kk];\n\t\t\t\t\t\t\tif (event.el_type === \"overlay\" && !inOverlay) {\n\t\t\t\t\t\t\t\tmadeChanges = true;\n\t\t\t\t\t\t\t\tinOverlay = true;\n\t\t\t\t\t\t\t\tsnipStart = kk;\n\t\t\t\t\t\t\t\toverlayVoice[k].hasOverlay = true;\n\t\t\t\t\t\t\t} else if (event.el_type === \"bar\") {\n\t\t\t\t\t\t\t\tif (inOverlay) {\n\t\t\t\t\t\t\t\t\t// delete the overlay events from this array without messing up this loop.\n\t\t\t\t\t\t\t\t\tinOverlay = false;\n\t\t\t\t\t\t\t\t\toverlayVoice[k].snip.push({ start: snipStart, len: kk - snipStart});\n\t\t\t\t\t\t\t\t\toverlayVoice[k].voice.push(event); // Also end the overlay with the barline.\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// This keeps the voices lined up: if the overlay isn't in the first measure then we need a bunch of invisible rests.\n\t\t\t\t\t\t\t\t\tif (durationThisBar > 0)\n\t\t\t\t\t\t\t\t\t\toverlayVoice[k].voice.push({ el_type: \"note\", duration: durationThisBar, rest: {type: \"invisible\"}, startChar: event.startChar, endChar: event.endChar });\n\t\t\t\t\t\t\t\t\toverlayVoice[k].voice.push(event);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdurationThisBar = 0;\n\t\t\t\t\t\t\t} else if (event.el_type === \"note\") {\n\t\t\t\t\t\t\t\tif (inOverlay) {\n\t\t\t\t\t\t\t\t\toverlayVoice[k].voice.push(event);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdurationThisBar += event.duration;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (event.el_type === \"scale\" || event.el_type === \"stem\" || event.el_type === \"overlay\" || event.el_type === \"style\" || event.el_type === \"transpose\") {\n\t\t\t\t\t\t\t\t// These types of events are duplicated on the overlay layer.\n\t\t\t\t\t\t\t\toverlayVoice[k].voice.push(event);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (overlayVoice[k].hasOverlay && overlayVoice[k].snip.length === 0) {\n\t\t\t\t\t\t\t// there was no closing bar, so we didn't set the snip amount.\n\t\t\t\t\t\t\toverlayVoice[k].snip.push({ start: snipStart, len: voice.length - snipStart});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (k = 0; k < overlayVoice.length; k++) {\n\t\t\t\t\t\tvar ov = overlayVoice[k];\n\t\t\t\t\t\tif (ov.hasOverlay) {\n\t\t\t\t\t\t\tstaff.voices.push(ov.voice);\n\t\t\t\t\t\t\tfor (var kkk = ov.snip.length-1; kkk >= 0; kkk--) {\n\t\t\t\t\t\t\t\tvar snip = ov.snip[kkk];\n\t\t\t\t\t\t\t\tstaff.voices[k].splice(snip.start, snip.len);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// remove ending marks from the overlay voice so they are not repeated\n\t\t\t\t\t\t\tfor (kkk = 0; kkk < staff.voices[staff.voices.length-1].length; kkk++) {\n\t\t\t\t\t\t\t\tstaff.voices[staff.voices.length-1][kkk] = parseCommon.clone(staff.voices[staff.voices.length-1][kkk]);\n\t\t\t\t\t\t\t\tvar el = staff.voices[staff.voices.length-1][kkk];\n\t\t\t\t\t\t\t\tif (el.el_type === 'bar' && el.startEnding) {\n\t\t\t\t\t\t\t\t\tdelete el.startEnding;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (el.el_type === 'bar' && el.endEnding)\n\t\t\t\t\t\t\t\t\tdelete el.endEnding;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn madeChanges;\n\t};\n\n\tfunction fixTitles(lines) {\n\t\t// We might have name and subname defined. We now know what line everything is on, so we can determine which to use.\n\t\tvar firstMusicLine = true;\n\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\tvar line = lines[i];\n\t\t\tif (line.staff) {\n\t\t\t\tfor (var j = 0; j < line.staff.length; j++) {\n\t\t\t\t\tvar staff = line.staff[j];\n\t\t\t\t\tif (staff.title) {\n\t\t\t\t\t\tvar hasATitle = false;\n\t\t\t\t\t\tfor (var k = 0; k < staff.title.length; k++) {\n\t\t\t\t\t\t\tif (staff.title[k]) {\n\t\t\t\t\t\t\tstaff.title[k] = (firstMusicLine) ? staff.title[k].name : staff.title[k].subname;\n\t\t\t\t\t\t\tif (staff.title[k])\n\t\t\t\t\t\t\t\thasATitle = true;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstaff.title[k] = '';\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tstaff.title[k] = '';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!hasATitle)\n\t\t\t\t\t\t\tdelete staff.title;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfirstMusicLine = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.cleanUp = function(defWidth, defLength, barsperstaff, staffnonote, currSlur) {\n\t\tthis.closeLine();\t// Close the last line.\n\n\t\t// If the tempo was created with a string like \"Allegro\", then the duration of a beat needs to be set at the last moment, when it is most likely known.\n\t\tif (this.metaText.tempo && this.metaText.tempo.bpm && !this.metaText.tempo.duration)\n\t\t\tthis.metaText.tempo.duration = [ this.getBeatLength() ];\n\n\t\t// Remove any blank lines\n\t\tvar anyDeleted = false;\n\t\tvar i, s, v;\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tif (this.lines[i].staff !== undefined) {\n\t\t\t\tvar hasAny = false;\n\t\t\t\tfor (s = 0; s < this.lines[i].staff.length; s++) {\n\t\t\t\t\tif (this.lines[i].staff[s] === undefined) {\n\t\t\t\t\t\tanyDeleted = true;\n\t\t\t\t\t\tthis.lines[i].staff[s] = null;\n\t\t\t\t\t\t//this.lines[i].staff[s] = { voices: []};\t// TODO-PER: There was a part missing in the abc music. How should we recover?\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (v = 0; v < this.lines[i].staff[s].voices.length; v++) {\n\t\t\t\t\t\t\tif (this.lines[i].staff[s].voices[v] === undefined)\n\t\t\t\t\t\t\t\tthis.lines[i].staff[s].voices[v] = [];\t// TODO-PER: There was a part missing in the abc music. How should we recover?\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tif (this.containsNotes(this.lines[i].staff[s].voices[v])) hasAny = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!hasAny) {\n\t\t\t\t\tthis.lines[i] = null;\n\t\t\t\t\tanyDeleted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anyDeleted) {\n\t\t\tthis.lines = parseCommon.compact(this.lines);\n\t\t\tparseCommon.each(this.lines, function(line) {\n\t\t\t\tif (line.staff)\n\t\t\t\t\tline.staff = parseCommon.compact(line.staff);\n\t\t\t});\n\t\t}\n\n\t\t// if we exceeded the number of bars allowed on a line, then force a new line\n\t\tif (barsperstaff) {\n\t\t\twhile (wrapMusicLines(this.lines, barsperstaff)) {\n\t\t\t\t// This will keep wrapping until the end of the piece.\n\t\t\t}\n\t\t}\n\n\t\t// If we were passed staffnonote, then we want to get rid of all staffs that contain only rests.\n\t\tif (staffnonote) {\n\t\t\tanyDeleted = false;\n\t\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\t\tif (this.lines[i].staff !== undefined) {\n\t\t\t\t\tfor (s = 0; s < this.lines[i].staff.length; s++) {\n\t\t\t\t\t\tvar keepThis = false;\n\t\t\t\t\t\tfor (v = 0; v < this.lines[i].staff[s].voices.length; v++) {\n\t\t\t\t\t\t\tif (this.containsNotesStrict(this.lines[i].staff[s].voices[v])) {\n\t\t\t\t\t\t\t\tkeepThis = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!keepThis) {\n\t\t\t\t\t\t\tanyDeleted = true;\n\t\t\t\t\t\t\tthis.lines[i].staff[s] = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (anyDeleted) {\n\t\t\t\tparseCommon.each(this.lines, function(line) {\n\t\t\t\t\tif (line.staff)\n\t\t\t\t\t\tline.staff = parseCommon.compact(line.staff);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfixTitles(this.lines);\n\n\t\t// Remove the temporary working variables\n\t\tfor (i = 0; i < this.lines.length; i++) {\n\t\t\tif (this.lines[i].staff) {\n\t\t\t\tfor (s = 0; s < this.lines[i].staff.length; s++)\n\t\t\t\t\t\tdelete this.lines[i].staff[s].workingClef;\n\t\t\t}\n\t\t}\n\n\t\t// If there are overlays, create new voices for them.\n\t\twhile (this.resolveOverlays()) {\n\t\t\t// keep resolving overlays as long as any are found.\n\t\t}\n\n\t\tfunction cleanUpSlursInLine(line) {\n\t\t\tvar x;\n//\t\t\tvar lyr = null;\t// TODO-PER: debugging.\n\n\t\t\tvar addEndSlur = function(obj, num, chordPos) {\n\t\t\t\tif (currSlur[chordPos] === undefined) {\n\t\t\t\t\t// There isn't an exact match for note position, but we'll take any other open slur.\n\t\t\t\t\tfor (x = 0; x < currSlur.length; x++) {\n\t\t\t\t\t\tif (currSlur[x] !== undefined) {\n\t\t\t\t\t\t\tchordPos = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (currSlur[chordPos] === undefined) {\n\t\t\t\t\t\tvar offNum = chordPos*100+1;\n\t\t\t\t\t\tparseCommon.each(obj.endSlur, function(x) { if (offNum === x) --offNum; });\n\t\t\t\t\t\tcurrSlur[chordPos] = [offNum];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar slurNum;\n\t\t\t\tfor (var i = 0; i < num; i++) {\n\t\t\t\t\tslurNum = currSlur[chordPos].pop();\n\t\t\t\t\tobj.endSlur.push(slurNum);\n//\t\t\t\t\tlyr.syllable += '<' + slurNum;\t// TODO-PER: debugging\n\t\t\t\t}\n\t\t\t\tif (currSlur[chordPos].length === 0)\n\t\t\t\t\tdelete currSlur[chordPos];\n\t\t\t\treturn slurNum;\n\t\t\t};\n\n\t\t\tvar addStartSlur = function(obj, num, chordPos, usedNums) {\n\t\t\t\tobj.startSlur = [];\n\t\t\t\tif (currSlur[chordPos] === undefined) {\n\t\t\t\t\tcurrSlur[chordPos] = [];\n\t\t\t\t}\n\t\t\t\tvar nextNum = chordPos*100+1;\n\t\t\t\tfor (var i = 0; i < num; i++) {\n\t\t\t\t\tif (usedNums) {\n\t\t\t\t\t\tparseCommon.each(usedNums, function(x) { if (nextNum === x) ++nextNum; });\n\t\t\t\t\t\tparseCommon.each(usedNums, function(x) { if (nextNum === x) ++nextNum; });\n\t\t\t\t\t\tparseCommon.each(usedNums, function(x) { if (nextNum === x) ++nextNum; });\n\t\t\t\t\t}\n\t\t\t\t\tparseCommon.each(currSlur[chordPos], function(x) { if (nextNum === x) ++nextNum; });\n\t\t\t\t\tparseCommon.each(currSlur[chordPos], function(x) { if (nextNum === x) ++nextNum; });\n\n\t\t\t\t\tcurrSlur[chordPos].push(nextNum);\n\t\t\t\t\tobj.startSlur.push({ label: nextNum });\n//\t\t\t\t\tlyr.syllable += ' ' + nextNum + '>';\t// TODO-PER:debugging\n\t\t\t\t\tnextNum++;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < line.length; i++) {\n\t\t\t\tvar el = line[i];\n//\t\t\t\tif (el.lyric === undefined)\t// TODO-PER: debugging\n//\t\t\t\t\tel.lyric = [{ divider: '-' }];\t// TODO-PER: debugging\n//\t\t\t\tlyr = el.lyric[0];\t// TODO-PER: debugging\n//\t\t\t\tlyr.syllable = '';\t// TODO-PER: debugging\n\t\t\t\tif (el.el_type === 'note') {\n\t\t\t\t\tif (el.gracenotes) {\n\t\t\t\t\t\tfor (var g = 0; g < el.gracenotes.length; g++) {\n\t\t\t\t\t\t\tif (el.gracenotes[g].endSlur) {\n\t\t\t\t\t\t\t\tvar gg = el.gracenotes[g].endSlur;\n\t\t\t\t\t\t\t\tel.gracenotes[g].endSlur = [];\n\t\t\t\t\t\t\t\tfor (var ggg = 0; ggg < gg; ggg++)\n\t\t\t\t\t\t\t\t\taddEndSlur(el.gracenotes[g], 1, 20);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (el.gracenotes[g].startSlur) {\n\t\t\t\t\t\t\t\tx = el.gracenotes[g].startSlur;\n\t\t\t\t\t\t\t\taddStartSlur(el.gracenotes[g], x, 20);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (el.endSlur) {\n\t\t\t\t\t\tx = el.endSlur;\n\t\t\t\t\t\tel.endSlur = [];\n\t\t\t\t\t\taddEndSlur(el, x, 0);\n\t\t\t\t\t}\n\t\t\t\t\tif (el.startSlur) {\n\t\t\t\t\t\tx = el.startSlur;\n\t\t\t\t\t\taddStartSlur(el, x, 0);\n\t\t\t\t\t}\n\t\t\t\t\tif (el.pitches) {\n\t\t\t\t\t\tvar usedNums = [];\n\t\t\t\t\t\tfor (var p = 0; p < el.pitches.length; p++) {\n\t\t\t\t\t\t\tif (el.pitches[p].endSlur) {\n\t\t\t\t\t\t\t\tvar k = el.pitches[p].endSlur;\n\t\t\t\t\t\t\t\tel.pitches[p].endSlur = [];\n\t\t\t\t\t\t\t\tfor (var j = 0; j < k; j++) {\n\t\t\t\t\t\t\t\t\tvar slurNum = addEndSlur(el.pitches[p], 1, p+1);\n\t\t\t\t\t\t\t\t\tusedNums.push(slurNum);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (p = 0; p < el.pitches.length; p++) {\n\t\t\t\t\t\t\tif (el.pitches[p].startSlur) {\n\t\t\t\t\t\t\t\tx = el.pitches[p].startSlur;\n\t\t\t\t\t\t\t\taddStartSlur(el.pitches[p], x, p+1, usedNums);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Correct for the weird gracenote case where ({g}a) should match.\n\t\t\t\t\t\t// The end slur was already assigned to the note, and needs to be moved to the first note of the graces.\n\t\t\t\t\t\tif (el.gracenotes && el.pitches[0].endSlur && el.pitches[0].endSlur[0] === 100 && el.pitches[0].startSlur) {\n\t\t\t\t\t\t\tif (el.gracenotes[0].endSlur)\n\t\t\t\t\t\t\t\tel.gracenotes[0].endSlur.push(el.pitches[0].startSlur[0].label);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tel.gracenotes[0].endSlur = [el.pitches[0].startSlur[0].label];\n\t\t\t\t\t\t\tif (el.pitches[0].endSlur.length === 1)\n\t\t\t\t\t\t\t\tdelete el.pitches[0].endSlur;\n\t\t\t\t\t\t\telse if (el.pitches[0].endSlur[0] === 100)\n\t\t\t\t\t\t\t\tel.pitches[0].endSlur.shift();\n\t\t\t\t\t\t\telse if (el.pitches[0].endSlur[el.pitches[0].endSlur.length-1] === 100)\n\t\t\t\t\t\t\t\tel.pitches[0].endSlur.pop();\n\t\t\t\t\t\t\tif (currSlur[1].length === 1)\n\t\t\t\t\t\t\t\tdelete currSlur[1];\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcurrSlur[1].pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TODO-PER: This could be done faster as we go instead of as the last step.\n\t\tfunction fixClefPlacement(el) {\n\t\t\tparseKeyVoice.fixClef(el);\n\t\t\t//if (el.el_type === 'clef') {\n//\t\t\t\tvar min = -2;\n//\t\t\t\tvar max = 5;\n//\t\t\t\tswitch(el.type) {\n//\t\t\t\t\tcase 'treble+8':\n//\t\t\t\t\tcase 'treble-8':\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\tcase 'bass':\n//\t\t\t\t\tcase 'bass+8':\n//\t\t\t\t\tcase 'bass-8':\n//\t\t\t\t\t\tel.verticalPos = 20 + el.verticalPos; min += 6; max += 6;\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\tcase 'tenor':\n//\t\t\t\t\tcase 'tenor+8':\n//\t\t\t\t\tcase 'tenor-8':\n//\t\t\t\t\t\tel.verticalPos = - el.verticalPos; min = -40; max = 40;\n////\t\t\t\t\t\tel.verticalPos+=2; min += 6; max += 6;\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\tcase 'alto':\n//\t\t\t\t\tcase 'alto+8':\n//\t\t\t\t\tcase 'alto-8':\n//\t\t\t\t\t\tel.verticalPos = - el.verticalPos; min = -40; max = 40;\n////\t\t\t\t\t\tel.verticalPos-=2; min += 4; max += 4;\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t\tif (el.verticalPos < min) {\n//\t\t\t\t\twhile (el.verticalPos < min)\n//\t\t\t\t\t\tel.verticalPos += 7;\n//\t\t\t\t} else if (el.verticalPos > max) {\n//\t\t\t\t\twhile (el.verticalPos > max)\n//\t\t\t\t\t\tel.verticalPos -= 7;\n//\t\t\t\t}\n\t\t\t//}\n\t\t}\n\n\t\tfunction wrapMusicLines(lines, barsperstaff) {\n\t\t\tfor (i = 0; i < lines.length; i++) {\n\t\t\t\tif (lines[i].staff !== undefined) {\n\t\t\t\t\tfor (s = 0; s < lines[i].staff.length; s++) {\n\t\t\t\t\t\tvar permanentItems = [];\n\t\t\t\t\t\tfor (v = 0; v < lines[i].staff[s].voices.length; v++) {\n\t\t\t\t\t\t\tvar voice = lines[i].staff[s].voices[v];\n\t\t\t\t\t\t\tvar barNumThisLine = 0;\n\t\t\t\t\t\t\tfor (var n = 0; n < voice.length; n++) {\n\t\t\t\t\t\t\t\tif (voice[n].el_type === 'bar') {\n\t\t\t\t\t\t\t\t\tbarNumThisLine++;\n\t\t\t\t\t\t\t\t\tif (barNumThisLine >= barsperstaff) {\n\t\t\t\t\t\t\t\t\t\t// push everything else to the next line, if there is anything else,\n\t\t\t\t\t\t\t\t\t\t// and there is a next line. If there isn't a next line, create one.\n\t\t\t\t\t\t\t\t\t\tif (n < voice.length - 1) {\n\t\t\t\t\t\t\t\t\t\t\tvar nextLine = getNextMusicLine(lines, i);\n\t\t\t\t\t\t\t\t\t\t\tif (!nextLine) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar cp = JSON.parse(JSON.stringify(lines[i]));\n\t\t\t\t\t\t\t\t\t\t\t\tlines.push(parseCommon.clone(cp));\n\t\t\t\t\t\t\t\t\t\t\t\tnextLine = lines[lines.length - 1];\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var ss = 0; ss < nextLine.staff.length; ss++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var vv = 0; vv < nextLine.staff[ss].voices.length; vv++)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnextLine.staff[ss].voices[vv] = [];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tvar startElement = n + 1;\n\t\t\t\t\t\t\t\t\t\t\tvar section = lines[i].staff[s].voices[v].slice(startElement);\n\t\t\t\t\t\t\t\t\t\t\tlines[i].staff[s].voices[v] = lines[i].staff[s].voices[v].slice(0, startElement);\n\t\t\t\t\t\t\t\t\t\t\tnextLine.staff[s].voices[v] = permanentItems.concat(section.concat(nextLine.staff[s].voices[v]));\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (!voice[n].duration) {\n\t\t\t\t\t\t\t\t\tpermanentItems.push(voice[n]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction getNextMusicLine(lines, currentLine) {\n\t\t\tcurrentLine++;\n\t\t\twhile (lines.length > currentLine) {\n\t\t\t\tif (lines[currentLine].staff)\n\t\t\t\t\treturn lines[currentLine];\n\t\t\t\tcurrentLine++;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tfor (this.lineNum = 0; this.lineNum < this.lines.length; this.lineNum++) {\n\t\t\tvar staff = this.lines[this.lineNum].staff;\n\t\t\tif (staff) {\n\t\t\t\tfor (this.staffNum = 0; this.staffNum < staff.length; this.staffNum++) {\n\t\t\t\t\tif (staff[this.staffNum].clef)\n\t\t\t\t\t\tfixClefPlacement(staff[this.staffNum].clef);\n\t\t\t\t\tfor (this.voiceNum = 0; this.voiceNum < staff[this.staffNum].voices.length; this.voiceNum++) {\n\t\t\t\t\t\tvar voice = staff[this.staffNum].voices[this.voiceNum];\n\t\t\t\t\t\tcleanUpSlursInLine(voice);\n\t\t\t\t\t\tfor (var j = 0; j < voice.length; j++) {\n\t\t\t\t\t\t\tif (voice[j].el_type === 'clef')\n\t\t\t\t\t\t\t\tfixClefPlacement(voice[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (voice.length > 0 && voice[voice.length-1].barNumber) {\n\t\t\t\t\t\t\t// Don't hang a bar number on the last bar line: it should go on the next line.\n\t\t\t\t\t\t\tvar nextLine = getNextMusicLine(this.lines, this.lineNum);\n\t\t\t\t\t\t\tif (nextLine)\n\t\t\t\t\t\t\t\tnextLine.staff[0].barNumber = voice[voice.length-1].barNumber;\n\t\t\t\t\t\t\tdelete voice[voice.length-1].barNumber;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!this.formatting.pagewidth)\n\t\t\tthis.formatting.pagewidth = defWidth;\n\t\tif (!this.formatting.pageheight)\n\t\t\tthis.formatting.pageheight = defLength;\n\n\t\t// Remove temporary variables that the outside doesn't need to know about\n\t\tdelete this.staffNum;\n\t\tdelete this.voiceNum;\n\t\tdelete this.lineNum;\n\t\tdelete this.potentialStartBeam;\n\t\tdelete this.potentialEndBeam;\n\t\tdelete this.vskipPending;\n\n\t\treturn currSlur;\n\t};\n\n\tthis.reset();\n\n\tthis.getLastNote = function() {\n\t\tif (this.lines[this.lineNum] && this.lines[this.lineNum].staff && this.lines[this.lineNum].staff[this.staffNum] &&\n\t\t\tthis.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum]) {\n\t\t\tfor (var i = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum].length-1; i >= 0; i--) {\n\t\t\t\tvar el = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum][i];\n\t\t\t\tif (el.el_type === 'note') {\n\t\t\t\t\treturn el;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\tthis.addTieToLastNote = function() {\n\t\t// TODO-PER: if this is a chord, which note?\n\t\tvar el = this.getLastNote();\n\t\tif (el && el.pitches && el.pitches.length > 0) {\n\t\t\tel.pitches[0].startTie = {};\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tthis.getDuration = function(el) {\n\t\tif (el.duration) return el.duration;\n\t\t//if (el.pitches && el.pitches.length > 0) return el.pitches[0].duration;\n\t\treturn 0;\n\t};\n\n\tthis.closeLine = function() {\n\t\tif (this.potentialStartBeam && this.potentialEndBeam) {\n\t\t\tthis.potentialStartBeam.startBeam = true;\n\t\t\tthis.potentialEndBeam.endBeam = true;\n\t\t}\n\t\tdelete this.potentialStartBeam;\n\t\tdelete this.potentialEndBeam;\n\t};\n\n\tthis.appendElement = function(type, startChar, endChar, hashParams)\n\t{\n\t\tvar This = this;\n\t\tvar pushNote = function(hp) {\n\t\t\tvar currStaff = This.lines[This.lineNum].staff[This.staffNum];\n\t\t\tif (!currStaff) {\n\t\t\t\t// TODO-PER: This prevents a crash, but it drops the element. Need to figure out how to start a new line, or delay adding this.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hp.pitches !== undefined) {\n\t\t\t\tvar mid = currStaff.workingClef.verticalPos;\n\t\t\t\tparseCommon.each(hp.pitches, function(p) { p.verticalPos = p.pitch - mid; });\n\t\t\t}\n\t\t\tif (hp.gracenotes !== undefined) {\n\t\t\t\tvar mid2 = currStaff.workingClef.verticalPos;\n\t\t\t\tparseCommon.each(hp.gracenotes, function(p) { p.verticalPos = p.pitch - mid2; });\n\t\t\t}\n\t\t\tcurrStaff.voices[This.voiceNum].push(hp);\n\t\t};\n\t\thashParams.el_type = type;\n\t\tif (startChar !== null)\n\t\t\thashParams.startChar = startChar;\n\t\tif (endChar !== null)\n\t\t\thashParams.endChar = endChar;\n\t\tvar endBeamHere = function() {\n\t\t\tThis.potentialStartBeam.startBeam = true;\n\t\t\thashParams.endBeam = true;\n\t\t\tdelete This.potentialStartBeam;\n\t\t\tdelete This.potentialEndBeam;\n\t\t};\n\t\tvar endBeamLast = function() {\n\t\t\tif (This.potentialStartBeam !== undefined && This.potentialEndBeam !== undefined) {\t// Do we have a set of notes to beam?\n\t\t\t\tThis.potentialStartBeam.startBeam = true;\n\t\t\t\tThis.potentialEndBeam.endBeam = true;\n\t\t\t}\n\t\t\tdelete This.potentialStartBeam;\n\t\t\tdelete This.potentialEndBeam;\n\t\t};\n\t\tif (type === 'note') { // && (hashParams.rest !== undefined || hashParams.end_beam === undefined)) {\n\t\t\t// Now, add the startBeam and endBeam where it is needed.\n\t\t\t// end_beam is already set on the places where there is a forced end_beam. We'll remove that here after using that info.\n\t\t\t// this.potentialStartBeam either points to null or the start beam.\n\t\t\t// this.potentialEndBeam either points to null or the start beam.\n\t\t\t// If we have a beam break (note is longer than a quarter, or an end_beam is on this element), then set the beam if we have one.\n\t\t\t// reset the variables for the next notes.\n\t\t\tvar dur = This.getDuration(hashParams);\n\t\t\tif (dur >= 0.25) {\t// The beam ends on the note before this.\n\t\t\t\tendBeamLast();\n\t\t\t} else if (hashParams.force_end_beam_last && This.potentialStartBeam !== undefined) {\n\t\t\t\tendBeamLast();\n\t\t\t} else if (hashParams.end_beam && This.potentialStartBeam !== undefined) {\t// the beam is forced to end on this note, probably because of a space in the ABC\n\t\t\t\tif (hashParams.rest === undefined)\n\t\t\t\t\tendBeamHere();\n\t\t\t\telse\n\t\t\t\t\tendBeamLast();\n\t\t\t} else if (hashParams.rest === undefined) {\t// this a short note and we aren't about to end the beam\n\t\t\t\tif (This.potentialStartBeam === undefined) {\t// We aren't collecting notes for a beam, so start here.\n\t\t\t\t\tif (!hashParams.end_beam) {\n\t\t\t\t\t\tThis.potentialStartBeam = hashParams;\n\t\t\t\t\t\tdelete This.potentialEndBeam;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tThis.potentialEndBeam = hashParams;\t// Continue the beaming, look for the end next note.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//  end_beam goes on rests and notes which precede rests _except_ when a rest (or set of adjacent rests) has normal notes on both sides (no spaces)\n//\t\t\tif (hashParams.rest !== undefined)\n//\t\t\t{\n//\t\t\t\thashParams.end_beam = true;\n//\t\t\t\tvar el2 = this.getLastNote();\n//\t\t\t\tif (el2) el2.end_beam = true;\n//\t\t\t\t// TODO-PER: implement exception mentioned in the comment.\n//\t\t\t}\n\t\t} else {\t// It's not a note, so there definitely isn't beaming after it.\n\t\t\tendBeamLast();\n\t\t}\n\t\tdelete hashParams.end_beam;\t// We don't want this temporary variable hanging around.\n\t\tdelete hashParams.force_end_beam_last;\t// We don't want this temporary variable hanging around.\n\t\tpushNote(hashParams);\n\t};\n\n\tthis.appendStartingElement = function(type, startChar, endChar, hashParams2)\n\t{\n\t\t// If we're in the middle of beaming, then end the beam.\n\t\tthis.closeLine();\n\n\t\t// We only ever want implied naturals the first time.\n\t\tvar impliedNaturals;\n\t\tif (type === 'key') {\n\t\t\timpliedNaturals = hashParams2.impliedNaturals;\n\t\t\tdelete hashParams2.impliedNaturals;\n\t\t\tdelete hashParams2.explicitAccidentals;\n\t\t}\n\n\t\t// Clone the object because it will be sticking around for the next line and we don't want the extra fields in it.\n\t\tvar hashParams = parseCommon.clone(hashParams2);\n\n\t\tif (this.lines[this.lineNum].staff) { // be sure that we are on a music type line before doing the following.\n\t\t\t// If this is the first item in this staff, then we might have to initialize the staff, first.\n\t\t\tif (this.lines[this.lineNum].staff.length <= this.staffNum) {\n\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum] = {};\n\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum].clef = parseCommon.clone(this.lines[this.lineNum].staff[0].clef);\n\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum].key = parseCommon.clone(this.lines[this.lineNum].staff[0].key);\n\t\t\t\tif (this.lines[this.lineNum].staff[0].meter)\n\t\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum].meter = parseCommon.clone(this.lines[this.lineNum].staff[0].meter);\n\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum].workingClef = parseCommon.clone(this.lines[this.lineNum].staff[0].workingClef);\n\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum].voices = [[]];\n\t\t\t}\n\t\t\t// If this is a clef type, then we replace the working clef on the line. This is kept separate from\n\t\t\t// the clef in case there is an inline clef field. We need to know what the current position for\n\t\t\t// the note is.\n\t\t\tif (type === 'clef') {\n\t\t\t\tthis.lines[this.lineNum].staff[this.staffNum].workingClef = hashParams;\n\t\t\t}\n\n\t\t\t// These elements should not be added twice, so if the element exists on this line without a note or bar before it, just replace the staff version.\n\t\t\tvar voice = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];\n\t\t\tfor (var i = 0; i < voice.length; i++) {\n\t\t\t\tif (voice[i].el_type === 'note' || voice[i].el_type === 'bar') {\n\t\t\t\t\thashParams.el_type = type;\n\t\t\t\t\thashParams.startChar = startChar;\n\t\t\t\t\thashParams.endChar = endChar;\n\t\t\t\t\tif (impliedNaturals)\n\t\t\t\t\t\thashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);\n\t\t\t\t\tvoice.push(hashParams);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (voice[i].el_type === type) {\n\t\t\t\t\thashParams.el_type = type;\n\t\t\t\t\thashParams.startChar = startChar;\n\t\t\t\t\thashParams.endChar = endChar;\n\t\t\t\t\tif (impliedNaturals)\n\t\t\t\t\t\thashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);\n\t\t\t\t\tvoice[i] = hashParams;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// We didn't see either that type or a note, so replace the element to the staff.\n\t\t\tthis.lines[this.lineNum].staff[this.staffNum][type] = hashParams2;\n\t\t}\n\t};\n\n\tthis.getNumLines = function() {\n\t\treturn this.lines.length;\n\t};\n\n\tthis.pushLine = function(hash) {\n\t\tif (this.vskipPending) {\n\t\t\thash.vskip = this.vskipPending;\n\t\t\tdelete this.vskipPending;\n\t\t}\n\t\tthis.lines.push(hash);\n\t};\n\n\tthis.addSubtitle = function(str) {\n\t\tthis.pushLine({subtitle: str});\n\t};\n\n\tthis.addSpacing = function(num) {\n\t\tthis.vskipPending = num;\n\t};\n\n\tthis.addNewPage = function(num) {\n\t\tthis.pushLine({newpage: num});\n\t};\n\n\tthis.addSeparator = function(spaceAbove, spaceBelow, lineLength) {\n\t\tthis.pushLine({separator: {spaceAbove: spaceAbove, spaceBelow: spaceBelow, lineLength: lineLength}});\n\t};\n\n\tthis.addText = function(str) {\n\t\tthis.pushLine({text: str});\n\t};\n\n\tthis.addCentered = function(str) {\n\t\tthis.pushLine({text: [{text: str, center: true }]});\n\t};\n\n\tthis.containsNotes = function(voice) {\n\t\tfor (var i = 0; i < voice.length; i++) {\n\t\t\tif (voice[i].el_type === 'note' || voice[i].el_type === 'bar')\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tthis.containsNotesStrict = function(voice) {\n\t\tfor (var i = 0; i < voice.length; i++) {\n\t\t\tif (voice[i].el_type === 'note' && voice[i].rest === undefined)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n//\tanyVoiceContainsNotes: function(line) {\n//\t\tfor (var i = 0; i < line.staff.voices.length; i++) {\n//\t\t\tif (this.containsNotes(line.staff.voices[i]))\n//\t\t\t\treturn true;\n//\t\t}\n//\t\treturn false;\n//\t},\n\tthis.changeVoiceScale = function(scale) {\n\t\tvar This = this;\n\t\tThis.appendElement('scale', null, null, { size: scale} );\n\t};\n\n\tthis.startNewLine = function(params) {\n\t\t// If the pointed to line doesn't exist, just create that. If the line does exist, but doesn't have any music on it, just use it.\n\t\t// If it does exist and has music, then increment the line number. If the new element doesn't exist, create it.\n\t\tvar This = this;\n\t\tthis.closeLine();\t// Close the previous line.\n\t\tvar createVoice = function(params) {\n\t\t\tvar thisStaff = This.lines[This.lineNum].staff[This.staffNum];\n\t\t\tthisStaff.voices[This.voiceNum] = [];\n\t\t\tif (!thisStaff.title)\n\t\t\t\tthisStaff.title = [];\n\t\t\tthisStaff.title[This.voiceNum] = { name: params.name, subname: params.subname };\n\t\t\tif (params.style)\n\t\t\t\tThis.appendElement('style', null, null, {head: params.style});\n\t\t\tif (params.stem)\n\t\t\t\tThis.appendElement('stem', null, null, {direction: params.stem});\n\t\t\telse if (This.voiceNum > 0) {\n\t\t\t\tif (thisStaff.voices[0]!== undefined) {\n\t\t\t\t\tvar found = false;\n\t\t\t\t\tfor (var i = 0; i < thisStaff.voices[0].length; i++) {\n\t\t\t\t\t\tif (thisStaff.voices[0].el_type === 'stem')\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\tvar stem = { el_type: 'stem', direction: 'up' };\n\t\t\t\t\t\tthisStaff.voices[0].splice(0,0,stem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tThis.appendElement('stem', null, null, {direction: 'down'});\n\t\t\t}\n\t\t\tif (params.scale)\n\t\t\t\tThis.appendElement('scale', null, null, { size: params.scale} );\n\t\t};\n\t\tvar createStaff = function(params) {\n\t\t\tif (params.key && params.key.impliedNaturals) {\n\t\t\t\tparams.key.accidentals = params.key.accidentals.concat(params.key.impliedNaturals);\n\t\t\t\tdelete params.key.impliedNaturals;\n\t\t\t}\n\n\t\t\tThis.lines[This.lineNum].staff[This.staffNum] = {voices: [ ], clef: params.clef, key: params.key, workingClef: params.clef };\n\t\t\tif (params.stafflines !== undefined) {\n\t\t\t\tThis.lines[This.lineNum].staff[This.staffNum].clef.stafflines = params.stafflines;\n\t\t\t\tThis.lines[This.lineNum].staff[This.staffNum].workingClef.stafflines = params.stafflines;\n\t\t\t}\n\t\t\tif (params.staffscale) {\n\t\t\t\tThis.lines[This.lineNum].staff[This.staffNum].staffscale = params.staffscale;\n\t\t\t}\n\t\t\tif (params.tripletfont) This.lines[This.lineNum].staff[This.staffNum].tripletfont = params.tripletfont;\n\t\t\tif (params.vocalfont) This.lines[This.lineNum].staff[This.staffNum].vocalfont = params.vocalfont;\n\t\t\tif (params.bracket) This.lines[This.lineNum].staff[This.staffNum].bracket = params.bracket;\n\t\t\tif (params.brace) This.lines[This.lineNum].staff[This.staffNum].brace = params.brace;\n\t\t\tif (params.connectBarLines) This.lines[This.lineNum].staff[This.staffNum].connectBarLines = params.connectBarLines;\n\t\t\tif (params.barNumber) This.lines[This.lineNum].staff[This.staffNum].barNumber = params.barNumber;\n\t\t\tcreateVoice(params);\n\t\t\t// Some stuff just happens for the first voice\n\t\t\tif (params.part)\n\t\t\t\tThis.appendElement('part', params.part.startChar, params.part.endChar, {title: params.part.title});\n\t\t\tif (params.meter !== undefined) This.lines[This.lineNum].staff[This.staffNum].meter = params.meter;\n\t\t};\n\t\tvar createLine = function(params) {\n\t\t\tThis.lines[This.lineNum] = {staff: []};\n\t\t\tcreateStaff(params);\n\t\t};\n\t\tif (this.lines[this.lineNum] === undefined) createLine(params);\n\t\telse if (this.lines[this.lineNum].staff === undefined) {\n\t\t\tthis.lineNum++;\n\t\t\tthis.startNewLine(params);\n\t\t} else if (this.lines[this.lineNum].staff[this.staffNum] === undefined) createStaff(params);\n\t\telse if (this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum] === undefined) createVoice(params);\n\t\telse if (!this.containsNotes(this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum])) return;\n\t\telse {\n\t\t\tthis.lineNum++;\n\t\t\tthis.startNewLine(params);\n\t\t}\n\t};\n\n\tthis.setBarNumberImmediate = function(barNumber) {\n\t\t// If this is called right at the beginning of a line, then correct the measure number that is already written.\n\t\t// If this is called at the beginning of a measure, then correct the measure number that was just created.\n\t\t// If this is called in the middle of a measure, then subtract one from it, because it will be incremented before applied.\n\t\tvar currentVoice = this.getCurrentVoice();\n\t\tif (currentVoice && currentVoice.length > 0) {\n\t\t\tvar lastElement = currentVoice[currentVoice.length-1];\n\t\t\tif (lastElement.el_type === 'bar') {\n\t\t\t\tif (lastElement.barNumber !== undefined) // the measure number might not be written for this bar, don't override that.\n\t\t\t\t\tlastElement.barNumber = barNumber;\n\t\t\t} else\n\t\t\t\treturn barNumber-1;\n\t\t}\n\t\treturn barNumber;\n\t};\n\n\tthis.hasBeginMusic = function() {\n\t\t// return true if there exists at least one line that contains \"staff\"\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tif (this.lines[i].staff)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tthis.isFirstLine = function(index) {\n\t\tfor (var i = index-1; i >= 0; i--) {\n\t\t\tif (this.lines[i].staff !== undefined) return false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tthis.getMeter = function() {\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tvar line = this.lines[i];\n\t\t\tif (line.staff) {\n\t\t\t\tfor (var j = 0; j < line.staff.length; j++) {\n\t\t\t\t\tvar meter = line.staff[j].meter;\n\t\t\t\t\tif (meter) {\n\t\t\t\t\t\treturn meter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { type: \"common_time\" };\n\t};\n\n\tthis.getMeterFraction = function() {\n\t\tvar meter = this.getMeter();\n\t\tvar num = 4;\n\t\tvar den = 4;\n\t\tif (meter) {\n\t\t\tif (meter.type === 'specified') {\n\t\t\t\tnum = parseInt(meter.value[0].num, 10);\n\t\t\t\tden = parseInt(meter.value[0].den,10);\n\t\t\t} else if (meter.type === 'cut_time') {\n\t\t\t\tnum = 2;\n\t\t\t\tden = 2;\n\t\t\t} else if (meter.type === 'common_time') {\n\t\t\t\tnum = 4;\n\t\t\t\tden = 4;\n\t\t\t}\n\t\t}\n\t\tthis.meter = { num: num, den: den };\n\t\treturn this.meter; // TODO-PER: is this saved value used anywhere? A get function shouldn't change state.\n\t};\n\n\tthis.getKeySignature = function() {\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tvar line = this.lines[i];\n\t\t\tif (line.staff) {\n\t\t\t\tfor (var j = 0; j < line.staff.length; j++) {\n\t\t\t\t\tif (line.staff[j].key)\n\t\t\t\t\t\treturn line.staff[j].key;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {  };\n\t};\n\n\tthis.getCurrentVoice = function() {\n\t\tif (this.lines[this.lineNum] !== undefined && this.lines[this.lineNum].staff[this.staffNum] !== undefined && this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum] !== undefined)\n\t\t\treturn this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];\n\t\telse return null;\n\t};\n\n\tthis.setCurrentVoice = function(staffNum, voiceNum) {\n\t\tthis.staffNum = staffNum;\n\t\tthis.voiceNum = voiceNum;\n\t\tfor (var i = 0; i < this.lines.length; i++) {\n\t\t\tif (this.lines[i].staff) {\n\t\t\t\tif (this.lines[i].staff[staffNum] === undefined || this.lines[i].staff[staffNum].voices[voiceNum] === undefined ||\n\t\t\t\t\t!this.containsNotes(this.lines[i].staff[staffNum].voices[voiceNum] )) {\n\t\t\t\t\tthis.lineNum =  i;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.lineNum =  i;\n\t};\n\n\tthis.addMetaText = function(key, value) {\n\t\tif (this.metaText[key] === undefined)\n\t\t\tthis.metaText[key] = value;\n\t\telse\n\t\t\tthis.metaText[key] += \"\\n\" + value;\n\t};\n\n\tthis.addMetaTextArray = function(key, value) {\n\t\tif (this.metaText[key] === undefined)\n\t\t\tthis.metaText[key] = [value];\n\t\telse\n\t\t\tthis.metaText[key].push(value);\n\t};\n\tthis.addMetaTextObj = function(key, value) {\n\t\tthis.metaText[key] = value;\n\t};\n\n\tfunction addVerticalInfo(timingEvents) {\n\t\t// Add vertical info to the bar events: put the next event's top, and the event after the next measure's top.\n\t\tvar lastBarTop;\n\t\tvar lastBarBottom;\n\t\tvar lastEventTop;\n\t\tvar lastEventBottom;\n\t\tfor (var e = timingEvents.length - 1; e >= 0; e--) {\n\t\t\tvar ev = timingEvents[e];\n\t\t\tif (ev.type === 'bar') {\n\t\t\t\tev.top = lastEventTop;\n\t\t\t\tev.nextTop = lastBarTop;\n\t\t\t\tlastBarTop = lastEventTop;\n\n\t\t\t\tev.bottom = lastEventBottom;\n\t\t\t\tev.nextBottom = lastBarBottom;\n\t\t\t\tlastBarBottom = lastEventBottom;\n\t\t\t} else if (ev.type === 'event') {\n\t\t\t\tlastEventTop = ev.top;\n\t\t\t\tlastEventBottom = ev.top + ev.height;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction makeSortedArray(hash) {\n\t\tvar arr = [];\n\t\tfor (var k in hash) {\n\t\t\tif (hash.hasOwnProperty(k))\n\t\t\t\tarr.push(hash[k]);\n\t\t}\n\t\tarr = arr.sort(function (a, b) {\n\t\t\tvar diff = a.milliseconds - b.milliseconds;\n\t\t\t// if the events have the same time, make sure a bar comes before a note\n\t\t\tif (diff !== 0) {\n\t\t\t\treturn diff;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn a.type === \"bar\" ? -1 : 1;\n\t\t\t}\n\t\t});\n\t\treturn arr;\n\t}\n\n\tthis.addElementToEvents = function(eventHash, element, voiceTimeMilliseconds, top, height, line, measureNumber, timeDivider, isTiedState, nextIsBar) {\n\t\tif (element.hint)\n\t\t\treturn { isTiedState: undefined, duration: 0 };\n\t\tvar realDuration = element.durationClass ? element.durationClass : element.duration;\n\t\tif (element.abcelem.rest && element.abcelem.rest.type === \"spacer\")\n\t\t\trealDuration = 0;\n\t\tif (realDuration > 0) {\n\t\t\tvar es = [];\n\t\t\t// If there is an invisible rest, then there are not elements, so don't push a null one.\n\t\t\tfor (var i = 0; i < element.elemset.length; i++) {\n\t\t\t\tif (element.elemset[i] !== null)\n\t\t\t\t\tes.push(element.elemset[i]);\n\t\t\t}\n\t\t\tvar isTiedToNext = element.startTie;\n\t\t\tif (isTiedState !== undefined) {\n\t\t\t\teventHash[\"event\" + isTiedState].elements.push(es); // Add the tied note to the first note that it is tied to\n\t\t\t\tif (nextIsBar) {\n\t\t\t\t\tif (!eventHash[\"event\" + voiceTimeMilliseconds]) {\n\t\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds] = {\n\t\t\t\t\t\t\ttype: \"event\",\n\t\t\t\t\t\t\tmilliseconds: voiceTimeMilliseconds,\n\t\t\t\t\t\t\tline: line,\n\t\t\t\t\t\t\tmeasureNumber: measureNumber,\n\t\t\t\t\t\t\ttop: top,\n\t\t\t\t\t\t\theight: height,\n\t\t\t\t\t\t\tleft: null,\n\t\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\t\telements: [],\n\t\t\t\t\t\t\tstartChar: null,\n\t\t\t\t\t\t\tendChar: null,\n\t\t\t\t\t\t\tstartCharArray: [],\n\t\t\t\t\t\t\tendCharArray: []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].measureStart = true;\n\t\t\t\t\tnextIsBar = false;\n\t\t\t\t}\n\t\t\t\tif (!isTiedToNext)\n\t\t\t\t\tisTiedState = undefined;\n\t\t\t} else {\n\t\t\t\t// the last note wasn't tied.\n\t\t\t\tif (!eventHash[\"event\" + voiceTimeMilliseconds]) {\n\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds] = {\n\t\t\t\t\t\ttype: \"event\",\n\t\t\t\t\t\tmilliseconds: voiceTimeMilliseconds,\n\t\t\t\t\t\tline: line,\n\t\t\t\t\t\tmeasureNumber: measureNumber,\n\t\t\t\t\t\ttop: top,\n\t\t\t\t\t\theight: height,\n\t\t\t\t\t\tleft: element.x,\n\t\t\t\t\t\twidth: element.w,\n\t\t\t\t\t\telements: [es],\n\t\t\t\t\t\tstartChar: element.abcelem.startChar,\n\t\t\t\t\t\tendChar: element.abcelem.endChar,\n\t\t\t\t\t\tstartCharArray: [element.abcelem.startChar],\n\t\t\t\t\t\tendCharArray: [element.abcelem.endChar],\n\t\t\t\t\t\tmidiPitches: element.abcelem.midiPitches ? parseCommon.cloneArray(element.abcelem.midiPitches) : []\n\t\t\t\t\t};\n\t\t\t\t\tif (element.abcelem.midiGraceNotePitches)\n\t\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].midiGraceNotePitches = parseCommon.cloneArray(element.abcelem.midiGraceNotePitches);\n\t\t\t\t} else {\n\t\t\t\t\t// If there is more than one voice then two notes can fall at the same time. Usually they would be lined up in the same place, but if it is a whole rest, then it is placed funny. In any case, the left most element wins.\n\t\t\t\t\tif (eventHash[\"event\" + voiceTimeMilliseconds].left)\n\t\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].left = Math.min(eventHash[\"event\" + voiceTimeMilliseconds].left, element.x);\n\t\t\t\t\telse\n\t\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].left = element.x;\n\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].elements.push(es);\n\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].startCharArray.push(element.abcelem.startChar);\n\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].endCharArray.push(element.abcelem.endChar);\n\t\t\t\t\tif (eventHash[\"event\" + voiceTimeMilliseconds].startChar === null)\n\t\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].startChar =element.abcelem.startChar;\n\t\t\t\t\tif (eventHash[\"event\" + voiceTimeMilliseconds].endChar === null)\n\t\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].endChar =element.abcelem.endChar;\n\t\t\t\t\tif (element.abcelem.midiPitches && element.abcelem.midiPitches.length) {\n\t\t\t\t\t\tif (!eventHash[\"event\" + voiceTimeMilliseconds].midiPitches)\n\t\t\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].midiPitches = [];\n\t\t\t\t\t\tfor (var i = 0; i < element.abcelem.midiPitches.length; i++)\n\t\t\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].midiPitches.push(element.abcelem.midiPitches[i]);\n\t\t\t\t\t}\n\t\t\t\t\tif (element.abcelem.midiGraceNotePitches && element.abcelem.midiGraceNotePitches.length) {\n\t\t\t\t\t\tif (!eventHash[\"event\" + voiceTimeMilliseconds].midiGraceNotePitches)\n\t\t\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].midiGraceNotePitches = [];\n\t\t\t\t\t\tfor (var j = 0; j < element.abcelem.midiGraceNotePitches.length; j++)\n\t\t\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].midiGraceNotePitches.push(element.abcelem.midiGraceNotePitches[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nextIsBar) {\n\t\t\t\t\teventHash[\"event\" + voiceTimeMilliseconds].measureStart = true;\n\t\t\t\t\tnextIsBar = false;\n\t\t\t\t}\n\t\t\t\tif (isTiedToNext)\n\t\t\t\t\tisTiedState = voiceTimeMilliseconds;\n\t\t\t}\n\t\t}\n\t\treturn { isTiedState: isTiedState, duration: realDuration / timeDivider, nextIsBar: nextIsBar || element.type === 'bar' };\n\t};\n\n\tthis.makeVoicesArray = function() {\n\t\t// First make a new array that is arranged by voice so that the repeats that span different lines are handled correctly.\n\t\tvar voicesArr = [];\n\t\tfor (var line = 0; line < this.engraver.staffgroups.length; line++) {\n\t\t\tvar group = this.engraver.staffgroups[line];\n\t\t\tvar firstStaff = group.staffs[0];\n\t\t\tvar middleC = firstStaff.absoluteY;\n\t\t\tvar top = middleC - firstStaff.top * spacing.STEP;\n\t\t\tvar lastStaff = group.staffs[group.staffs.length - 1];\n\t\t\tmiddleC = lastStaff.absoluteY;\n\t\t\tvar bottom = middleC - lastStaff.bottom * spacing.STEP;\n\t\t\tvar height = bottom - top;\n\n\t\t\tvar voices = group.voices;\n\t\t\tfor (var v = 0; v < voices.length; v++) {\n\t\t\t\tvar measureNumber = 0;\n\t\t\t\tvar noteFound = false;\n\t\t\t\tif (!voicesArr[v])\n\t\t\t\t\tvoicesArr[v] = [];\n\t\t\t\tvar elements = voices[v].children;\n\t\t\t\tfor (var elem = 0; elem < elements.length; elem++) {\n\t\t\t\t\tvoicesArr[v].push({top: top, height: height, line: line, measureNumber: measureNumber, elem: elements[elem]});\n\t\t\t\t\tif (elements[elem].type === 'bar' && noteFound) // Count the measures by counting the bar lines, but skip a bar line that appears at the left of the music, before any notes.\n\t\t\t\t\t\tmeasureNumber++;\n\t\t\t\t\tif (elements[elem].type === 'note' || elements[elem].type === 'rest')\n\t\t\t\t\t\tnoteFound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn voicesArr;\n\t};\n\n\tthis.setupEvents = function(startingDelay, timeDivider, bpm) {\n\t\tvar timingEvents = [];\n\n\t\tvar eventHash = {};\n\t\t// The time is the number of seconds from the beginning of the piece.\n\t\t// The units we are scanning are in notation units (i.e. 0.25 is a quarter note)\n\t\tvar time = startingDelay;\n\t\tvar isTiedState;\n\t\tvar nextIsBar = true;\n\t\tvar voices = this.makeVoicesArray();\n\t\tfor (var v = 0; v < voices.length; v++) {\n\t\t\tvar voiceTime = time;\n\t\t\tvar voiceTimeMilliseconds = Math.round(voiceTime * 1000);\n\t\t\tvar startingRepeatElem = 0;\n\t\t\tvar endingRepeatElem = -1;\n\t\t\tvar elements = voices[v];\n\t\t\tfor (var elem = 0; elem < elements.length; elem++) {\n\t\t\t\tvar element = elements[elem].elem;\n\t\t\t\tif (element.abcelem.el_type === \"tempo\") {\n\t\t\t\t\tvar bpm = this.getBpm(element.abcelem);\n\t\t\t\t\tvar beatLength = this.getBeatLength();\n\t\t\t\t\tvar beatsPerSecond = bpm / 60;\n\t\t\t\t\ttimeDivider = beatLength * beatsPerSecond;\n\t\t\t\t}\n\t\t\t\tvar ret = this.addElementToEvents(eventHash, element, voiceTimeMilliseconds, elements[elem].top, elements[elem].height, elements[elem].line, elements[elem].measureNumber, timeDivider, isTiedState, nextIsBar);\n\t\t\t\tisTiedState = ret.isTiedState;\n\t\t\t\tnextIsBar = ret.nextIsBar;\n\t\t\t\tvoiceTime += ret.duration;\n\t\t\t\tvoiceTimeMilliseconds = Math.round(voiceTime * 1000);\n\t\t\t\tif (element.type === 'bar') {\n\t\t\t\t\tvar barType = element.abcelem.type;\n\t\t\t\t\tvar endRepeat = (barType === \"bar_right_repeat\" || barType === \"bar_dbl_repeat\");\n\t\t\t\t\tvar startEnding = (element.abcelem.startEnding === '1');\n\t\t\t\t\tvar startRepeat = (barType === \"bar_left_repeat\" || barType === \"bar_dbl_repeat\" || barType === \"bar_right_repeat\");\n\t\t\t\t\tif (endRepeat) {\n\t\t\t\t\t\tif (endingRepeatElem === -1)\n\t\t\t\t\t\t\tendingRepeatElem = elem;\n\t\t\t\t\t\tfor (var el2 = startingRepeatElem; el2 < endingRepeatElem; el2++) {\n\t\t\t\t\t\t\tvar element2 = elements[el2].elem;\n\t\t\t\t\t\t\tret = this.addElementToEvents(eventHash, element2, voiceTimeMilliseconds, elements[el2].top, elements[el2].height, elements[el2].line, elements[el2].measureNumber, timeDivider, isTiedState, nextIsBar);\n\t\t\t\t\t\t\tisTiedState = ret.isTiedState;\n\t\t\t\t\t\t\tnextIsBar = ret.nextIsBar;\n\t\t\t\t\t\t\tvoiceTime += ret.duration;\n\t\t\t\t\t\t\tvoiceTimeMilliseconds = Math.round(voiceTime * 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextIsBar = true;\n\t\t\t\t\t\tendingRepeatElem = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (startEnding)\n\t\t\t\t\t\tendingRepeatElem = elem;\n\t\t\t\t\tif (startRepeat)\n\t\t\t\t\t\tstartingRepeatElem = elem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// now we have all the events, but if there are multiple voices then there may be events out of order or duplicated, so normalize it.\n\t\ttimingEvents = makeSortedArray(eventHash);\n\t\taddVerticalInfo(timingEvents);\n\t\ttimingEvents.push({ type: \"end\", milliseconds: voiceTimeMilliseconds });\n\t\tthis.addUsefulCallbackInfo(timingEvents, bpm);\n\t\treturn timingEvents;\n\t};\n\n\tthis.addUsefulCallbackInfo = function(timingEvents, bpm) {\n\t\tvar millisecondsPerMeasure = this.millisecondsPerMeasure(bpm);\n\t\tfor (var i = 0; i < timingEvents.length; i++) {\n\t\t\tvar ev = timingEvents[i];\n\t\t\tev.millisecondsPerMeasure = millisecondsPerMeasure;\n\t\t}\n\t};\n\n\tfunction getVertical(group) {\n\t\tvar voices = group.voices;\n\t\tvar firstStaff = group.staffs[0];\n\t\tvar middleC = firstStaff.absoluteY;\n\t\tvar top = middleC - firstStaff.top*spacing.STEP;\n\t\tvar lastStaff = group.staffs[group.staffs.length-1];\n\t\tmiddleC = lastStaff.absoluteY;\n\t\tvar bottom = middleC - lastStaff.bottom*spacing.STEP;\n\t\tvar height = bottom - top;\n\t\treturn { top: top, height: height };\n\t}\n\n\tthis.getBpm = function(tempo) {\n\t\tvar bpm;\n\t\tif (tempo) {\n\t\t\tbpm = tempo.bpm;\n\t\t\tvar beatLength = this.getBeatLength();\n\t\t\tvar statedBeatLength = tempo.duration && tempo.duration.length > 0 ? tempo.duration[0] : beatLength;\n\t\t\tbpm = bpm * statedBeatLength / beatLength;\n\t\t}\n\t\tif (!bpm) {\n\t\t\tbpm = 180;\n\t\t\t// Compensate for compound meter, where the beat isn't a beat.\n\t\t\tvar meter = this.getMeterFraction();\n\t\t\tif (meter && meter.den === 8) {\n\t\t\t\tbpm = 120;\n\t\t\t}\n\t\t}\n\t\treturn bpm;\n\t};\n\n\tthis.setTiming = function (bpm, measuresOfDelay) {\n\t\tif (!bpm) {\n\t\t\tvar tempo = this.metaText ? this.metaText.tempo : null;\n\t\t\tbpm = this.getBpm(tempo);\n\t\t}\n\n\t\tvar beatLength = this.getBeatLength();\n\t\tvar beatsPerSecond = bpm / 60;\n\n\t\tvar measureLength = this.getBarLength();\n\n\t\tvar startingDelay = measureLength / beatLength * measuresOfDelay / beatsPerSecond;\n\t\tif (startingDelay)\n\t\t\tstartingDelay -= this.getPickupLength() / beatLength / beatsPerSecond;\n\t\tvar timeDivider = beatLength * beatsPerSecond;\n\n\t\tthis.noteTimings = this.setupEvents(startingDelay, timeDivider, bpm);\n\t};\n};\n\nmodule.exports = Tune;\n"]},"metadata":{},"sourceType":"script"}