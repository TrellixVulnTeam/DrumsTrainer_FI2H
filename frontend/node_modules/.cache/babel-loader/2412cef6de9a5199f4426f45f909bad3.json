{"ast":null,"code":"var downloadBuffer = function (buffer) {\n  return window.URL.createObjectURL(bufferToWave(buffer.audioBuffers));\n}; // Convert an AudioBuffer to a Blob using WAVE representation\n\n\nfunction bufferToWave(audioBuffers) {\n  var numOfChan = audioBuffers.length;\n  var length = audioBuffers[0].length * numOfChan * 2 + 44;\n  var buffer = new ArrayBuffer(length);\n  var view = new DataView(buffer);\n  var channels = [];\n  var i;\n  var sample;\n  var offset = 0;\n  var pos = 0; // write WAVE header\n\n  setUint32(0x46464952); // \"RIFF\"\n\n  setUint32(length - 8); // file length - 8\n\n  setUint32(0x45564157); // \"WAVE\"\n\n  setUint32(0x20746d66); // \"fmt \" chunk\n\n  setUint32(16); // length = 16\n\n  setUint16(1); // PCM (uncompressed)\n\n  setUint16(numOfChan);\n  setUint32(audioBuffers[0].sampleRate);\n  setUint32(audioBuffers[0].sampleRate * 2 * numOfChan); // avg. bytes/sec\n\n  setUint16(numOfChan * 2); // block-align\n\n  setUint16(16); // 16-bit (hardcoded in this demo)\n\n  setUint32(0x61746164); // \"data\" - chunk\n\n  setUint32(length - pos - 4); // chunk length\n  // write interleaved data\n\n  for (i = 0; i < audioBuffers.length; i++) channels.push(audioBuffers[i].getChannelData(0));\n\n  while (pos < length) {\n    for (i = 0; i < channels.length; i++) {\n      // interleave channels\n      sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp\n\n      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; // scale to 16-bit signed int\n\n      view.setInt16(pos, sample, true); // write 16-bit sample\n\n      pos += 2;\n    }\n\n    offset++; // next source sample\n  } // create Blob\n\n\n  return new Blob([buffer], {\n    type: \"audio/wav\"\n  });\n\n  function setUint16(data) {\n    view.setUint16(pos, data, true);\n    pos += 2;\n  }\n\n  function setUint32(data) {\n    view.setUint32(pos, data, true);\n    pos += 4;\n  }\n}\n\nmodule.exports = downloadBuffer;","map":{"version":3,"sources":["/home/elad/Desktop/Repos/drums-trainer/frontend/node_modules/react-sheet-music/node_modules/abcjs/src/synth/download-buffer.js"],"names":["downloadBuffer","buffer","window","URL","createObjectURL","bufferToWave","audioBuffers","numOfChan","length","ArrayBuffer","view","DataView","channels","i","sample","offset","pos","setUint32","setUint16","sampleRate","push","getChannelData","Math","max","min","setInt16","Blob","type","data","module","exports"],"mappings":"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","sourcesContent":["var downloadBuffer = function(buffer) {\n\treturn window.URL.createObjectURL(bufferToWave(buffer.audioBuffers));\n};\n\n// Convert an AudioBuffer to a Blob using WAVE representation\nfunction bufferToWave(audioBuffers) {\n\tvar numOfChan = audioBuffers.length;\n\tvar length = audioBuffers[0].length * numOfChan * 2 + 44;\n\tvar buffer = new ArrayBuffer(length);\n\tvar view = new DataView(buffer);\n\tvar channels = [];\n\tvar i;\n\tvar sample;\n\tvar offset = 0;\n\tvar pos = 0;\n\n\t// write WAVE header\n\tsetUint32(0x46464952);                         // \"RIFF\"\n\tsetUint32(length - 8);                         // file length - 8\n\tsetUint32(0x45564157);                         // \"WAVE\"\n\n\tsetUint32(0x20746d66);                         // \"fmt \" chunk\n\tsetUint32(16);                                 // length = 16\n\tsetUint16(1);                                  // PCM (uncompressed)\n\tsetUint16(numOfChan);\n\tsetUint32(audioBuffers[0].sampleRate);\n\tsetUint32(audioBuffers[0].sampleRate * 2 * numOfChan); // avg. bytes/sec\n\tsetUint16(numOfChan * 2);                      // block-align\n\tsetUint16(16);                                 // 16-bit (hardcoded in this demo)\n\n\tsetUint32(0x61746164);                         // \"data\" - chunk\n\tsetUint32(length - pos - 4);                   // chunk length\n\n\t// write interleaved data\n\tfor(i = 0; i < audioBuffers.length; i++)\n\t\tchannels.push(audioBuffers[i].getChannelData(0));\n\n\twhile(pos < length) {\n\t\tfor(i = 0; i < channels.length; i++) {             // interleave channels\n\t\t\tsample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp\n\t\t\tsample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; // scale to 16-bit signed int\n\t\t\tview.setInt16(pos, sample, true);          // write 16-bit sample\n\t\t\tpos += 2;\n\t\t}\n\t\toffset++; // next source sample\n\t}\n\n\t// create Blob\n\treturn new Blob([buffer], {type: \"audio/wav\"});\n\n\tfunction setUint16(data) {\n\t\tview.setUint16(pos, data, true);\n\t\tpos += 2;\n\t}\n\n\tfunction setUint32(data) {\n\t\tview.setUint32(pos, data, true);\n\t\tpos += 4;\n\t}\n}\n\nmodule.exports = downloadBuffer;\n"]},"metadata":{},"sourceType":"script"}